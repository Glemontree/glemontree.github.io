[{"title":"[DB] MySQL中distinct的用法","date":"2018-04-09T08:28:44.000Z","path":"2018/04/09/[DB] MySQL中distinct的用法/","text":"distinct用法在使用MySQL时，有时需要查出某个字段不重复的字段，这时可以使用MySQL提供的distinct关键字来过滤重复的记录，但是实际中往往使用distinct来返回不重复字段的条数（count(distinct id)），其原因是distinct只能返回它的目标字段，而无法返回其他字段，其常见用法为： 1select distinct name from user; 这样可以将不重复的用户名查询出来，但是用户的id并不会被查询出来，如果使用下面的语句： 1selelct distinct name, id from user; 则MySQL会认为要过滤掉name和id两个字段均不重复的字段，如果使用下面的sql语句： 1select id, distinct name from user; 则MySQL会报错，因为distinct必须放在要查询字段的开头。 distinct一般用来查询不重复记录的条数。 说明本文转自mysql中去重 distinct 用法。","tags":[{"name":"distinct","slug":"distinct","permalink":"https://glemontree.github.io/tags/distinct/"}]},{"title":"[DB] MySQL中group by的用法","date":"2018-04-09T08:10:26.000Z","path":"2018/04/09/[DB] MySQL中group by的用法/","text":"group by的用法group by的常规用法group by的常规用法是配合聚合函数，利用分组信息进行统计，常见的是配合max等聚合函数筛选数据后分析，以及配合having进行筛选后过滤。 创建数据库表 123456789CREATE TABLE `user_info` ( `id` INT(11) NOT NULL AUTO_INCREMENT COMMENT '主键id', `user_id` VARCHAR(50) NOT NULL DEFAULT '' COMMENT '用户编号', `grade` VARCHAR(50) NOT NULL DEFAULT '' COMMENT '年级', `class` VARCHAR(50) NOT NULL DEFAULT '' COMMENT '班级', PRIMARY KEY (`id`), UNIQUE INDEX `uniq_user_id` (`user_id`))ENGINE=InnoDB 插入数据 12345678910INSERT INTO `user_info` (`id`, `user_id`, `grade`, `class`) VALUES (10, '10230', 'C', 'B');INSERT INTO `user_info` (`id`, `user_id`, `grade`, `class`) VALUES (9, '10229', 'C', 'a');INSERT INTO `user_info` (`id`, `user_id`, `grade`, `class`) VALUES (8, '10228', 'B', 'b');INSERT INTO `user_info` (`id`, `user_id`, `grade`, `class`) VALUES (7, '10227', 'B', 'b');INSERT INTO `user_info` (`id`, `user_id`, `grade`, `class`) VALUES (6, '10226', 'B', 'a');INSERT INTO `user_info` (`id`, `user_id`, `grade`, `class`) VALUES (5, '10225', 'B', 'a');INSERT INTO `user_info` (`id`, `user_id`, `grade`, `class`) VALUES (4, '10224', 'A', 'b');INSERT INTO `user_info` (`id`, `user_id`, `grade`, `class`) VALUES (3, '10223', 'A', 'b');INSERT INTO `user_info` (`id`, `user_id`, `grade`, `class`) VALUES (2, '10222', 'A', 'a');INSERT INTO `user_info` (`id`, `user_id`, `grade`, `class`) VALUES (1, '10221', 'A', 'a'); 配合max聚合函数筛选数据 1select max(user_id), grade from user_info group by grade; 这条sql语句的意思就是将数据按照grade字段进行分组，查询每组最大的user_id以及当前组内容，这里的分组条件是grade，查询的非聚合条件是grade。 结果 | max(user_id) | grade || ———— | —– || 10224 | A || 10228 | B || 10230 | C | 配合having进行筛选后过滤 1select max(user_id), grade from user_info group by grade having grade &gt; 'A'; 结果 | max(user_id) | grade || ———— | —– || 10228 | B || 10230 | C | group by的非常规用法1select max(user_id), id, grade from user_info group by grade; 结果为： max(user_id) id grade 10224 1 A 10228 5 B 10230 9 C 与上述例子不同的是，查询条件多了id一列。数据按照grade分组后，grade一列是相同的，max(user_id)按照数据进行计算也是唯一的，id一列是如何取值的？看上述的数据结果，推论：id是物理内存的第一个匹配项。 结论 当group by 与聚合函数配合使用时，功能为分组后计算 当group by 与having配合使用时，功能为分组后过滤 当group by 与聚合函数，同时非聚合字段同时使用时，非聚合字段的取值是第一个匹配到的字段内容，即id小的条目对应的字段内容。 说明本文转自mysql中group by 的用法解析。","tags":[{"name":"group by","slug":"group-by","permalink":"https://glemontree.github.io/tags/group-by/"},{"name":"max","slug":"max","permalink":"https://glemontree.github.io/tags/max/"},{"name":"having","slug":"having","permalink":"https://glemontree.github.io/tags/having/"}]},{"title":"[Java] 静态代理、JDK动态代理与CGLIB动态代理","date":"2018-04-05T12:01:20.000Z","path":"2018/04/05/[Java] 静态代理、JDK动态代理与CGLIB动态代理/","text":"代理模式代理模式是常用设计模式的一种，常见的代理模式有静态代理和动态代理两大类，在Java中动态代理又可分为JDK动态代理和CGLIB动态代理，下面我们分别进行讲述！ 静态代理静态代理由业务实现类、业务代理类两部分组成，业务实现类负责实现主要的业务方法，业务代理类负责对调用的业务方法进行拦截、过滤、预处理，我们在需要调用业务时不是直接通过业务实现类来调用的，而是通过业务代理类的同名方法来调用被代理类处理过的业务方法。 静态代理的实现过程 接口，声明业务逻辑 12345678910 /** * 定义一个账户接口 */ public interface Count &#123; // 查询账户 public void queryCount(); // 修改账户 public void updateCount(); &#125; 业务实现类，实现业务逻辑接口 123456789101112131415/** * 委托类(包含业务逻辑) */ public class CountImpl implements Count &#123; @Override public void queryCount() &#123; System.out.println(\"查看账户...\"); &#125; @Override public void updateCount() &#123; System.out.println(\"修改账户...\"); &#125; &#125; 业务代理类，通过组合，在代理类中创建一个业务实现类对象来调用具体的业务方法；通过实现业务逻辑接口，来统一业务方法；在代理类中实现业务逻辑接口中的方法时，进行预处理操作、通过业务实现类对象调用真正的业务方法、进行调用后操作的定义。 123456789101112131415161718192021222324252627public class CountProxy implements Count &#123; private CountImpl countImpl; //组合一个业务实现类对象来进行真正的业务方法的调用 /** * 覆盖默认构造器 * @param countImpl */ public CountProxy(CountImpl countImpl) &#123; this.countImpl = countImpl; &#125; @Override public void queryCount() &#123; System.out.println(\"查询账户的预处理——————\"); // 调用真正的查询账户方法 countImpl.queryCount(); System.out.println(\"查询账户之后————————\"); &#125; @Override public void updateCount() &#123; System.out.println(\"修改账户之前的预处理——————\"); // 调用真正的修改账户操作 countImpl.updateCount(); System.out.println(\"修改账户之后——————————\"); &#125; &#125; 使用，首先创建业务实现类对象，然后把业务实现类对象作构造参数创建一个代理类对象，最后通过代理类对象进行业务方法的调用。 123456public static void main(String[] args) &#123; CountImpl countImpl = new CountImpl(); CountProxy countProxy = new CountProxy(countImpl); countProxy.updateCount(); countProxy.queryCount(); &#125; 静态代理的缺点 一个代理类只能对一个业务接口的实现类进行包装，如果有多个业务接口的话就要定义很多实现类和代理类才行 如果代理类对业务方法的预处理、调用后操作都是一样的（比如：调用前输出提示、调用后自动关闭连接），则多个代理类就会有很多重复代码。 JDK动态代理JDK动态代理所用到的代理类在程序调用到代理类对象时才由JVM真正创建，JVM根据传进来的业务实现类对象以及方法名，动态的创建了一个代理类的class文件并被字节码引擎执行，然后通过该代理类对象进行方法调用，我们需要做的，只需要指定代理类的预处理、调用后操作即可。 JDK动态代理的实现过程 定义业务逻辑接口 123public interface BookFacade &#123; public void addBook(); &#125; 实现业务逻辑接口创建业务实现类 123456public class BookFacadeImpl implements BookFacade &#123; @Override public void addBook() &#123; System.out.println(\"增加图书方法。。。\"); &#125; &#125; 实现调用管理接口InvocationHandler，创建动态代理类 123456789101112131415161718192021222324252627public class BookFacadeProxy implements InvocationHandler &#123; private Object target;//这是业务实现类对象，用来调用具体的业务方法 /** * 绑定业务对象并返回一个代理类 */ public Object bind(Object target) &#123; this.target = target; //接收业务实现类对象参数 //通过反射机制，创建一个代理类对象实例并返回。用户进行方法调用时使用 //创建代理对象时，需要传递该业务类的类加载器（用来获取业务实现类的元数据，在包装方法是调用真正的业务方法）、接口、handler实现类 return Proxy.newProxyInstance(target.getClass().getClassLoader(), target.getClass().getInterfaces(), this); &#125; /** * 包装调用方法：进行预处理、调用后处理 */ public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; Object result=null; System.out.println(\"预处理操作——————\"); //调用真正的业务方法 result=method.invoke(target, args); System.out.println(\"调用后处理——————\"); return result; &#125; &#125; 在使用时，首先创建一个业务实现类对象和一个代理类对象，然后定义接口引用（这里使用向上转型）并用代理对象.bind(业务实现类对象)的返回值进行赋值。最后通过接口引用调用业务方法即可。（接口引用真正指向的是一个绑定了业务类的代理类对象，所以通过接口方法名调用的是被代理的方法们） 123456public static void main(String[] args) &#123; BookFacadeImpl bookFacadeImpl=new BookFacadeImpl(); BookFacadeProxy proxy = new BookFacadeProxy(); BookFacade bookfacade = (BookFacade) proxy.bind(bookFacadeImpl); bookfacade.addBook(); &#125; 注意点JDK动态代理的代理对象在创建时，需要使用业务实现类所实现的接口作为参数（因为后面代理方法时需要根据接口内的方法名进行调用），如果业务实现类是没有实现接口而是直接定义定义业务方法的话，就无法使用JDK动态代理了，并且，如果业务实现类中新增了接口中没有的方法，这些方法是无法被代理的（因为无法被调用）。 CGLIB实现动态代理CGLIB是针对类来实现代理的，原理是对指定的业务类生成一个子类，并覆盖其中业务方法实现代理，因为采用的是继承，所以不能对final修饰的类进行代理。 CGLIB实现动态代理的过程 定义业务类，无需实现接口（当然，实现接口也可以） 12345public class BookFacadeImpl1 &#123; public void addBook() &#123; System.out.println(\"新增图书...\"); &#125; &#125; 实现MethodInterceptor方法代理接口，创建代理类 1234567891011121314151617181920public class BookFacadeCglib implements MethodInterceptor &#123; private Object target;//业务类对象，供代理方法中进行真正的业务方法调用 //相当于JDK动态代理中的绑定 public Object getInstance(Object target) &#123; this.target = target; //给业务对象赋值 Enhancer enhancer = new Enhancer(); //创建加强器，用来创建动态代理类 enhancer.setSuperclass(this.target.getClass()); //为加强器指定要代理的业务类（即：为下面生成的代理类指定父类） //设置回调：对于代理类上所有方法的调用，都会调用CallBack，而Callback则需要实现intercept()方法进行拦 enhancer.setCallback(this); // 创建动态代理类对象并返回 return enhancer.create(); &#125; // 实现回调方法 public Object intercept(Object obj, Method method, Object[] args, MethodProxy proxy) throws Throwable &#123; System.out.println(\"预处理——————\"); proxy.invokeSuper(obj, args); //调用业务类（父类中）的方法 System.out.println(\"调用后操作——————\"); return null; &#125; 创建业务类和代理类对象，然后通过代理类对象.getInstance(业务类对象)返回一个动态代理类对象（它是业务类的子类，可以用业务类引用指向它），最后通过动态代理类对象进行方法调用。 123456public static void main(String[] args) &#123; BookFacadeImpl1 bookFacade=new BookFacadeImpl1()； BookFacadeCglib cglib=new BookFacadeCglib(); BookFacadeImpl1 bookCglib=(BookFacadeImpl1)cglib.getInstance(bookFacade); bookCglib.addBook(); &#125; 声明本文转自Java动态代理之JDK实现和CGlib实现（简单易懂）。","tags":[{"name":"代理模式","slug":"代理模式","permalink":"https://glemontree.github.io/tags/代理模式/"}]},{"title":"[C++] 动态链接库","date":"2018-03-30T05:06:09.000Z","path":"2018/03/30/[C++] 动态链接库/","text":"VS中使用动态链接库 添加头文件目录 配置属性 –&gt; C/C++ –&gt; 常规 –&gt; 附加包含目录，加入头文件存放的目录 添加lib文件 配置属性 –&gt; 链接器 –&gt; 输入 –&gt; 附加依赖项加入库名（xxx.lib），或者在cpp文件中用#pragma comment(lib, &quot;xxx.lib&quot;)来代替。 此时编译会提示：fatal error LNK1104：无法打开文件“xxx.lib”，原因是编译器找不到lib文件。 给项目添加库文件路径 在VS中右击项目选择属性，配置属性 –&gt; 链接器 –&gt; 常规 –&gt; 附加目录，在里面填上库文件所在的路径即可。 加载DLL 将dll文件拷贝到工程debug目录下（如果不拷贝，编译链接不报错，但是运行报错：无法找到*.dll），或者在系统环境变量中加入dll文件的路径。 另外一种方法就是右击项目选择属性，配置属性 –&gt; 调试 –&gt; 右侧环境，编辑 –&gt; 添加dll文件所在的路径，可以是绝对路径，也可以是相对路径，需要注意最后一定要以半角分号结束，例如PATH=dll所在路径。 DLL和LIB文件的区别lib是一个二进制文件，与dll类似，供其他程序调用，lib与dll的区别是：dll是运行时需要的，lib是编译时需要的。 共有两种库： lib文件包含了函数所在的dll文件和文件中函数位置的信息（入口），代码由运行时加载在进行空间中的DLL提供，称为动态链接库； lib文件包含了函数代码本身，在编译时直接将代码加入程序当中，称为静态链接库。 关于lib和dll的区别如下： lib是编译时用到的，dll是运行时用到的，如果要完成源代码的编译，只需要lib，如果要使动态链接的程序运行起来，只需要dll； 如果有dll文件，那么lib一般是一些索引信息，记录了dll中函数的入口和位置，dll中是函数的具体内容；如果只有lib文件，那么这个lib文件是静态编译出来的，索引和实现都在其中，使用静态编译的lib文件，在运行程序时不需要再挂动态库，缺点是导致应用程序比较大，而且失去了动态库的灵活性，发布新版本时要发布新的应用程序才行； 动态链接的情况下，有两个 文件：一个是LIB文件，一个是DLL文件。LIB包含被DLL导出的函数名称和位置，DLL包含实际的函数和数据，应用程序使用LIB文件链接到DLL 文件。在应用程序的可执行文件中，存放的不是被调用的函数代码，而是DLL中相应函数代码的地址，从而节省了内存资源。DLL和LIB文件必须随应用程序 一起发行，否则应用程序会产生错误。 动态链接库和静态链接库分别需要的文件： 使用静态链接库需要包含两个文件： .h头文件，包含lib中说明输出的类或符号原型或数据结构，应用程序调用lib时，需要将该文件包含入应用程序的源文件中； .lib文件 使用dll需要包含三个文件： .h头文件，包含dll中说明输出的类或符号原型或数据结构的.h文件，应用程序调用dll时，需要将该文件包含入应用程序的源文件中； .lib文件，是dll在编译、链接成功之后生成的文件，作用是当其他程序调用dll时，需要将该文件引入应用程序，否则产生错误； .dll文件，真正的可执行文件，开发成功的应用程序在发布时，只需要.exe文件和.dll文件，并不需要.lib文件和.h文件。 本小节转自LIB,DLL区别 及 VS中如何添加LIB,DLL。","tags":[{"name":"动态链接库","slug":"动态链接库","permalink":"https://glemontree.github.io/tags/动态链接库/"}]},{"title":"[网络编程] Linux网络编程常用函数","date":"2018-03-28T01:59:01.000Z","path":"2018/03/28/[网络编程] Linux网络编程常用函数/","text":"socket函数 1int socket(int domain, int type, int protocol) domain：主机采用的通讯协议族（AF_UNIX和AF_INET），AF_UNIX只能够用于单一的Unix系统进程间进行通信，而AF_INET是针对Internet的。因而允许在远程主机之间进行通信。 type：采用的通信协议（SOCK_STREAM、SOCK_DGRAM等），SOCK_STREAM表明我们用的是TCP协议，而SOCK_DGRAM表示使用的是UDP协议。 protocol：由于指定了type，所以protocol的值一般为0 socket()函数成功时返回文件描述符，失败时返回-1，看errno可知道出错的详细情况。 bind函数 1int bind(int sockfd, struct sockaddr* my_addr, int addrlen); sockfd：socket函数返回的文件描述符 addrlen：是sockaddr结构的长度 my_addr：一个指向sockaddr的指针，struct sockaddr的定义如下： 1234struct sockaddr &#123; unsigned short as_family; char sa_data[14];&#125;; 不过由于系统的兼容性，一般不用这个头文件，而使用另外一个结构（struct sockaddr_in）来代替，其定义如下： 123456struct sockaddr_in &#123; unsigned short sin_family; unsigned short int sin_port; struct in_addr sin_addr; unsigned char sin_zero[8];&#125;; 我们主要使用Internet，所以sin_family一般为AF_INET，sin_addr设置为INADDR_ANY表示可以和任何的主机通信，sin_port是监听的端口号，sin_zero[8]是用来填充的。 bind函数的作用就是将本地的端口和socket函数返回的文件描述符捆绑在一起，成功时返回0。 linten函数 1int linten(int sockfd, int backlog); sockfd：是bind后的文件描述符 backlog：设置请求队列的最大长度 listen函数的作用就是bind的文件描述符转为监听套接字。 accept函数 1int accept(int sockfd, struct sockaddr* addr, int* addrlen); sockfd：是listen后的文件描述符 addr、addrlen是用来给客户端的程序填写的，服务器端只要传递指针就可以了，bind、listen和accept是服务器端用的函数，accept调用时，服务器端的程序会一直阻塞到有一个客户程序发出了连接，accept成功时返回最后的服务器端的文件描述符，这个时候服务器端就可以向该描述符写信息了。 connect函数 1int connect(int sockfd, struct sockaddr* serv_addr, int addrlen); sockfd：socket返回的文件描述符 serv_addr：存储了服务器端的连接信息，其中sin_addr是服务端的地址 addr_len：serv_addr的长度 connect函数是客户端用来同服务端连接的，成功时返回0。 setsockopt函数 1int setsockopt(socket s, int level, int optname, const char* optval, int optlen); s：指向一个打开的套接字描述符 level： SOL_SOCKET：基本套接口 IPPROTO_IP：IPV4套接口 IPPROTO_IPV6：IPV6套接口 IPPROTO_TCP：TCP套接口 optname：选项名称 optval：指针，指向存放选项值的缓冲区 optlen：optval缓冲区长度 inet_ntop函数 1const char* inet_ntop(int af, const void* src, char* dst, socklen_t cnt); 这个函数转换网络二进制结构到ASCII类型的地址。 af：地址簇，其取值可以为AF_INET、AF_INET6 src：来源地址 dst：接收转换后的数据 cnt：缓冲区dst的大小 ntohs函数 将一个16位数由网络字节序转换为主机字节顺序。","tags":[{"name":"Linux, 网络编程","slug":"Linux-网络编程","permalink":"https://glemontree.github.io/tags/Linux-网络编程/"}]},{"title":"[设计模式] 抽象工厂模式","date":"2018-03-25T08:03:31.000Z","path":"2018/03/25/[设计模式] 抽象工厂模式/","text":"模式定义抽象工厂模式提供一个创建一系列相关或相关依赖对象的接口。 模式结构抽象工厂模式包含以下角色： AbstractFactory：抽象工厂 ConcreteFactory：具体工厂 AbstractProduct：抽象产品 Product：具体产品 代码实现 Engine接口 123public interface Engine &#123; void engine();&#125; Light接口 123public interface Light &#123; void light();&#125; BMWEngine 123456public class BMWEngine implements Engine &#123; @Override public void engine() &#123; System.out.println(\"bmw engine\"); &#125;&#125; BMWLight 1234567public class BMWLight implements Light &#123; @Override public void light() &#123; System.out.println(\"bmw light\"); &#125;&#125; AudiEngine 123456public class AudiEngine implements Engine &#123; @Override public void engine() &#123; System.out.println(\"audi engine\"); &#125;&#125; AudiLight 123456public class AudiLight implements Light &#123; @Override public void light() &#123; System.out.println(\"audi light\"); &#125;&#125; Factory接口 1234public interface Factory &#123; Engine createEngine(); Light createLight();&#125; BMWFactory 1234567891011public class BMWFactory implements Factory &#123; @Override public Engine createEngine() &#123; return new BMWEngine(); &#125; @Override public Light createLight() &#123; return new BMWLight(); &#125;&#125; AudiFactory 1234567891011public class AudiFactory implements Factory &#123; @Override public Engine createEngine() &#123; return new AudiEngine(); &#125; @Override public Light createLight() &#123; return new AudiLight(); &#125;&#125; Test 123456789public class Test &#123; public static void main(String[] args) &#123; Factory factory = new AudiFactory(); Engine engine = factory.createEngine(); Light light = factory.createLight(); engine.engine(); light.light(); &#125;&#125; 总结 抽象工厂模式包含四个角色： 抽象工厂用于声明生成抽象产品的方法 具体工厂实现了抽象工厂声明的生成抽象产品的方法，生成一组具体产品，这些产品构成了一个产品族 抽象产品为某种产品声明接口，在抽象产品中定义了产品的抽象业务方法 具体产品定义具体工厂生成的具体产品对象，实现抽闲产品接口中定义的业务方法 抽象工厂模式和工厂方法模式最大的区别在于，工厂方法模式针对的是一个产品等级结构，而抽象工厂模式则需要面对多个产品等级结构 本文转自3.抽象工厂模式。","tags":[{"name":"抽象工厂模式","slug":"抽象工厂模式","permalink":"https://glemontree.github.io/tags/抽象工厂模式/"}]},{"title":"[设计模式] 工厂方法模式","date":"2018-03-25T06:13:24.000Z","path":"2018/03/25/[设计模式] 工厂方法模式/","text":"模式定义在工厂方法模式中，工厂父类负责定义创建产品对象的公共接口，而工厂子类则负责生成具体的产品对象。 模式结构工厂方法模式包含以下角色： Product：抽象产品 ConcreteProduct：具体产品 Factory：抽象工厂 ConcreteFactory：具体工厂 相对于简单工厂模式的优点在工厂方法模式中，核心的工厂类不再负责所有产品的创建，而是将具体创建工作交给子类去做，这个核心类仅仅负责给出具体工厂必须实现的接口，而不负责哪一个产品类被实例化这种细节，这使得工厂方法模式可以允许系统在不修改工厂角色的情况下引入新产品。 代码 Product接口 123public interface Product &#123; void name();&#125; BMW 123456public class BMW implements Product &#123; @Override public void name() &#123; System.out.println(\"bmw...\"); &#125;&#125; Audi 123456public class Audi implements Product &#123; @Override public void name() &#123; System.out.println(\"audi...\"); &#125;&#125; Factory接口 123public interface Factory &#123; Product create();&#125; BMWFactory 123456public class BMWFactory implements Factory &#123; @Override public Product create() &#123; return new BMW(); &#125;&#125; AudiFactory 123456public class AudiFactory implements Factory &#123; @Override public Product create() &#123; return new Audi(); &#125;&#125; Test 1234567public class Test &#123; public static void main(String[] args) &#123; Factory factory = new AudiFactory(); Product product = factory.create(); product.name(); &#125;&#125; 总结 工厂方法模式包含四个角色： 抽象产品是定义产品的接口，是工厂方法模式所创建对象的超类，即产品对象的共同父类或接口 具体产品实现了抽象产品接口，某种类型的具体产品由专门的具体工厂创建，它们之间往往是一一对应 抽象工厂中声明了工厂方法，用于返回一个产品，它是工厂方法模式的核心，任何在模式中创建对象的工厂类必须实现该接口 具体工厂是抽象工厂类的子类，实现了抽象工厂中定义的工厂方法，并可由客户调用，返回一个具体产品类的实例 工厂方法模式允许系统在不修改工厂角色的情况下引进新产品 工厂方法模式的缺点在于增加新产品的同时需要增加新的工厂，导致系统类的个数成对增加 本文转自2.工厂方法模式。","tags":[{"name":"工厂方法模式","slug":"工厂方法模式","permalink":"https://glemontree.github.io/tags/工厂方法模式/"}]},{"title":"[设计模式] 简单工厂模式","date":"2018-03-23T15:09:50.000Z","path":"2018/03/23/[设计模式] 简单工厂模式/","text":"模式定义简单工厂模式又称为静态工厂方法，在简单工厂模式中可以根据参数的不同返回不同类的实例，简单工厂模式专门定义一个类来负责创建其他类的实例，被创建的实例通常具有共同的父类。 模式结构 Factory：工厂角色，负责实现创建所有实例的内部逻辑 Product：抽象产品角色，是所创建的所有对象的父类，负责描述所有实例共有的公共接口 ConcreteProduct：具体产品角色。 代码实现 Product抽象类 123public interface Product &#123; void use();&#125; Product类仅仅提供一个接口，具体不同的商品实现不同的use()方法。 ConcreteProductA 123456public class ConcreteProductA implements Product &#123; @Override public void use() &#123; System.out.println(\"ConcreteProductA...\"); &#125;&#125; ConcreteProductB 123456public class ConcreteProductB implements Product &#123; @Override public void use() &#123; System.out.println(\"ConcreteProductB...\"); &#125;&#125; SimpleFactory 12345678910public class SimpleFactory &#123; public static Product createProduct(String name) &#123; if (name.equals(\"A\")) &#123; return new ConcreteProductA(); &#125; else if (name.equals(\"B\")) &#123; return new ConcreteProductB(); &#125; return null; &#125;&#125; Test 123456public class Test &#123; public static void main(String[] args) &#123; Product product = SimpleFactory.createProduct(\"A\"); product.use(); &#125;&#125; ​","tags":[{"name":"简单工厂模式","slug":"简单工厂模式","permalink":"https://glemontree.github.io/tags/简单工厂模式/"}]},{"title":"[Redis] Redis数据类型","date":"2018-03-23T13:16:39.000Z","path":"2018/03/23/[Redis] Redis原理/","text":"Redis数据类型与Memcached仅支持简单的key-value结构的数据记录不同，Redis支持的数据类型有String、List、Hash、Set和Sorted Set。 Redis内部使用一个redisObject对象来表示所有的key和value，在上图中，type代表一个value对象具体是何种数据类型，encoding是不同数据类型在redis内部的存储方式，比如：type=string代表value存储的是一个普通的字符串，那么对应的encoding可以是raw或者int，如果是int则代表实际redis内部是按数值类型存储和表示这个字符串的，当然前提是这个字符串本身可以用数值表示。 上图中vm字段只有打开了Redis的虚拟内存功能，此字段才会真正的分配内存，该功能默认是关闭状态的。 String类型字符串是Redis的最基础的类型，Redis中使用的字符串是通过包装的，基于C语言字符数组实现的简单动态字符串（Simple Dynamic String, sds）一个抽象数据结构。 12345struct sdshdr &#123; int len; // len表示buf中存储的字符串的长度 int free; // free表示buf中空闲空间的长度 char buf[]; // buf用来存储字符串内容&#125;; String是最常用的数据类型，普通的key-value都可以归为此类。 Hash类型Hash是一个String类型的field和value之间的映射表，即Redis的Hash数据类型的key对应的value实际的内部存储结构是一个HashMap，因此Hash特别适合存储对象。 Hash类型通常用一个对象存储用户信息、商品信息、订单信息等。 List类型Redis的List类型其实就是每一个元素都是String类型的双向链表，可以从链表的头部和尾部添加或者删除元素，因此，其既可以作为栈，也可以作为队列来使用。 List类型通常用在好友列表、粉丝列表、消息队列、最新消息排行等场合。 Set类型Redis的Set类型是一个无序的String类型数据的集合，与List不同的是Set不能有重复的数据。实际上，Set内部是用HashMap实现的，Set只用了HashMap的key列来存储对象。 Set类型有取交集、并集、差集等操作，通常用在求共同好友、共同兴趣、分类标签等。","tags":[{"name":"Redis","slug":"Redis","permalink":"https://glemontree.github.io/tags/Redis/"}]},{"title":"[Java] Java虚拟机垃圾收集","date":"2018-03-23T09:08:56.000Z","path":"2018/03/23/[Java] Java虚拟机垃圾收集/","text":"垃圾收集算法 可作为GC Roots的对象包括： 虚拟机栈（栈帧中的本地变量表）中的引用对象 方法区中的类静态属性引用的对象 方法区中的常量引用的对象 本地方法栈中JNI的引用对象 标记-清除算法其缺点为： 效率不高 标记清除之后会产生大量不连续的内存碎片 复制算法它将可用内存容量划分为大小相等的两块，每次只使用其中的一块，当这一块用完之后，就将还存活的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉，这样使得每次都是对其中一块内存进行回收，不会产生碎片等情况。其缺点是内存缩小为原来的一半。 标记-清理算法其缺点为在标记-清除的基础上还需进行对象的移动，成本相对较高，好处就是不会产生内存碎片。 垃圾收集器 如上图所示，有7种收集器，分为两块，上面为新生代收集器，下面为老年代收集器，如果两个收集器之间存在连线，就说明它们可以搭配使用。 Serial(串行GC)收集器其为一个新生代的收集器，单线程执行，使用复制算法，它在进行垃圾回收的时候，必须暂停其他所有的工作线程（用户线程），对于限定单个CPU的环境来说，Serial收集器由于没有线程交互的开销，专心做垃圾收集自然可以获得最高的单线程手机效率。 ParNew(并行)收集器ParNew收集器就是Serial收集器的多线程版本。 Parallel Scavenge(并行回收GC)收集器Parallel Scavenge收集器也是一个新生代收集器，它也是使用复制算法的收集器，又是并行多线程收集器， Parallel Scavenge收集器的特点是它的关注点与其他收集器不同，CMS等收集器的关注点是尽可能缩短垃圾收集时用户线程的停顿时间，而Parallel Scavenge收集器的目标则是达到一个可控制的吞吐量，吞吐量 = 程序运行时间 / （程序运行时间 + 垃圾收集时间）。 Serial Old(串行GC)收集器其为Serial收集器的老年代版本，它同样使用一个单线程执行收集，使用“标记-整理”算法。 Parallel Old(并行GC)收集器Parallel Old是Parallel Scavenge收集器的老年代版本，使用多线程和“标记-整理”算法。 CMS(并发GC)收集器CMS（Concurrent Mark Sweep）收集器是一种以获取最短回收停顿时间为目标的收集器，CMS收集器是基于“标记-清除”算法实现的，整个收集过程分为4个步骤： 初始标记 并发标记 重新标记 并发清除 其中初始标记、重新标记这两个步骤任然需要停顿其他用户线程。初始标记仅仅只是标记出GC ROOTS能直接关联到的对象，速度很快，并发标记阶段是进行GC ROOTS 根搜索算法阶段，会判定对象是否存活。而重新标记阶段则是为了修正并发标记期间，因用户程序继续运行而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间会被初始标记阶段稍长，但比并发标记 阶段要短。 由于整个过程中耗时最长的并发标记和并发清除过程中，收集器线程都可以与用户线程一起工作，所以整体来说，CMS收集器的内存回收过程是与用户线程一起并发执行的。 CMS收集器的优点：并发收集、低停顿，但是CMS还远远达不到完美，器主要有三个显著缺点： CMS收集器对CPU资源非常敏感。在并发阶段，虽然不会导致用户线程停顿，但是会占用CPU资源而导致引用程序变慢，总吞吐量下降。CMS默认启动的回收线程数是：(CPU数量+3) / 4。 G1收集器G1（Garbage First）收集器是JDK1.7提供的一个新收集器，G1收集器基于“标记-整理”算法实现，不会产生内存碎片，还有一个特点就是G1将整个Java堆（包括新生代和老年代）。 说明本文转载自Java虚拟机学习 - 垃圾收集器 （4）。","tags":[]},{"title":"[SpringMVC] HTTP协议中GET、PUT、DELETE、POST与幂等性","date":"2018-03-20T12:40:32.000Z","path":"2018/03/20/[SpringMVC] HTTP协议中GET、PUT、DELETE、POST与幂等性/","text":"幂等性 幂等性即为不管进行多少次重复操作，或者说一次和多次请求某一个资源应该具有相同的副作用。 REST请求中的幂等性操作 GET、PUT和DELETE都是幂等操作，而POST不是。 GET方法用于获取资源，不应有副作用，所以是幂等的，需要注意的是，这里强调的是一次和多次具有相同的副作用，而不是多次GET请求的结果相同 DELETE方法用于删除资源，第一次将资源删除后，后面多次进行此删除操作，最终结果都是一样的 PUT请求的幂等性可以这样理解，将A改成B，第一次请求值变成了B，再进行多次此操作，最终的结果还是B，与一次执行的结果是一样的 POST方法会在服务器端创建资源，两次相同的POST请求会在服务器端产生两份资源，它们具有不同的URI，因此，POST请求不具有幂等性 分布式事务与幂等性 看下面的例子，假设有一个从账户取钱的远程API，我们暂时用函数的方式记为： 1bool withdraw(account_id, amount); withdraw的语义是从account_id对应的账户中扣除amount数额的钱；如果扣除成功则返回true，账户余额减少amount；如果扣除失败则返回false，账户余额不变。值得注意的是：和本地环境相比，我们不能轻易假设分布式环境的可靠性。一种典型的情况是withdraw请求已经被服务器端正确处理，但服务器端的返回结果由于网络等原因被掉丢了，导致客户端无法得知处理结果。如果是在网页上，一些不恰当的设计可能会使用户认为上一次操作失败了，然后刷新页面，这就导致了withdraw被调用两次，账户也被多扣了一次钱。 这个问题的解决方案一是采用分布式事务，通过引入支持分布式事务的中间件来保证withdraw功能的事务性。分布式事务的优点是对于调用者很简单，复杂性都交给了中间件来管理。缺点则是一方面架构太重量级，容易被绑在特定的中间件上，不利于异构系统的集成；另一方面分布式事务虽然能保证事务的ACID性质，而但却无法提供性能和可用性的保证。 另一种更轻量级的解决方案是幂等设计。我们可以通过一些技巧把withdraw变成幂等的，比如： 12int create_ticket() bool idempotent_withdraw(ticket_id, account_id, amount) create_ticket的语义是获取一个服务器端生成的唯一的处理号ticket_id，它将用于标识后续的操作。idempotent_withdraw和withdraw的区别在于关联了一个ticket_id，一个ticket_id表示的操作至多只会被处理一次，每次调用都将返回第一次调用时的处理结果。这样，idempotent_withdraw就符合幂等性了，客户端就可以放心地多次调用。 基于幂等性的解决方案中一个完整的取钱流程被分解成了两个步骤：1.调用create_ticket()获取ticket_id；2.调用idempotent_withdraw(ticket_id, account_id, amount)。虽然create_ticket不是幂等的，但在这种设计下，它对系统状态的影响可以忽略，加上idempotent_withdraw是幂等的，所以任何一步由于网络等原因失败或超时，客户端都可以重试，直到获得结果。 根据幂等性区分POST和PUT的使用 举一个简单的例子，假如有一个博客系统提供一个Web API，模式是这样http://superblogging/blogs/{blog-name}，很简单，将{blog-name}替换为我们的blog名字，往这个URI发送一个HTTP PUT或者POST请求，HTTP的body部分就是博文，这是一个很简单的REST API例子。 我们应该用PUT方法还是POST方法？ 取决于这个REST服务的行为是否是idempotent的，假如我们发送两个http://superblogging/blogs/post/Sample请求，服务器端是什么样的行为？如果产生了两个博客帖子，那就说明这个服务不是idempotent的，因为多次使用产生了副作用了嘛；如果后一个请求把第一个请求覆盖掉了，那这个服务就是idempotent的。前一种情况，应该使用POST方法，后一种情况，应该使用PUT方法。 本文转自利用幂等性区分HTTP的POST与PUT请求和HTTP幂等性及GET、POST、PUT、DELETE的区别。","tags":[{"name":"幂等性","slug":"幂等性","permalink":"https://glemontree.github.io/tags/幂等性/"}]},{"title":"[算法] 背包问题","date":"2018-01-30T05:32:21.000Z","path":"2018/01/30/[算法] 背包问题/","text":"题目： ​ 在n个物品中挑选若干物品装入背包，最多能装多满？假设背包的大小为m，每个物品的大小为A[i] 样例： ​ 如果有4个物品[2, 3, 5, 7] ​ 如果背包的大小为11，可以选择[2, 3, 5]装入背包，最多可以装满10的空间。 ​ 如果背包的大小为12，可以选择[2, 3, 7]装入背包，最多可以装满12的空间。 ​ 函数需要返回最多能装满的空间大小。 代码： 1234567891011121314151617181920212223242526class Solution &#123; public int backPack(int m, int[] A) &#123; int[][] dp = new int[A.length][m + 1]; // 动态规划矩阵 for (int i = 0; i &lt; A.length; i++) &#123; dp[i][0] = 0; // 背包空间为0时，不管放多少个物品，可装满的背包空间都为0 &#125; for (int j = 1; j &lt; m + 1; j++) &#123; if (A[0] &lt;= j) &#123; // 当第0个物品的空间小于等于当前背包空间j时 dp[0][j] = A[0]; // 背包可装满的最大空间是第0个物品的体积 &#125; else &#123; // 当第0个物品的空间大于当前背包空间j时 dp[0][j] = 0; // 背包可装满的空间是0 &#125; for (int i = 1; i &lt; A.length; i++) &#123; // 当放第1个到第A.length - 1个物品时 if (A[i] &gt; j) &#123; // 若该物品所占空间大于背包总空间，该物品无法放入背包 dp[i][j] = dp[i - 1][j]; // 背包可装满的最大空间不变 &#125; else &#123; // 若该物品所占空间小于等于背包总空间，则需将背包腾出至少A[j]后，将该物品放入，放入新物品后背包最大可装满空间可能更大，也可能变小，取大值作为背包空间为j且放第i个物品时可以有的最大可装满空间 dp[i][j] = Math.max(dp[i - 1][j - A[i]] + A[i], dp[i - 1][j]); &#125; &#125; &#125; return dp[A.length - 1][m]; &#125;&#125; 解析： dp[i][j]表示当背包总重量为j且有前i个物品时，背包最多装满dp[i][j]的空间 状态转移方程为：dp[i][j] = Math.max(dp[i - 1][j - A[i]] + A[i], dp[i - 1][j]) 为了把第i个物品放进背包，背包当然要先腾出至少A[i]的空间，腾出后空间的最多装满空间为dp[ i - 1][j - A[i]]，再加上第i个物品的空间A[i]，即为当背包总空间为j时，装入第i个物品背包的总装满空间。 当然第i个物品所占的空间可能比此时背包的总空间j要大(j &lt; A[i])，此时装不进第i个物品，因此此时背包的总装满空间为dp[i-1][j]。 还有一种可能的情形是，虽然第i个物品能够装入包中，但为了把第i个物品装入而拿出了其他物品，使此时的总装入空间dp[i-1][j-A[i]] + A[i] &lt; dp[i-1][j]。 其他情形： 当j = 0时，dp[i][0] = 0 建立的动态规划数组大小为dp[A.length][m + 1]，之所以需要m + 1列是因为需要考虑背包空间大小为0时的情况 参考自文章【LintCode】Backpack 背包问题。","tags":[{"name":"动态规划","slug":"动态规划","permalink":"https://glemontree.github.io/tags/动态规划/"}]},{"title":"[算法] 删除二叉搜索树中的某一个节点","date":"2018-01-30T05:13:10.000Z","path":"2018/01/30/[算法] 删除二叉搜索树中的某一个节点/","text":"题目：删除二叉搜索树中满足某个条件的节点 具体代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758class Solution &#123; public TreeNode deleteNode(TreeNode root, int key) &#123; if (root == null) &#123; return null; &#125; if (root.val &lt; key) &#123; root.right = deleteNode(root.right, key); return root; &#125; if (root.val &gt; key) &#123; root.left = deleteNode(root.left, key); return root; &#125; if (root.left == null &amp;&amp; root.right == null) &#123; root = null; return root; &#125; if (root.left != null &amp;&amp;root.right == null) &#123; root = root.left; return root; &#125; if (root.left == null &amp;&amp; root.right != null) &#123; root = root.right; return right; &#125; // 重新调整二叉树，首先在左子树中找出最大值，将最大值赋值给根结点，然后删除左子树中值最大的节点，新的子树赋值给根结点的左子树 if (root.left != null &amp;&amp; root.right != null) &#123; int val = findMaxInLeftTree(root.left); root.val = val; root.left = deleteNode(root.left, val); return root; &#125; return root; &#125; int findMaxInLeftTree(TreeNode node) &#123; if (node == null) &#123; // 空节点，直接返回 return 0; &#125; if (node.right == null) &#123; // 右子树的节点的值比根结点的值大，若右子树为空，则直接返回根结点的值 return node.val; &#125; if (node.right == null &amp;&amp; node.left == null) &#123; // 左子树和右子树均为空，则直接返回根结点的值 return node.val; &#125; return findMaxInLeftTree(node.right); // 左子树和右子树都不为空，最大值必然在右子树中，则递归找出右子树中的最大值 &#125;&#125;","tags":[{"name":"二叉搜索树","slug":"二叉搜索树","permalink":"https://glemontree.github.io/tags/二叉搜索树/"}]},{"title":"[算法] 最长回文子串","date":"2018-01-30T03:28:34.000Z","path":"2018/01/30/[算法] 最长回文子串/","text":"题目：找出一个字符串中的最长回文子串！ 回文字符串的子串也是回文，比如P[i,j]（表示以i开始以j结束的子串）是回文字符串，那么P[i + 1, j - 1]也是回文字符串，这样最长回文子串就能分解成一系列子问题了。 首先定义状态方程和转移方程，P[i,j] = 0表示子串[i,j]不是回文子串，P[i,j] = 1表示子串[i, j]是回文子串： 123P[i, i] = 1;P[i, j] = P[i + 1, j - 1], if s[i] == s[j];P[i, j] = 0, if s[i] != s[j]; 具体代码如下： 123456789101112131415161718192021222324252627282930string findLongestPalindrome(string&amp; s) &#123; const int length = s.size(); int maxLength = 0; int start; bool P[50][50] = &#123;false&#125;; for (int i = 0; i &lt; length; i++) &#123; // 初始化 P[i][i] = true; if (i &lt; length - 1 &amp;&amp; s.at(i) == s.at(i + 1)) &#123; P[i][i + 1] = true; start = i; maxLength = 2; &#125; &#125; for (int len = 3; len &lt;= length; len++) &#123; // 子串长度 for (int i = 0; i &lt;= length - len; i++) &#123; // 子串起始地址 int j = i + len - 1; // 子串结束地址 if (P[i + 1][j - 1] &amp;&amp; s.at(i) == s.at(j)) &#123; p[i][j] = true; maxLength = len; start = i; &#125; &#125; &#125; if (maxLength &gt; 2) &#123; return s.substr(start, maxLength); &#125; return nullptr;&#125;","tags":[{"name":"动态规划","slug":"动态规划","permalink":"https://glemontree.github.io/tags/动态规划/"}]},{"title":"[Java] Java书籍推荐","date":"2018-01-27T05:44:35.000Z","path":"2018/01/27/[Java] Java书籍推荐/","text":"《Spring Boot实战》 《Head First设计模式》 隆重推荐这本神书,很有趣.刚开始读觉得很深,但是和《轻量级Java EE企业应用实战》一起看,思考那些设计模式存在的意义,会对软件架构方面的知识豁然开朗… 《Java并发编程实践》 又是个歪果仁写的书,里面详细介绍了Java并发工具包java.util.concurrent的各种工具以及很多的并发编程实践之道,是并发编程的入门之作。 《Java并发编程的艺术》 国人写的书,也是写Java并发编程的,与上一本相比个人认为比较凝练/干净/易懂 《架构探险:从零开始写Java Web框架》 作者叫黄勇,一本非常让我拍手叫绝的书….首推!绝对干货!如果你不想看spring源码也没有太大关系,这本书带你一步步地开发出一个类似spring mvc的简单框架,并且逐步地增加需求和完善,理解了每个细节对于理解Java Web的开发是很有帮助的。 《深入分析Java Web技术内幕》 这本书我觉得是必看的,可以说是对我帮助最大的一本技术书籍,覆盖了Java Web很多方面的知识,比如计算机网络|Tomcat结构|Spring架构|SpringMVC原理|模板引擎实现原理等,绝对很有收货,足够有深度也很有难度。 《Spring源码深度剖析》 一本比较详细的书,其实对于阅读源代码,跟着作者的思路读,再结合自己的断点调试进行学习的方式是最好的。 《深入理解Java虚拟机-(JVM高级特性与最佳实践)》 想知道Java虚拟机为什么会帮你自动收集垃圾而不需要你管理资源释放吗?想知道Java虚拟机的内存区域是如何划分的吗?想知道Java虚拟机是如何唯一确定一个Java实现类,并且如何加载类的吗?想知道JVM凭什么能够将远程服务器发送的网络字节加载到JVM内存,从而实现远程过程调用的吗?这本书你值得拥有!(感谢这本书让我回答出RPC的实现原理) 《MySQL技术内幕-InnoDB存储引擎》 《大型网站技术架构:核心原理与案例分析》 李智慧著,确实是很好的入门书籍.实际上如果有操作系统和Web项目后台开发的基础话阅读起来不会特别困难,主要内容是介绍当今企业应对大型网站高并发请求的种种策略。 《分布式Java应用-基础与实践》 这本书比较深,介绍分布式Java应用和相应的应用场景,什么远程过程调用(RPC)呀,基于服务的体系架构呀(SOA)等,同时也讲了很多java比较底层的知识,最后介绍构建高可用/可伸缩系统的工程经验。 《大型分布式网站架构:设计与实践》 与上一本书类似,不过个人觉得更偏向于”介绍”互联网安全架构和分布式系统的各种组件(比如分布式缓存|消息队列|搜索引擎等),目前我只接触了Redis,相应的组件实在太多了- -此外对系统监控和数据分析等也做了相应介绍,这些我感觉比较偏向运维岗的工作人员。 《Redis实战》 Redis的基本用法和在生产环境的应用,值得拥有,虽然书籍是用python,不过官方github也有放java的源码。 《Redis设计与实现》 Redis的源码解读,怎么说呢,反正比spring源码好读太多了….而且作者读得很用心,整理出了带注释版本的redis源码,去读个痛快吧少年。 转自阿里巴巴等大厂的 Java岗位要求是什么？。 ​","tags":[{"name":"Java","slug":"Java","permalink":"https://glemontree.github.io/tags/Java/"}]},{"title":"[TCPIP] 利用TCP/IP参考模型分析数据传输过程","date":"2017-12-23T03:51:45.000Z","path":"2017/12/23/[TCPIP] 利用TCPIP参考模型分析数据传输过程/","text":"利用TCP/IP参考模型分析数据传输过程。","tags":[]},{"title":"[DB] 事务的隔离级别","date":"2017-12-15T02:39:53.000Z","path":"2017/12/15/[DB] 事务的隔离级别/","text":"数据库事务有不同的隔离级别，不同的隔离级别对锁的使用是不同的，锁的应用最终导致不同事务的隔离级别。 隔离级别有以下四种： 读未提交（Read Uncommitted） 读已提交（Read Committed）大多数数据库默认的隔离级别 可重复读（Repeatable-Read）mysql数据库默认的级别 序列化（serializable） 看下面这个例子，A修改事务级别为未提交读，并开始事务，对user表做一次查询： B事务更新一条记录： 此时B事务还未提交，A在事务内做一次查询，发现查询结果已经改变： B进行事务回滚： A再做一次查询，查询结果又变回去了： 由试验可知，在一个进程的事务当中，我更改了其中的一行数据，但是我修改完之后就释放了锁，这时候另一个进程读取了该数据，此时先前的事务是还未提交的，直到我回滚了数据，另一个进程读的数据就变成了无用的或是错误的数据，我们通常把这种数据称为脏数据，这种情况读出来的数据叫脏读。 之前是只要操作完数据就立刻释放掉锁，现在是把释放锁的位置调整到事务提交之后，此时在事务提交之前，其他进程是无法对该行数据进行读取的，包括任何操作。那么数据库为此种状态的数据库操作规则又给了一个名字叫“读已提交（Read Committed）”，或者叫不可重复读。 把隔离性调整为READ-COMMITTED（读取提交内容），设置A的事务隔离级别，并进入事务做一次查询： B开始事务，并对记录进行修改： A再对user表进行查询，发现记录没有受到影响： B提交事务： A再对user表进行查询，发现记录被修改： 试验进行到这里，你会发现，在同一个事务中如果两次读取相同的数据时，最后的结果却不一致。这里我们把这种现象称为：不可重复读。因为在第一个事务读取了数据之后，此时另一个事务把该数据给修改了，这时候事务提交，那么另一个事务在第二次读取的时候，结果就不一样，一个修改前的，一个是修改后的。 但是细心的你会发现，既然你说此种隔离性是在事务提交后才释放锁，那么在试验过程中，在该数据未提交前，另一个事务为什么也是仍然可以读取的呀。是我说错了吗？不是的，在这里mysql使用了一个并发版本控制机制，他们把它叫做MVCC，通俗的也就是说：mysql为了提高系统的并发量，在事务未提交前，虽然事务内操作的数据是锁定状态，但是另一个事务仍然可以读取，大多数数据库默认的就是这个级别的隔离性。但mysql不是。 而且不只是在更新数据时出现这个问题，在插入数据时仍然会造成类似的这样一种现象：mysql虽然锁住了正在操作的数据行，但它仍然不会阻止另一个事务往表插入新行新的数据。比如：一个事务读取或更新了表里的所有行，接着又有另一个事务往该表里插入一个新行，在事务提交后。原来读取或更改过数据的事务又第二次读取了相同的数据，这时候这个事务中两次读取的结果集行数就不一样。原来更新了所有行，而现在读出来发现竟然还有一行没有更新。这就是所谓的幻读。 为了防止同事务中两次读取数据不一致，（包括不可重读和幻读），接下来该如何继续做呢？！ mysql依然采取的是MVCC并发版本控制来解决这个问题。具体是：如果事务中存在多次读取同样的数据，MySQL第一次读的时候仍然会保持选择读最新提交事务的数据，当第一次之后，之后再读时，mysql会取第一次读取的数据作为结果。这样就保证了同一个事务多次读取数据时数据的一致性。这时候，mysql把这种解决方案叫做：可重复读（Repeatable-Read)，也就是上述所写的第三个隔离性，也是mysql默认的隔离级别。 注意：幻读和不可重复读（Read Committed）都是读取了另一条已经提交的事务（这点就脏读不同），所不同的是不可重复读查询的都是同一个数据项，而幻读针对的是一批数据整体（比如数据的个数）。 说到这里，真的就完事了吗？到这里其实mysql并未完全解决数据的一致性问题。只是在读取上做了手脚，解决了传统意义上的幻读和不可重复读。例子：1 A事务开启，B事务开启。​ 2 B事务往表里面插入了一条数据，但还并未提交。​ 3 A事务开始查询了，并没有发现B事务这次插入的数据。然后此时B事务提交了数据。​ 4 于是乎，A事务就以为没有这条数据，就开始添加这条数据，但是却发现，发生了数据 重复冲突。 最后这个时候，该我们的最后一种隔离级别也是最高的隔离级：别序列化（serializable）登场了。该隔离级别会自动在锁住你要操作的整个表的数据，如果另一个进程事务想要操作表里的任何数据就需要等待获得锁的进程操作完成释放锁。可避免脏读、不可重复读、幻读的发生。当然性能会下降很多，会导致很多的进程相互排队竞争锁。 后记：以上所说的四种隔离性的锁机制应用是数据库自动完成的，不需要人为干预。隔离级别的设置只对当前链接有效。对于使用MySQL命令窗口而言，一个窗口就相当于一个链接，当前窗口设置的隔离级别只对当前窗口中的事务有效 本文转自数据库事务原子性、一致性是怎样实现的？ ​ ​","tags":[{"name":"事务隔离级别","slug":"事务隔离级别","permalink":"https://glemontree.github.io/tags/事务隔离级别/"}]},{"title":"[TCPIP] 三次握手和四次挥手","date":"2017-12-14T11:26:02.000Z","path":"2017/12/14/[TCPIP] 三次握手和四次挥手/","text":"可参考TCP 为什么是三次握手，为什么不是两次或四次？","tags":[{"name":"三次握手, 四次挥手","slug":"三次握手-四次挥手","permalink":"https://glemontree.github.io/tags/三次握手-四次挥手/"}]},{"title":"[Java] Java虚拟机","date":"2017-12-14T09:22:58.000Z","path":"2017/12/14/[Java] Java虚拟机/","text":"JVM物理结构： Java编译器只面向JVM，生成JVM能理解的代码或字节码文件，Java源文件经编译器，编译成字节码程序，通过JVM将每一条指令翻译成不同平台机器码，通过特定平台运行！ Java代码编译和执行的整个过程包含三个重要的机制： Java源码编译机制 类加载机制 类执行机制 Java源码编译机制由三个过程组成： 分析和输入到符号表 注解处理 语义分析和生成class文件 类加载过程中会先检查类是否已被加载，检查顺序是自底向上，从Custom ClassLoader到BootStrap ClassLoader逐层检查，只要某个ClassLoader已加载就视为已加载该类，保证此类只被加载一次，而加载的顺序是自顶向下的，也就是由上层来逐层尝试加载此类。 JVM是基于栈的体系结构来执行class字节码文件的，线程创建后，都会产生程序计数器（PC）和栈（Stack），程序计数器存放下一条要执行的指令在方法内的偏移量，栈中存放一个个栈帧，每个栈帧对应着每个方法的每次调用，而栈帧又是由局部变量区和操作数栈两部分组成，局部变量区用于存放方法中的局部变量和参数，操作数栈中用于存放方法执行过程中产生的中间结果。 Java虚拟机规范将JVM所管理的内存分为以下几个运行时数据区：程序计数器、Java虚拟机栈、本地方法栈、Java堆、方法区。 其中，Java堆和方法区是线程共享内存区，而虚拟机栈、本地方法栈和程序计数器则是线程私有内存区。 程序计数器 每条线程都有一个独立的程序计数器，各线程间的计数器互不影响，因此该区域是线程私有的。当程序执行一个Java方法时，该计数器记录的是正在执行的虚拟机字节码指令的地址，当线程在执行的是Native方法时，该计数器的值为空。另外，该内存区是唯一一个在Java虚拟机规范中没有规定任何OOM情况的区域。 Java虚拟机栈 该区域是线程私有的，它的生命周期和线程相同 本地方法栈 虚拟机栈为虚拟机执行Java方法服务，而本地方法栈则为使用到的本地操作系统方法服务。 Java堆 Java堆是所有线程共享的一块内存区域，几乎所有的对象实例和数组都在这类分配内存，Java Heap是垃圾收集器管理的主要区域，因此很多时候称为GC堆。 方法区 方法区是各个线程共享的内存区域，它用于存储已经被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。方法区又被称为永久代，但这仅仅对于Sun HotSpot来说。Java虚拟机规范把方法区描述为Java堆的一个逻辑部分，另外，虚拟机规范允许该区域可以选择不实现垃圾回收，相对而言，垃圾收集行为在这个区域比较少出现，该区域的内存回收目标主要是针对废弃常量和无用类的回收。运行时常量池是方法区的一部分，Class文件中除了有类的版本、字段、方法、接口等信息之外，还有一项就是常量池，用于存放编译器生成的各种字面量和符号引用，这部分内容将在类加载后存放到方法区的运行时常量池中。运行时常量池相对于Class文件常量池的另一个重要特性就是具备动态性，Java语言并不要求常量一定只能在编译器产生，也就是并非预置于Class文件中的常量池中的内容才能进入方法区的运行时常量池，运行期间也可能将新的常量放入池中，这种特性被开发人员利用较多的是String类的intern()方法。 当方法区无法满足内存分配需求时，将抛出OutOfMemoryError异常。 ​ 直接内存并不是虚拟机运行时数据区的一部分，也不是 Java 虚拟机规范中定义的内存区域，它直接从操作系统中分配，因此不受 Java 堆大小的限制，但是会受到本机总内存的大小及处理器寻址空间的限制，因此它也可能导致 OutOfMemoryError 异常出现。在 JDK1.4 中新引入了 NIO 机制，它是一种基于通道与缓冲区的新 I/O 方式，可以直接从操作系统中分配直接内存，即在堆外分配内存，这样能在一些场景中提高性能，因为避免了在 Java 堆和 Native 堆中来回复制数据。 类初始化是类加载过程的最后一个阶段，到初始化阶段，才真正开始执行类中的Java程序代码，虚拟机规范严格规定了有且只有四种情况必须立即对类进行初始化： 遇到new、getstatic、putstatic、invokestatic这四条字节码指定时，如果类还没有进行初始化，则需要触发其初始化，生成这四条指令最常见的Java代码场景是：使用new关键字实例化对象时、读取或设置一个类的静态字段（static）时（被static修饰又被final修饰的，已在编译期把结果放入常量池的静态字段除外）以及调用一个类的静态方法时； 使用java.lang.refect包的方法对类进行反射调用时，如果类还没有进行初始化，则需要触发其初始化； 当初始化一个类的时候，如果发现其父类还没有进行初始化，则需要先触发其父类的初始化； 当虚拟机启动时，用户需要指定一个要执行的主类，虚拟机会先执行该主类。 虚拟机只有这四种情况才会触发类的初始化，称为对一个类进行主动引用，除此之外所有引用类的方式都不会触发其初始化，称为被动引用，下面举一些例子来说明被动引用： 通过子类引用父类中的静态字段，这时对子类的引用为被动引用，因此不会初始化子类，只会初始化父类： 123456789101112131415161718class Father &#123; public static int m = 33; static &#123; System.out.println(\"父类被初始化\"); &#125;&#125;class Child extends Father &#123; static &#123; System.out.println(\"子类被初始化\"); &#125;&#125;public class StaticTest &#123; public static void main(String[] args) &#123; System.out.println(Child.m); &#125;&#125; 执行结果如下： 12父类被初始化33 对于静态字段，只有直接定义这个字段的类才会被初始化，因此，通过子类来引用父类中定义的静态字段，只会触发父类的初始化而不会触发子类的初始化。 常量在编译阶段会被存入调用它的类的常量池中，本质上没有直接引用到定义该常量的类，因此不会触发定义常量的类的初始化： 123456789101112class Const &#123; public static final String NAME = \"我是常量\"; static &#123; System.out.println(\"初始化Const类\"); &#125;&#125;public class FinalTest&#123; public static void main(String[] args)&#123; System.out.println(Const.NAME); &#125; &#125; 执行后输出的结果为： 1我是常量 虽然程序中引用了 const 类的常量 NAME，但是在编译阶段将此常量的值“我是常量”存储到了调用它的类 FinalTest 的常量池中，对常量 Const.NAME 的引用实际上转化为了 FinalTest 类对自身常量池的引用。也就是说，实际上 FinalTest 的 Class 文件之中并没有 Const 类的符号引用入口，这两个类在编译成 Class 文件后就不存在任何联系了。 通过数组定义来引用类，不会触发类的初始化： 1234567891011class Const&#123; static&#123; System.out.println(\"初始化Const类\"); &#125; &#125; public class ArrayTest&#123; public static void main(String[] args)&#123; Const[] con = new Const[5]; &#125; &#125; 执行后不输出任何信息，说明 Const 类并没有被初始化。 Java程序最初是仅仅通过解释器进行执行的，即对字节码逐条解释执行，这种方式的执行速度相对会比较慢，尤其是当某个方法或代码块运行的特别频繁的时候，这种方式的执行效率就显得很低，于是后来在虚拟机中引入了JIT编译器（即时编译器），当虚拟机发现某个方法或代码块执行比较频繁的时候，就会把这些代码认定为“Hot Spot Code”（热点代码），为了提高热点代码的执行效率，在运行时，虚拟机将会把这些代码编译成与本地平台相关的机器码，并进行各层次的优化，完成这项任务的正是JIT编译器。 当程序需要迅速启动和执行时，解释器可以首先发挥作用，省去编译的时间，立即执行；当程序运行后，随着时间的推移，编译器会逐渐发挥作用，把越来越多的代码编译成本地代码后，可以获得更高的执行效率。 解释执行可以节约内存，而编译执行可以提升效率。 运行过程中会被即时编译器编译的“热点代码”有两类： 被多次调用的方法 被多次调用的循环体 本文参考自深入理解 Java 虚拟机。","tags":[{"name":"Java, 虚拟机, 类加载","slug":"Java-虚拟机-类加载","permalink":"https://glemontree.github.io/tags/Java-虚拟机-类加载/"}]},{"title":"[DB] JDBC知识点","date":"2017-12-13T08:47:13.000Z","path":"2017/12/13/[DB] JDBC知识点/","text":"JDBC：Java DataBase Connect，即Java数据库连接，我们可以用它来操作关系型数据库。 JDBC的Statement： Statement是JDBC中用来执行数据库SQL查询语句的接口。通过调用连接对象的getStatement()方法可以生成一个Statement对象，我们可以通过调用它的execute()、executeQuery()、executeUpdate()方法来执行静态SQL查询。 Statement的execute(String query)方法用来执行任意的SQL查询，如果查询的结果是一个ResultSet，这个方法就返回true，如果不是ResultSet，比如insert或者update语句，他就会返回false，我们可以通过它的getResultSet方法来获取ResultSet，或者通过getUpdateCount()方法来获取更新的记录条数。 Statement的executeQuery(String query)接口用来执行select查询，并且返回ResultSet。即使查询不到记录返回的ResultSet也不会为null。我们通常使用executeQuery来执行查询语句，这样的话如果传进来的是insert或者update语句的话，它会抛出错误信息为 “executeQuery method can not be used for update”的java.util.SQLException。 Statement的executeUpdate(String query)方法用来执行insert或者update/delete（DML）语句，或者 什么也不返回DDL语句。返回值是int类型，如果是DML语句的话，它就是更新的条数，如果是DDL的话，就返回0。 只有当你不确定是什么语句的时候才应该使用execute()方法，否则应该使用executeQuery或者executeUpdate方法。 PreparedStatement：PreparedStatement对象代表的是一个预编译的SQL语句，用它提供的setter方法可以传入查询的变量。由于PreparedStatement是预编译的，通过它可以将对应的SQL语句高效的执行多次。 通过Statement的getGeneratedKeys()方法可以获取表自动生成的主键 脏读：当我们使用事务时，有可能会出现这样的情况，有一行数据刚更新，与此同时另一个查询读到了这个刚更新的值。这样就导致了脏读，因为更新的数据还没有进行持久化，更新这行数据的业务可能会进行回滚，这样这个数据就是无效的。 数据库的TRANSACTIONREADCOMMITTED，TRANSACTIONREPEATABLEREAD，和TRANSACTION_SERIALIZABLE隔离级别可以防止脏读。 幻读：指一个事务多次执行一条查询返回的却是不同的值，假设一个事务正根据某个条件进行数据查询，然后另一个事务插入了满足这个查询条件的语句，之后这个事务再次执行了这条查询，返回的结果集中会包含刚插入的那条新数据，这行新数据被称为幻行，这种现象称为幻读。 只有TRANSACTION_SERIALIZABLE隔离级别才能防止产生幻读。 java.util.Date和java.sql.Date有什么区别？ java.util.Date包含日期和时间，而java.sql.Date只包含日期信息，而没有具体的时间信息。如果你想把时间信息存储在数据库里，可以考虑使用Timestamp或者DateTime字段。 JDBC里的CLOB和BLOB数据类型分别代表什么？ CLOB即Character Large Objects，字符大对象，它是由单字节字符组成的字符串数据，这种数据类型适用于存储超长的文本信息，那么可能会超出标准的VARCHAR数据类型长度限制的文本。 BLOB即Binary Large Objects，它是二进制大对象，由二进制数据组成，它能用于存储超过VARBINARY限制的二进制数据，这种数据类型适合存储图片、声音、图形或者其他业务程序特定的数据。 数据库的隔离级别：当我们为了数据的一致性使用事务时，数据库系统用锁来防止别人访问事务中用到的数据，数据库通过锁来防止脏读、不可重复读以及幻读等问题。 数据库使用JDBC设置的隔离级别来决定使用何种锁机制，我们可以通过Connection的getTransactionIsolation和setTransactionIsolation方法来获取和设置数据库的隔离级别。 | 隔离级别 | 事务 | 脏读 | 不可重复读 | 幻读 || —————————- | —- | —- | —– | —- || TRANSACTION_NONE | 不支持 | 不可用 | 不可用 | 不可用 || TRANSACTION_READ_COMMITTED | 支持 | 阻止 | 允许 | 允许 || TRANSACTION_READ_UNCOMMITTED | 支持 | 允许 | 允许 | 允许 || TRANSACTION_REPEATABLE_READ | 支持 | 阻止 | 阻止 | 允许 || TRANSACTION_SERIALIZABLE | 支持 | 阻止 | 阻止 | 阻止 |","tags":[{"name":"DB JDBC","slug":"DB-JDBC","permalink":"https://glemontree.github.io/tags/DB-JDBC/"}]},{"title":"[Linux] vmware中启动ubuntu蓝屏","date":"2017-12-10T14:18:34.000Z","path":"2017/12/10/[Linux] vmware中启动ubuntu蓝屏/","text":"先进入字符界面：Ctrl + Alt + F4 然后安装相应服务，然后重置它！ 123sudo apt-get install xserver-xorg-lts-utopic sudo dpkg-reconfigure xserver-xorg-lts-utopic reboot 如果前面第一个操作有问题，需要重置 dpkg 后再试，总之按提示操作就好了。 1sudo dpkg --configure -a 有看到其他人不是安装 xserver-xorg-lts-utopic，而是 xserver-xorg-lts-quantal 。估计是版本问题。 reboot 系统后，亲切的图形界面终于回来了！ 本文转载自文章VMware 虚拟机 Ubuntu 登录后蓝屏问题。","tags":[{"name":"Linux, vmware, ubuntu, 蓝屏","slug":"Linux-vmware-ubuntu-蓝屏","permalink":"https://glemontree.github.io/tags/Linux-vmware-ubuntu-蓝屏/"}]},{"title":"[DB] mysql的最左前缀匹配原则","date":"2017-12-10T09:43:29.000Z","path":"2017/12/10/[DB] mysql的最左前缀匹配原则/","text":"mysql建立联合索引有最左前缀的原则，即最左优先，如： 如果有一个2列的索引(col1, col2)，则已经对(col1)、(col1, col2)上建立了索引； 如果有一个3列的索引(col1, col2, col3)，则已经对(col1)、(col1, col2)、(col1, col2, col3)上建立了索引； 总结： b+树的数据项是复合的数据结构，比如(name,age,sex)的时候，b+树是按照从左到右的顺序来建立搜索树的，比如当(张三,20,F)这样的数据来检索的时候，b+树会优先比较name来确定下一步的所搜方向，如果name相同再依次比较age和sex，最后得到检索的数据；但当(20,F)这样的没有name的数据来的时候，b+树就不知道第一步该查哪个节点，因为建立搜索树的时候name就是第一个比较因子，必须要先根据name来搜索才能知道下一步去哪里查询。 比如当(张三,F)这样的数据来检索时，b+树可以用name来指定搜索方向，但下一个字段age的缺失，所以只能把名字等于张三的数据都找到，然后再匹配性别是F的数据了， 这个是非常重要的性质，即索引的最左匹配特性。（这种情况无法用到联合索引） 测试1： 联合索引： KEY key_aS_aT (auditSt,applyTime) 1、explain select from tblArticle0 where applyTime=123 and auditSt =1 ;2、 explain select from tblArticle0 where auditSt =1 and applyTime =123 ; 测试结果：1和2两种情况都用到了索引key_aS_aT，所以索引顺序是可以颠倒的，只要where条件中的字段包含索引中的第一个字段即可。 测试2： 联合索引： KEYsex_type_age on user(sex,type,age); 1、explain select from user_test where sex = 22、explain select from user_test where sex = 2 and type = 23、explain select * from user_test where sex = 2 and age = 10 测试结果：这3条sql语句都会用到联合索引sex_type_age，因为where条件中包含了第一个索引字段sex。 再看下面这种： 1234567CREATE TABLE `student` ( `id` int(11) NOT NULL AUTO_INCREMENT, `name` varchar(255) DEFAULT NULL, `cid` int(11) DEFAULT NULL, PRIMARY KEY (`id`), KEY `name_cid_INX` (`name`,`cid`)) ENGINE=InnoDB AUTO_INCREMENT=8 DEFAULT CHARSET=utf8; 索引方面：id是主键，(name,cid)是一个多列索引。 1EXPLAIN SELECT * FROM student WHERE cid=1; 1EXPLAIN SELECT * FROM student WHERE cid=1 AND name='小红'; 你的疑问是：sql查询用到索引的条件是必须要遵守最左前缀原则，为什么上面两个查询还能用到索引？ 上述你的两个查询的explain结果中显示用到索引的情况类型是不一样的。,可观察explain结果中的type字段。你的查询中分别是： type: index type: ref 解释：index：这种类型表示是mysql会对整个该索引进行扫描。要想用到这种类型的索引，对这个索引并无特别要求，只要是索引，或者某个复合索引的一部分，mysql都可能会采用index类型的方式扫描。但是呢，缺点是效率不高，mysql会从索引中的第一个数据一个个的查找到最后一个数据，直到找到符合判断条件的某个索引。 所以：对于你的第一条语句： 1EXPLAIN SELECT * FROM student WHERE cid=1; 判断条件是cid=1,而cid是(name,cid)复合索引的一部分，没有问题，可以进行index类型的索引扫描方式。explain显示结果使用到了索引，是index类型的方式。 ref：这种类型表示mysql会根据特定的算法快速查找到某个符合条件的索引，而不是会对索引中每一个数据都进行一 一的扫描判断，也就是所谓你平常理解的使用索引查询会更快的取出数据。而要想实现这种查找，索引却是有要求的，要实现这种能快速查找的算法，索引就要满足特定的数据结构。简单说，也就是索引字段的数据必须是有序的，才能实现这种类型的查找，才能利用到索引。 下面就说下复合索引：以该表的(name,cid)复合索引为例,它内部结构简单说就是下面这样排列的： mysql创建复合索引的规则是首先会对复合索引的最左边的，也就是第一个name字段的数据进行排序，在第一个字段的排序基础上，然后再对后面第二个的cid字段进行排序。其实就相当于实现了类似 order by name cid这样一种排序规则。 所以：第一个name字段是绝对有序的，而第二字段就是无序的了。所以通常情况下，直接使用第二个cid字段进行条件判断是用不到索引的，当然，可能会出现上面的使用index类型的索引。这就是所谓的mysql为什么要强调最左前缀原则的原因。 那么什么时候才能用到呢?当然是cid字段的索引数据也是有序的情况下才能使用咯，什么时候才是有序的呢？观察可知，当然是在name字段是等值匹配的情况下，cid才是有序的。发现没有，观察两个name名字为 c 的cid字段是不是有序的呢。从上往下分别是4 5。这也就是mysql索引规则中要求复合索引要想使用第二个索引，必须先使用第一个索引的原因。（而且第一个索引必须是等值匹配）。 所以对于你的这条sql查询： 1EXPLAIN SELECT * FROM student WHERE cid=1 AND name='小红'; 没有错，而且复合索引中的两个索引字段都能很好的利用到了！因为语句中最左面的name字段进行了等值匹配，所以cid是有序的，也可以利用到索引了。 你可能会问：我建的索引是(name,cid)。而我查询的语句是cid=1 AND name=’小红’; 我是先查询cid，再查询name的，不是先从最左面查的呀？ 好吧，我再解释一下这个问题：首先可以肯定的是把条件判断反过来变成这样 name=’小红’ and cid=1; 最后所查询的结果是一样的。那么问题产生了？既然结果是一样的，到底以何种顺序的查询方式最好呢？ 所以，而此时那就是我们的mysql查询优化器该登场了，mysql查询优化器会判断纠正这条sql语句该以什么样的顺序执行效率最高，最后才生成真正的执行计划。所以，当然是我们能尽量的利用到索引时的查询顺序效率最高咯，所以mysql查询优化器会最终以这种顺序进行查询执行。 所以，而此时那就是我们的mysql查询优化器该登场了，mysql查询优化器会判断纠正这条sql语句该以什么样的顺序执行效率最高，最后才生成真正的执行计划。所以，当然是我们能尽量的利用到索引时的查询顺序效率最高咯，所以mysql查询优化器会最终以这种顺序进行查询执行。 本文转载自知乎mysql索引最左匹配原则的理解?，作者沈杰链接：https://www.zhihu.com/question/36996520/answer/93256153。","tags":[{"name":"DB 最左前缀","slug":"DB-最左前缀","permalink":"https://glemontree.github.io/tags/DB-最左前缀/"}]},{"title":"[Linux] Shell编程第十一课","date":"2017-12-03T12:18:59.000Z","path":"2017/12/03/[Linux] Shell编程第十一课/","text":"bash shell会将一些称为位置参数的特殊变量分配给输入到命令行中的所有参数，其中$0是程序名，$1是第一个参数，$2是第二个参数… 1234567#!/bin/bashfactorial=1for (( number = 1; number &lt;= $1 ; number++ ))do factorial=[ factorial * $number ]doneecho The factorial of 1 is factorial 12$ ./test1.sh 5The factorial of 5 is 120 需要注意的是factorial=$[ $factorial * $number ]这一行等号左右不可以有空格。 在将文本字符串作为参数传递时，若碰到有空格的文本字符串，需要用引号将文本字符串包起来 读取脚本名：可以用$0参数获取shell在命令行启动的脚本名，例如bash test.sh，那么在shell脚本中使用$0获取到的脚本名为test.sh，但是有一个问题就是使用./test.sh运行程序时，命令会和脚本名混在一起，例如执行./test.sh，那么在脚本中$0获取到的脚本名为./test.sh，另外一个问题就是当传给$0变量的实际字符串不仅仅是脚本名，而是完整的脚本路径时，变量$0就是使用整个路径，例如bash /home/gtp/test.sh，那么在脚本中获取的值就为/home/gtp/test.sh，有个命令可以帮我们提取出脚本名称，basename命令会返回不包含路径的脚本名，例如： 123456789#!/bin/bashname=(basename 0)if [ $name = &quot;addem&quot; ]then total=$[ $1 + $2 ]elif [ $name = &quot;multem&quot; ]then total=$[ $1 * $2 ]fi ​在shell脚本中使用命令行参数如果脚本不加参数运行会报错，所以在脚本中使用命令行参数时一定要先判断： 1234567#!/bin/bashif [ -n &quot;$1&quot; ]then echo Hello $1, glad to meet you.else echo &quot;Sorry, you did not identify yourself&quot;fi 特殊变量$#含有脚本运行时携带的命令行参数的个数，可以在脚本中任何地方使用这个特殊变量，就跟普通变量一样，我们通过如下形式获取到最后一个命令行参数： 123456#!/bin/bashparams=$#echoecho The last parameter is $paramsecho The last parameter is $&#123;!#&#125; echo 123$ bash test.sh 1 2 3 4 5The last parameter is 5The last parameter is 5 123$ bash test.sh The last parameter is 0The last parameter is test.sh $*和$@变量可以轻松访问所有的命令行参数，这两个变量都能够在单个变量上存储所有的命令行参数，$*变量会将命令行上提供的所有参数当作一个单词保存，这个单词包含了命令行上出现的每一个参数值，$*变量会将这些参数视为一个整体，而不是多个个体；而$@变量会将命令行上提供的所有参数当作同一字符串中的多个独立的单词，这样就能遍历所有的参数值，得到每一个参数值。 123456789101112131415#!/bin/bashechocount=1for param in &quot;$*&quot;do echo &quot;$* Parameter #count = param&quot; count=[ count + 1 ]doneechocount=1for param in &quot;$@&quot;do echo &quot;$@ Paramter #count = param&quot; count=[ count + 1]done 123456$ ./test.sh rich barbara katie jessica$* Parameter #1 = rich barbara katie jessica$@ Parameter #1 = rich$@ Parameter #2 = barbara$@ Parameter #3 = katie$@ Parameter #4 = jessica 移动变量：shift命令能够用来操作命令行参数，shift命令会根据它们的相对位置来移动命令行参数，在使用shift命令时，默认情况下它会将每个参数变量向左移动一个位置，所以,变量$3的值会移到$2中,变量$2的值会移到$1中,而变量$1的值则会被删除(注意,变量$0的值,也就是程序名,不会改变)。这是遍历命令行参数的另一种方法，你可以只操作第一个参数，移动参数，然后继续操作第一个参数。 123456789#!/bin/bashechocount=1while [ -n &quot;$1&quot; ]do echo &quot;Parameter #$count = $1&quot; count=$[ $count + 1 ] shiftdone 123456$$ ./test13.sh rich barbara katie jessicaParameter #1 = richParameter #2 = barbaraParameter #3 = katieParameter #4 = jessica 使用shift命令需要注意的是如果某个参数被移出，它的值就被丢弃了，无法再恢复。 你可以使用shift命令来依次处理脚本程序携带的命令行参数，你也可以用同样的方法来处理命令行选项，在提取每个单独参数时，用case语句来判断某个参数是否为选项： 123456789101112#!/bin/bashechowhile [ -n &quot;$1&quot; ]do case &quot;$1&quot; in -a) echo &quot;Found the -a option&quot; ;; -b) echo &quot;Found the -a option&quot; ;; -c) echo &quot;Found the -c option&quot; ;; *) echo &quot;$1 is not an option&quot; ;; esac shiftdone 12345$ ./test.sh -a -b -c -dFound the -a optionFound the -b optionFound the -c option-d is not an option Linux中使用--特殊字符将选项和参数分开，shell会用双破折线来表明选项列表结束，在双破折线之后，脚本就可以放心的将剩下的命令行参数当作参数，而不是选项来处理了： 123456789101112131415161718192021#!/bin/bashecho while [ -n &quot;$1&quot; ]do case &quot;$1&quot; in -a) echo &quot;Found the -a option&quot; ;; -b) echo &quot;Found the -b option&quot; ;; -c) echo &quot;Found the -c option&quot; ;; --) shift break ;; *) echo &quot;$1 is not an option&quot; ;; esac shiftdone#count=1for param in $@do echo &quot;Parameter #$count: $param&quot; count=$[ $count + 1 ]done 1234567 $ ./test16.sh -c -a -b -- test1 test2 test3Found the -c optionFound the -a optionFound the -b optionParameter #1: test1Parameter #2: test2Parameter #3: test3 处理带值的选项：有些选项会带上一个额外的参数值，在这种情况下，命令行会类似于下面这种形式：./test.sh -a -b test1 -c -d test2，当命令行选项要求额外的参数时，脚本必须能够检测到并正确处理： 1234567891011121314151617181920212223#!/bin/bashechowhile [ -n &quot;$1&quot; ]do case &quot;$1&quot; in -a) echo &quot;Found the -a option&quot; -b) param=&quot;$2&quot; echo &quot;Found the -b option, with parameter value $param&quot; shift ;; -c) echo &quot;Found the -c option&quot; ;; --) shift break ;; *) echo &quot;$1 is not an option&quot; esac shiftdone#count=1for param in $@do echo &quot;Parameter #$count: $param&quot; count=$[ $count + 1 ]done 1234$ ./test.sh -a -b test1 -dFound the -a optionFound the -b option, with parameter value test1-d is not an option getopt命令是一个处理命令行选项和参数的命令，它能够识别命令行参数，getopt命令可以接受一系列任意形式的命令行选项和参数，并自动将它们转换成适当的形式，它的命令形式如下：getopt optstring parameters。 optstring定义了命令行有效的选项字母，还定义了哪些选项字母需要参数值，在optstring中列出你要在脚本中用到的每个命令行选项字母，然后在每个需要参数值的选项字母后加一个冒号，getopt命令会基于你定义的optstring解析提供的参数 12$ getopt ab:cd -a -b test1 -cd test2 test3a -b test1 -c -d -- test2 test3 optstring定义了四个有效选项字母，a、b、c和d，冒号被放在了b后面，表示b选项需要一个参数值，当getopt命令运行时，它会检查提供的参数列表（-a -b test1 -cd test2 test3），并基于提供的optstring进行解析，它会自动将-cd选项分为两个独立的选项，并插入双破折线来分隔行中的额外参数。 可以在脚本中使用getopt来格式化脚本所携带的任何命令行选项和参数，方法是用getopt命令生成的格式化后的版本来替换已有的命令行选项和参数，这可以通过set命令做到，set命令的选项之一是双破折线--，它会将命令行参数替换成set命令的命令行值： 1set -- $(getopt -q ab:cd &quot;$@&quot;) -q选项表示如果指定了一个不在optstring中的选项，默认情况下，getopt命令会产生一条错误信息，指定了-q选项后就可以忽略这条错误信息。 现在原始的命令行参数变量的值会被getopt命令的输出替换： 123456789101112131415161718192021222324252627#!/bin/bash#Extract command line options &amp; values with getopt#set -- $(getopt -q ab:cd &quot;$@&quot;)#echowhile [ -n &quot;$1&quot; ]do case &quot;$1&quot; in -a) echo &quot;Found the -a option&quot; ;; -b) param=&quot;$2&quot; echo &quot;Found the -b option, with parameter value $param&quot; shift ;; -c) echo &quot;Found the -c option&quot; ;; --) shift break ;; *) echo &quot;$1 is not an option&quot;;; esac shiftdone#count=1for param in &quot;$@&quot; do echo &quot;Parameter #$count: $param&quot; count=$[ $count + 1 ]done 123$ ./test.sh -acFound the -a optionFound the -c option 1234567$ ./test.sh -a -b test1 -cd test2 test3 test4Found the -a optionFound the -b option, with parameter value &apos;test1&apos;Found the -c optionParameter #1: &apos;test2&apos;Parameter #2: &apos;test3&apos;Parameter #3: &apos;test4&apos; getopt存在的一个问题就是当处理带空格和引号的参数值时，它会将空格当作参数分隔符，而不是根据双引号将二者当作一个参数，例如： 1./test.sh -a -b test1 -cd &quot;test2 test3&quot; test4 123456Found the -a optionFound the -b option, with parameter value &apos;test1&apos;Found the -c optionParameter #1: &apos;test2Parameter #2: test3&apos;Parameter #3: &apos;test4&apos; getopts一次只处理命令行上检测到的一个参数，处理完所有的参数后，它会退出并返回一个大于0的退出状态码，这让它非常适合用解析命令行所有参数的循环中： getopts optstring variable 有效的选项字母都会列在optstring中，如果选项字母要求有个参数值，就加一个冒号，要去掉错误信息的话，可以在optstring之前加一个冒号，getopts命令会将当前参数保存在命令行中定义的variable中。 getopts命令会用到两个环境变量，如果选项要跟一个参数值，OPTARG环境变量就会保存这个值，OPTIND环境变量保存了参数列表中getopts正在处理的参数位置： 1234567891011#!/bin/bashechowhile getopts :ab:c optdo case &quot;$opt&quot; in a) echo &quot;Found the -a option&quot; ;; b) echo &quot;Found the -b option, with value $OPTARG&quot; ;; a) echo &quot;Found the -c option&quot; ;; *) echo &quot;Unknown option: $opt&quot; ;; esacdone 1234$ ./test19.sh -ab test1 -cFound the -a optionFound the -b option, with value test1Found the -c option 需要注意的是，getopts命令解析命令行选项时会移除开头的破折线，所以在case定义中不用单破折线。 getopts可以在参数中包含空格： 1$ ./test.sh -b &quot;test1 test2&quot; -a 12Found the -b option, with value test1 test2Found the -a option 选项字母和参数值放在一起使用,而不用加空格 1$ ./test.sh -abtest1 12Found the -a optionFound the -b option, with value test1 getopts还能够将命令行上找到的所有未定义的选项统一输出成问号 1$ ./test19.sh -d 1Unknown option: ? 在getopts处理每个选项时,它会将OPTIND环境变量值增一。在getopts完成处理时,你可以使用shift命令和OPTIND值来移动参数。 12345678910111213141516171819202122#!/bin/bashechowhile getopts :ab:cd optdo case &quot;$opt&quot; in a) echo &quot;Found the -a option&quot; ;; b) echo &quot;Found the -b option, with value $OPTARG;; c) echo &quot;Found the -c option&quot; ;; d) echo &quot;Found the -d option&quot; ;; *) echo &quot;Unknown option: $opt&quot; ;; esacdone#shift $[ OPTIND - 1 ]#echocount=1for param in &quot;$@&quot;do echo &quot;Parameter $count: $param&quot; count=$[ $count + 1 ]done 12345678$ ./test.sh -a -b test1 -d test2 test3 test4Found the -a option Found the -b option, with value test1 Found the -d option Parameter 1: test2 Parameter 2: test3 Parameter 3: test4 注意：OPTIND总是存储下一个要处理的元素位置，例如： 1234567891011#!/bin/bashechowhile getopts :ab:cd optdo case &quot;$opt&quot; in a) echo &quot;a = $OPTIND&quot; ;; b) echo &quot;b = $OPTIND&quot; ;; c) echo &quot;c = $OPTIND&quot; ;; d) echo &quot;d = $OPTIND&quot; ;; esacdone 12345$ ./test.sh -a -b test1 -c -da = 2b = 4c = 5d = 6 之所以会有上述输出是因为当处理命令行参数-a时，下一个要处理的参数是-b，而-b参数所在的位置为2，所以a = 2，当处理-b时，下一个参数是test1，但test1不是命令行选项，所以跳过，因此下一个要处理的参数是-c，而-c参数所在的位置为4,后面几个输出的道理是一样的。 我们看另外一种情况： 12345$ ./test.sh -ab test1 -c -da = 1b = 3c = 4d = 5 之所以会有上述输出是因为当成处理命令行参数-a时，下一个要处理的参数是b，依然在处理第一个元素，因此a = 1，当处理b时，下一个参数是test1，但test1不是命令行选项，所以跳过，一次下一个要处理的参数是-c，而-c参数所在的位置为3,后面几个输出的道理是一样的。 read命令从标准输入（键盘）或另一个文件描述符中接受输入，在受到输入后，read命令会将数据放进一个变量： 1234#!/bin/bashecho -n &quot;Enter your name: &quot;read nameecho &quot;Hello $name, welcome&quot; 123$./test.shEnter your name: GTPHello GTP, welcome echo命令后面的-n选项表示不会在字符串末尾输出换行符，允许脚本用户紧跟其后输入数据，而不是下一行。 read命令包含了-p选项，允许直接在read命令行指定提示符： 1234#!/bin/bashread -p &quot;Please enter your age: &quot; agedays=$[ age * 365 ]echo &quot;That makes you over $days days old!&quot; 123$ ./test.shPlease enter your age: 10That makes you over 3650 days old! read命令会将姓和名保存在同一个变量中，read命令会将提示符后输入的所有数据分配给单个变量，要么你指定多个变量，输入的每个数据值都会分配给变量列表中的下一个变量，如果变量数量不够，剩下的数据就全部分配给最后一个变量： 123#!/bin/bashread -p &quot;Enter your name: &quot; first lastecho &quot;Checking data for last, first&quot; 123$ ./test.sh Enter your name: Rich BlumChecking data for Blum, Rich 也可以在read命令中不指定变量，这样read命令会将它收到的任何数据都放进特殊环境变量REPLY中 1234#!/bin/bashread -p &quot;Enter your name: &quot;echoecho Hello $REPLY, welcome! 123$./test.shEnter your name: GTPHello GTP, welcome! read命令可以通过-t选项指定一个计时器，指定了read命令等待输入的秒数，当计时器过期后，read命令会返回一个非零退出状态码： 12345678#!/bin/bashif read -t 5 -p &quot;Please enter your name: &quot; namethen echo &quot;Hello $name, welcome!&quot;else echo echo &quot;Sorry, too slow!&quot;fi read命令还可以统计输入的字符数，当输入的字符数达到预设的字符数时，就自动退出，将输入的数据赋给变量： 12345678910#!/bin/bshread -n1 -p &quot;Do you want to continue [Y/N]? &quot; answercase $answer inY | y) echo echo &quot;fine, continue on...&quot; ;;N | n) echo echo &quot;OK, goodbye&quot; exit ;;esacecho &quot;This is the end of the script&quot; -n1选项告诉read命令在接受单个字符后退出，只要按下单个字符回答后，read命令就会接受输入并将它传给变量，无需按回车键。 read命令的-s选项可以避免在read命令中输入的数据显示在显示器上（实际上数据会被显示，只是read命令会将文本颜色设成跟背景色一样）： 1234#!/bin/bashread -s -p &quot;Enter your password: &quot; passecho echo &quot;Is your password really $pass? &quot; 123$ ./test.shEnter your password:Is your password really T3stlng? 这样输入提示符输入的数据不会出现在屏幕上，但会赋给变量。 read命令可以读取文件中保存的数据，每次调用read命令， 会从文件中读取一行文本，当文件中再没有内容时，read命令会退出并返回非零退出状态码，最常见的方法是对文件使用cat命令，将结果通过管道直接传给read命令的while命令： 12345678#!/bin/bashcount=1cat test | while read linedo echo &quot;Line $count: $line&quot; count=$[ $count + 1 ]doneecho &quot;Finished procession the file&quot; ​","tags":[]},{"title":"[Linux] Shell编程第十七课","date":"2017-12-03T12:01:30.000Z","path":"2017/12/03/[Linux] Shell编程第十七课/","text":"监测磁盘空间du命令能够显示单个文件和目录的磁盘使用情况，-s选项用来总结目录一级的整体使用情况，这在计算单个用户使用的总体磁盘空间时很方便，下面的例子是使用du命令总结/home目录下每个用户的$HOME目录的磁盘占用情况： 1$ sudo du -s /home/* du还有另外一个选项参数-S（大写S），它为每个目录和子目录分别提供了总计信息，例如： 123456789101112$ sudo du -S /var/log/4 /var/log/anaconda.ifcfg.log20 /var/log/anaconda.log32 /var/log/anaconda.program.log108 /var/log/anaconda.storage.log40 /var/log/anaconda.syslog56 /var/log/anaconda.xlog116 /var/log/anaconda.yum.log4392 /var/log/audit4 /var/log/boot.log[...]$ 当然，我们最感兴趣的还是占用磁盘空间最多的目录，所以需要使用sort命令对du产生的输出进行排序： 1$ sudo du -S /var/log/ | sort -rn 其中，-n选项允许按数字排序，-r选项会先列出最大数字（逆序）。下面使用sed编辑器对输出进行优化： 1sed &apos;&#123;11,$D; =&#125;&apos; | sed &apos;N; s/\\n/ /&apos; 对前十名之后的数据删除并且给每一行加上行号，此时再使用gawk命令对输出进行格式化，sed编辑器的输出会通过管道输出到 gawk命令,然后用 printf 函数打印出来： 12345$ sudo du -S /var/log/ |&gt; sort -rn |&gt; sed &apos;&#123;11,$D; =&#125;&apos; |&gt; sed &apos;N; s/\\n/ /&apos; |&gt; gawk &apos;&#123;printf $1 &quot;:&quot; &quot;\\t&quot; $2 &quot;\\t&quot; $3 &quot;\\n&quot;&#125;&apos; 最后输出效果如下： 123456789101: 4396 /var/log/audit2: 3024 /var/log/sa3: 2976 /var/log/4: 420 /var/log/gdm5: 152 /var/log/ConsoleKit6: 80 /var/log/prelink7: 4 /var/log/sssd8: 4 /var/log/samba/old9: 4 /var/log/samba10: 4 /var/log/ppp 下面是完整的shell脚本： 1234567891011121314151617#!/bin/bashCHECK_DIRECTORIES=&quot; /var/log/home&quot;;DATE=$(date ‘+%m%d%y’)exec 0&gt; disk_space_$DATE.rptecho &quot;Top Ten Disk Space Usage&quot;echo &quot;for $CHECK_DIRECTORIES Directories&quot;for DIR_CHECK in $CHECK_DIRECTORIESdo echo &quot;&quot; echo &quot;The $DIR_CHECK Directory:&quot; du -S $DIR_CHECK 2&gt; /dev/null | sort -rn | sed &apos;&#123;11,$D; =&#125;&apos; | sed &apos;N; s/\\n/ /&apos; | gawk &apos;&#123;printf $1 &quot;:&quot; &quot;\\t&quot; $2 &quot;\\t&quot; $3 &quot;\\n&quot;&#125;&apos;doneexit","tags":[{"name":"Linux, Shell","slug":"Linux-Shell","permalink":"https://glemontree.github.io/tags/Linux-Shell/"}]},{"title":"[Linux] Shell编程第十六课","date":"2017-12-03T12:00:48.000Z","path":"2017/12/03/[Linux] Shell编程第十六课/","text":"N: 将数据流中的下一行加进来创建一个多行组来处理 D: 删除多行组中的一行 P: 打印多行组中的一行 小写的n命令告诉sed编辑器移动到数据流中的下一文本行，而不用重新回到命令的最开始再执行一遍，通常sed编辑器在移动到数据流的下一文本行之前，会在当前行上执行完所有定义好的命令，单行next命令改变了这个流程。 /^$/表示匹配空白行 单行的next命令会将数据流中的下一文本行移动到sed编辑器的工作空间（称为模式空间），多行版本的next命令（大写N）会将下一文本行添加到模式空间中已有的文本后。这样的作用是将数据流中的两个文本行合并到同一个模式空间中，文本行仍然用换行符分隔，但sed编辑器现在会将两行文本当成一行来处理： 1234567891011$ nano data2.txtThis is the header line.This is the first data line.This is the second data line.This is the last line.$ $ sed &apos;/first/&#123;N; s/\\n/ /&#125;&apos; data2.txtThis is the header line.This is the first data line. This is the second data line.This is the last line.$ 如果要在数据文件中查找一个可能会分散在两行中的文本短语的话，这是个很实用的应用程序： 123456789101112$ nano data3.txtOn Tuesday, the Linux SystemAdministrator&apos;s group meeting will be held.All System Administrators should attend.Thank you for your attendance.$$ sed &apos;N; s/System Administrator/Desktop User/&apos; data3.txtOn Tuesday, the Linux SystemAdministrator&apos;s group meeting will be held.All Desktop Users should attend.Thank you for your attendance.$ 替换命令会在文本文件中查找特定的双词短语System Administrator，上面这段程序中虽然使用了N命令，但是因为第一行和第二行之间有回车符所以无法识别，需要使用下面的方式： 12345$ sed &apos;N ; s/System.Administrator/Desktop User/&apos; data3.txtOn Tuesday, the Linux Desktop User&apos;s group meeting will be held.All Desktop Users should attend.Thank you for your attendance.$ 需要注意的是上面这段程序中替换命令在System和Administrator之间使用了通配符模式（.）来匹配空格和换行符这两种情况，但当它匹配了换行符时，他就从字符串中删除了换行符，导致两行合并成一行，要解决这种情况，可以在sed编辑器脚本中用两个替换命令：一个用来匹配短语出现在行中的情况，一个用来匹配短语出现在单行中的情况： 1$ sed &apos;N; s/System\\nAdministrator/Desktop\\nUser/; s/System Administrator/Desktop User/&apos; data3.txt 但是这个脚本还有一个问题，这个脚本总是在执行sed编辑器命令前将下一行文本读入到模式空间，当它到了最后一行文本时，就没有下一行可读了，所以N命令会叫sed编辑器停止，如果要匹配的文本正好在数据流的最后一行，命令就不会发现要匹配的数据，解决方式是将单行命令放到N命令前面，并将多行命令放到N命令后面; 1$ sed &apos;s/System Administrator/Desktop User/; N; s/System\\nAdministrator/Desktop\\nUser/&apos; data3.txt 单行删除命令d在和N一起使用时如果匹配成功，会将模式空间中两行同时删除，sed编辑器提供了多行删除命令D，它只删除模式空间中的第一行，该命令会删除到换行符（含换行符）为止的所有字符： 1234$ sed &apos;N; /System\\nAdministrator/D&apos; data4.txtAdministrator&apos;s group meeting will be held.All System Administrators should attend.$ 如果需要删除目标数据字符串所在行的前一文本行，这个命令很有用处，这里有个例子，它会删除数据流中出现在第一行前的空白行： 123456789101112$ nano data5.txtThis is the header line.This is a data line.This is the last line.$$ sed &apos;/^$/&#123;N; /header/D&#125;&apos; data5.txtThis is the header line.This is a data line.This is the last line. sed编辑器会查找空白行，然后用N命令来将下一文本行添加到模式空间，如果新的模式空间内内容含有单词header，则D命令会删除模式空间中的第一行。 多行打印命令只打引多行模式空间中的第一行，这包括模式空间中直到换行符为止的所有字符 需要的是D命令会强制sed编辑器返回到脚本的起始处，对同一模式空间中的内容重新执行这些命令（它不会从数据流中读取新的文本行） 模式空间是一块活跃的缓冲区，在sed编辑器执行命令时它会保存待检查的文本，sed编辑器有另一块称作保持空间的缓冲区域，在处理模式空间中的某些行时，可以用保持空间来临时保存一些行，有5条命令可用来操作保持空间空间： 命令 描述 h 将模式空间复制到保持空间 H 将模式空间附加到保持空间 g 将保持空间复制到模式空间 G 将保持空间附加到模式空间 x 交换保持空间和模式空间的内容 1234567891011$ nano data2.txtThis is the header line.This is the first data line.This is the second data line.This is the last line.$$ sed -n &apos;/first/ &#123;h;p;n;p;g;p&#125;&apos; data2.txtThis is the first data line.This is the second data line.This is the first data line.$ 感叹号命令(!)用来排除命令，也就是让原本会起作用的命令不起作用： 1234$ sed -n &apos;/header/!p&apos; data2.txtThis is the first data line.This is the second data line.This is the last line. 除了包含单词header那一行之外，文件中其他所有的行都被打印出来了。 1$ sed &apos;N; s/System\\nAdministrator/Desktop\\nUser/; s/System Administrator/Desktop User/&apos; data4.txt 123On Tuesday, the Linux DesktopUser&apos;s group meeting will be held.All System Administrators should attend. 1$ sed &apos;$!N; s/System\\nAdministrator/Desktop\\nUser/; s/System Administrator/Desktop User/&apos; data4.txt 123On Tuesday, the Linux DesktopUser&apos;s group meeting will be held.All Desktop Users should attend. 上面这段程序中，美元符表示数据流中的最后一行文本，所以当sed编辑器到了最后一行时，它没有执行N命令，但它对其他行都执行了这个命令，使用这种方法，你可以反转数据流中文本行的顺序。流程如下： 在模式空间中放置一行; 将模式空间中的行放到保持空间中; 在模式空间中放入下一行; 将保持空间附加到模式空间后; 将模式空间中的所有内容都放到保持空间中; 重复执行第(3)~(5)步,直到所有行都反序放到了保持空间中; 提取并打印行。 123456789101112$ nano data2.txtThis is the header line.This is the first data line.This is the second data line.This is the last line.$$ sed -n &apos;&#123;1!G; h; $p&#125;&apos; data2.txtThis is the last line.This is the second data line.This is the first data line.This is the header line.$ 当然，Linux命令tac也有反转文本文件的功能，tac命令会倒序显示一个文本文件，它执行的正好是和cat命令相反的功能。 sed提供了一种方法，可以基于地址、地址模式或地址空间排除一整块命令，这允许你只对数据流中的特定行执行一组命令。 分支命令b的格式如下：[address]b [label] address参数决定了哪些行的数据会触发分支命令，label参数定义了要跳转到的位置，如果没有加label参数，跳转命令会跳转到脚本的结尾： 123456789101112$ nano data2.txtThis is the header line.This is the first data line.This is the second data line.This is the last line.$$ sed &apos;&#123;2,3b; s/This is/Is this/; s/line./test?/&#125;&apos; data2.txtIs this the header test?This is the first data line.This is the second data line.Is this the last test?$ 分支命令在数据流中的第2行和第3行处跳过了两个替换命令，要是不想直接跳到脚本的结尾，可以为分支命令定义一个要跳转到的标签，标签以冒号开始，最多可以是7个字符长度:label2 要指定标签，将它加到b命令后即可，使用标签允许你跳过地址匹配处的命令，但仍然执行脚本中的其他命令。 123456$ sed &apos;&#123;/first/b jump1; s/This is the/No jump on/; :jump1; s/This is the/Jump here on/&#125;&apos; data2.txtNo jump on header lineJump here on first data lineNo jump on second data lineNo jump on last line$ 下面这个例子演示了跳转到sed脚本中靠前面的标签上，这样就达到了循环的效果： 123456789$ echo &quot;This, is, a, test, to, remove, commas.&quot; | sed -n &apos;&#123;:start; s/,//1p; b start;&#125;&apos;This is, a, test, to, remove, commas.This is a, test, to, remove, commas.This is a test, to, remove, commas.This is a test to, remove, commas.This is a test to remove, commas.This is a test to remove commas.^C$ 这个脚本有一个问题它会不停的寻找逗号陷入了一个死循环中，可以这样解决，为分支命令指定一个地址模式来查找： 123456789101112$ echo &quot;This, is, a, test, to, remove, commas.&quot; | sed -n &apos;&#123;&gt; :start&gt; s/,//1p&gt; /,/b start&gt; &#125;&apos;This is, a, test, to, remove, commas.This is a, test, to, remove, commas.This is a test, to, remove, commas.This is a test to, remove, commas.This is a test to remove, commas.This is a test to remove commas.$ 现在分支命令只会在行中有逗号的情况下跳转，在最后一个逗号被删除后分支命令不会再执行。 测试命令t也可以改变sed编辑器脚本的执行流程，测试命令会根据替换命令的结果跳转到某个标签，而不是根据地址进行跳转，如果替换命令成功匹配并替换了一个模式，测试命令就会跳转到指定的标签，如果替换命令未能匹配到指定的模式，测试命令就不会跳转。[address]t [label] 跟分支命令一样，在没有指定标签的情况下，如果测试成功，sed会跳转到脚本的结尾。 举个例子，如果已经做了一个替换，不需要再做另一个替换，那么测试命令就能帮上忙： 123456$ sed &apos;s/first/matched; t; s/This is the/No match on/&apos; data2.txtNo match on header lineThis is the matched data lineNo match on second data lineNo match on last line$ 设想下面这种情况： 123$ echo &quot;The cat sleeps in his hat.&quot; | sed &apos;s/.at/&quot;.at&quot;/g&apos;The &quot;.at&quot; sleeps in his &quot;.at&quot;.$ 这显然不是我们想要的效果，用于替代的字符串无法匹配已匹配单词中的通配字符。 sed编辑器提供了一种解决方法，&amp;符号可以用来代表替换命令中的匹配的模式，不管模式匹配的是什么样的文本，你都可以在替代模式中使用&amp;符号来使用这段文本，这样就可以操作模式所匹配到的任何单词了： 123$ echo &quot;The cat sleeps in his hat.&quot; | sed &apos;s/.at/&quot;&amp;&quot;/g&apos;The &quot;cat&quot; sleeps in his &quot;hat&quot;.$ 当模式匹配了单词cat,”cat”就会出现在了替换后的单词里。当它匹配了单词hat,”hat”就出现在了替换后的单词中。 sed编辑器用圆括号来定义替换模式中的子模式，你可以在替代模式中使用特殊字符来引用每个子模式，替代字符由反斜线和数字组成，数字表明子模式的位置，sed编辑器会给第一个子模式分配字符\\1，给第二个子模式分配字符\\2，以此类推。 需要注意的是当在替换命令中使用圆括号时，需要用转义字符将它们标识为分组字符而不是普通的圆括号： 123$ echo &quot;The System Administrator manual&quot; | sed &apos;s/(System) Administrator/\\1 User&apos;The System User manual$ 如果需要用一个单词来替换一个短语，而这个单词刚好是该短语的子字符串，但那个子字符串碰巧使用了通配符，这时使用子模式会方便很多。 123456$ echo &quot;That furry cat is pretty&quot; | sed &apos;s/furry (.at)/\\1/&apos;That cat is pretty$$ echo &quot;That furry hat is pretty&quot; | sed &apos;s/furry (.at)/\\1/&apos;That hat is pretty$ 在这种情况下，你不能使用&amp;符号，因为它会替换整个匹配的模式，这个时候就得使用子模式，允许你选择将模式中的某部分作为替代模式。 当需要在两个或多个子模式之间插入文本时，这个特性尤其有用，举个例子，使用子模式在大叔子中插入逗号： 123$ echo &quot;1234567&quot; | sed &apos;&#123;:start; s/(.*[0-9])([0-9]&#123;3&#125;)/\\1,\\2; t start&#125;&apos;1,234,567$ 这个模式会查找两个子模式。第一个子模式是以数字结尾的任意长度的字符。第二个子模式是若干组三位数字。如果这个模式在文本中找到了,替代文本会在两个子模式之间加一个逗号,每个子模式都会通过其位置来标示。这个脚本使用测试命令来遍历这个数字,直到放置好所有的逗号。 在shell脚本中可以将普通的shell变量及参数和sed编辑器脚本一起使用，例如： 1234$ nano reverse.sh#!/bin/bashsed -n &apos;&#123; 1!G ; h ; $p &#125;&apos; $1$ 这个脚本使用shell参数$1从命令行中提取第一个参数，这正是需要进行反转的文件名。现在你能在任何文件中轻松使用这个sed编辑器脚本，再不用每次在命令行上重新输入了。 可以在脚本中用 $()将sed编辑器命令的输出重定向到一个变量中,以备后用。下面的例子使用sed脚本来向数值计算结果添加逗号。 1234567891011121314151617181920212223242526$ cat fact.sh#!/bin/bash#Add commas to number in factorial answer#factorial=1counter=1number=$1#while [ $counter -le $number ]do factorial=$[ $factorial * $counter ] counter=$[ $counter + 1 ]done#result=$(echo $factorial | sed &apos;&#123;:starts/\\(.*[0-9]\\)\\([0-9]\\&#123;3\\&#125;)/\\1,\\2/t start&#125;&apos;)#echo &quot;The result is $result&quot;#$$ ./fact.sh 20The result is 2,432,902,008,176,640,000$ 有些bash命令也可以添加行号，但它们会另外加入一些东西（有可能是不需要的间隔），例如： 123456789101112$ nl data2.txt1 This is the2 This is the3 This is the4 This is the$$ cat -n data2.txt1 This is the2 This is the3 This is the4 This is the$ 看下面这个程序: 12345678910$ sed &apos;=&apos; data2.txt1This is the header line.2This is the first data line.3This is the second data line.4This is the last line.$ =号命令可以添加行号，但是行号显示在行的上面，需要结合sed命令将两者放在同一行。","tags":[{"name":"Linux, Shell","slug":"Linux-Shell","permalink":"https://glemontree.github.io/tags/Linux-Shell/"}]},{"title":"[Linux] Shell编程第十五课","date":"2017-12-03T11:59:52.000Z","path":"2017/12/03/[Linux] Shell编程第十五课/","text":"在gawk编程语言中，你可以做下面的事情： 定义变量来保存数据 使用算术和字符串操作符来处理数据 使用结构化编程概念（比如if-then语句和循环）来为数据处理增加处理逻辑 通过提取数据文件中的数据元素，将其重新排列或格式化，生成格式化报告 gawk程序的基本格式如下： 1gawk options program file 下面是gawk程序的可用选项： 选项 描述-F fs 指定行中划分数据字段的字段分隔符-f file 从指定的文件中读取程序-v var=value 定义gawk程序中的一个变量及其默认值gawk的强大之处在于程序脚本，可以写脚本来读取文本行的数据，然后处理并显示数据，创建任何类型的输出报告 gawk程序脚本使用一对花括号来定义，你必须将脚本命令放到两个花括号中，由于gawk命令行假定脚本是单个文本字符串，你必须将脚本放到单引号中： 1$ gawk &apos;&#123;print &quot;Hello World&quot;&#125;&apos; 当你在shell中执行这个命令时，shell中不会有任何输出，这是因为没有在命令行中指定文件名，所以gawk程序会从STDIN接收数据，在运行这个程序的时候，它会一直等待从STDIN输入的文本。 gawk程序会对每行文本执行脚本程序。 Ctrl+D组合键会在bash中产生一个EOF字符，这个组合键能够终止该gawk程序并返回到命令行界面提示符下 gawk的主要特性之一是其处理文本文件中的数据的能力，它会自动给一行中的每个数据元素分配一个变量，默认情况下，gawk会将如下变量分配给它在文本行中发现的数据字段： $0代表整个文本行 $1代表文本行中的第一个数据字段 $2代表文本行中的第二个数据字段 $n代表文本行中的第n个数据字段 在文本行中，每个数据字段都是通过字段分隔符来划分的，gawk在读取一行文本时，会用预定义的字段分隔符划分每个数据字段，gawk中默认的字段分隔符是任意的空白字符（例如空格或制表符），下面的程序会读取文本文件，只显示第一个数据字段的值： 123456789$ nano data.txtOne line of test text.Two lines of test text.Three lines of test text.$ gawk &apos;&#123;print $1&#125;&apos; data.txtOneTwoThree$ 如果你要读取采用了其他字段分隔符的文件，可以用-F选项指定： 1$ gawk -F: &apos;&#123;print $1&#125;&apos; /etc/passwd 要在命令行上的程序脚本中使用多条命令，只要在命令之间放个分号即可; 12$ echo &quot;My name is Rich&quot; | gawk &apos;&#123;$4=&quot;gtp&quot;; print $0&#125;&apos;My name is gtp 从文件中读取程序：gawk编辑器允许将程序存储在文件中，然后在命令行中引用： 123$ nano script.gawk&#123;print $1 &quot;&apos;s home directory is &quot; $6&#125;$ gawk -F: -f script.gawk /etc/passwd BEGIN关键字可以在处理数据前运行脚本，它会强制gawk在读取数据前指定BEGIN关键字后指定的程序脚本： 123$ gawk &apos;BEGIN&#123;print &quot;Hello World!&quot;&#125;&apos;Hello World!$ END关键字允许你指定一个程序脚本，gawk会在读完数据后执行它： 123$ gawk &apos;BEGIN &#123;print &quot;The data3 File Contents:&quot;&#125;&apos;&gt; &#123;print $0&#125;&gt; END &#123;print &quot;End of File&quot;&#125;&apos; data.txt 可以将所有内容放在一起组成一个脚本文件： 12345678910111213$ nano script.gawkBEGIN &#123; print &quot;The latest list of users and shells&quot; print &quot;UserID \\t Shell&quot; print &quot;------ \\t ------&quot; FS=&quot;:&quot;&#125;&#123; print $1 &quot; \\t &quot; $7&#125;END &#123; print &quot;This concludes the listing&quot;&#125; 内建变量FS可以更改字段分隔符，还有其他一些内建变量： FIELDWIDTHS 由空格分隔的一列数字，定义了每个数据字符的确切宽度 FS 输入字段分隔符 RS 输入记录分隔符 OFS 输出字段分隔符 ORS 输出记录分隔符 默认情况下，gawk将OFS设为一个空格，所以如果你用命令： print $1, $2, $3会看到如下输出： field1 field2 field3 print命令会自动将OFS变量的值放置在输出中的每个字符间，通过设置OFS变量，可以在输出中使用任意字符串来分隔字段： 1234$ gawk &apos;BEGIN&#123;FS=&quot;,&quot;; OFS=&quot;-&quot;&#125; &#123;print $1,$2,$3&#125;&apos; data1data11-data12-data13data21-data22-data23data31-data32-data33 变量RS和ORS定义了gawk程序如何处理数据流中的记录，默认情况下，gawk将RS和ORS设为换行符，默认的RS表明，输入数据流中的每行新文本就是一条新记录。 有时你会在数据流中碰到占据多行的记录，例如： 1234Riley Mullen123 Main StreetChicago, IL 60601(312)555-1234 如果使用默认的FS和RS变量值来读取这段数据，gawk就会把每行作为一条单独的记录来读取，并将记录中的空格当作字段分隔符，为了解决这个问题，只需要把FS变量值设置为换行符，这就表明数据流中的每行都是一个单独的字段，每行上的所有数据都属于同一个字段，现在还有一个问题就是无从判断一个新的数据行从何开始，对于这个问题，可以将RS变量设置为空字符串，然后在数据记录之间留一个空白行，gawk会把每个空白行当作一个记录分隔符。 123456789101112131415161718192021$ cat data2Riley Mullen123 Main StreetChicago, IL 60601(312)555-1234Frank Williams456 Oak StreetIndianapolis, IN 46201(317)555-9876Haley Snell4231 Elm StreetDetroit, MI 48201(313)555-4938$ gawk &apos;BEGIN&#123;FS=&quot;\\n&quot;; RS=&quot;&quot;&#125; &#123;print $1,$4&#125;&apos; data2Riley Mullen (312)555-1234Frank Williams (317)555-9876Haley Snell (313)555-4938$ ARGC和ARGV变量允许从shell中获得命令行参数的总数以及它们的值，但是gawk并不会将程序脚本当成命令行参数的一部分： 12$ gawk &apos;BEGIN &#123;print ARGC, ARGV[1]&#125;&apos; data12 data1 ARGC变量表示命令行上有两个参数，这包括gawk命令和data1参数，需要注意的是程序脚本并不算参数，ARGV数组从索引0开始，代表的是命令，第一个数组值是gawk命令后的第一个命令行参数 NF变量可以让你在不知道具体位置的情况下指定记录中的最后一个数据字段 可以在gawk命令行上给程序中的变量赋值，这允许你在正常的代码之外赋值，及时改变变量的值： 123456789101112$ cat script1BEGIN&#123;FS=&quot;,&quot;&#125;&#123;print $n&#125;$ gawk -f script1 n=2 data1data12data22data32$ gawk -f script1 n=3 data1data13data23data33$ 使用命令行参数来定义变量值会有一个问题，在你设置了变量后，这个值在代码的BEGIN部分不可用： 123456789$ cat script2BEGIN&#123;print &quot;The starting value is&quot;,n; FS=&quot;,&quot;&#125;&#123;print $n&#125;$ gawk -f script2 n=3 data1The starting value isdata13data23data33$ 可以用-v命令行参数来解决这个问题，它允许你在BEGIN代码之前设定变量，在命令行上，-v命令行参数必须放在脚本代码之前： 1gawk -v n=3 -f script data1 gawk编程语言使用关联数组提供数组功能，关联数组和数字数组的不同之处在于它的索引值可以是任意字符串，你不需要使用连续的数字来标识数组中的数据元素，相反，关联数组使用各种字符串来引用值，每个索引字符串都必须能够唯一地标识出赋给它的数据元素 数组变量赋值的格式为：var[index] = element，其中var是变量名，index是关联数组的索引值，element是数组元素值，例如： 123456$ gawk &apos;BEGIN&#123;&gt; capital[&quot;Illinois&quot;] = &quot;Springfield&quot;&gt; print capital[&quot;Illinois&quot;]&gt; &#125;&apos;Springfield$ 如果要在gawk中遍历一个关联数组，可以用for语句的一种特殊形式： 123for (var in array) &#123; statements;&#125; 这个for语句会在每次循环时将关联数组array的下一个索引值赋给变量var，然后执行一遍statements： 123456789101112131415$ gawk &apos;BEGIN&#123;&gt; var[&quot;a&quot;] = 1&gt; var[&quot;g&quot;] = 2&gt; var[&quot;m&quot;] = 3&gt; var[&quot;u&quot;] = 4&gt; for (test in var)&gt; &#123;&gt; print &quot;Index:&quot;,test,&quot; - Value:&quot;,var[test]&gt; &#125;&gt; &#125;&apos;Index: u - Value: 4Index: m - Value: 3Index: a - Value: 1Index: g - Value: 2$ 需要注意的是，索引值不会按任何特定顺序返回，但他们都能够执行对应的数据元素值。 如果需要从关联数组中删除数组索引需要使用下面的命令： 1delete array[index] 在使用正则表达式时，正则表达式必须出现在它要控制的程序脚本的左花括号之前： 123$ gawk &apos;BEGIN&#123;FS=&quot;,&quot;&#125; /11/&#123;print $1&#125;&apos; data1data11$ 正则表达式/11/匹配了数据字段中含有字符串11的记录，gawk程序会用正则表达式对记录中所有的数据字段进行匹配，包括字段分隔符： 1234$ gawk &apos;BEGIN&#123;FS=&quot;,&quot;&#125; /,d/&#123;print $1&#125;&apos; data1data11data21data31 匹配操作符允许将正则表达式限定在记录中的特定数据字段，匹配操作符是波浪先（～），可以指定匹配操作符、数据字段变量、以及要匹配的正则表达式： 1$1 ~ /^data/ $1变量代表记录中的第一个数据字段，这个表达式会过滤出第一个字段以文本data开头的所有记录： 123$ gawk &apos;BEGIN &#123;FS=&quot;,&quot;&#125; 2 ~ /^data2/&#123;print $0&#125;&apos; data1data21,data22,data23$ 匹配操作符会用正则表达式/^data2/来比较第二个数据字段，该正则表达式指明字符串要以文本data2开头。 123$ gawk -F: &apos;$1 ~ /rich/&#123;print $1,$NF&#125;&apos; /etc/passwdrich /bin/bash$ 这个例子会在第一个数据字段中查找文本rich，如果记录中找到了这个模式，它会打印该记录的第一个和最后一个数据字段值 除了正则表达式，你也可以在匹配模式中用数学表达式，这个功能在匹配数据字段中的数字值时非常方便，举个例子，如果你想显示所有属于root用户组（组ID为0）的系统用户： 123$ gawk -F: &apos;4 == 0&#123;print $1&#125;&apos; /etc/passwdroot$ 这段脚本会查看第四个数据字段含有值为0的记录。 也可以对文本数据使用表达式，但必须小心，跟正则表达式不同，表达式必须完全匹配，数据必须跟模式严格匹配。 if语句的格式： 12if (condition) statement1 当然也可以放在一行上： 1if (condition) statement1 while语句的格式： 123while (condition) &#123; statements&#125; 举个例子如下： 1234567891011121314$ gawk &apos;&#123;&gt; total = 0&gt; i = 1&gt; while (i &lt; 4) &#123;&gt; total += $i&gt; i++&gt; &#125;&gt; avg = total / 3&gt; print &quot;Average: &quot;, avg&gt; &#125;&apos; dataAverage: 128.333Average: 137.667Average: 176.667$ 这里需要注意的是gawk脚本程序会对数据中的每一行都执行一遍 for语句的格式： 1for ( variable assignment; condition; iteration process ) gawk可以格式化打印输出，此时可以使用printf指令： 1printf &quot;format string&quot;, var1, var2 格式化指定符采用如下格式： 1%[modifier] control-letter 其中control-letter是一个单子符代码，用来指明显示什么类型的数据，而modifier定义了可选的格式化特性。 gawk中定义自己的函数，必须用function关键字： 123function name([variables]) &#123; statements&#125; 可以在调用gawk程序中传给这个函数一个或多个变量，当然，函数还能用return语句返回值：return value 在定义函数时，它必须出现在所有代码块之前（包括BEGIN代码块）： 123456789101112$ gawk &apos;&gt; function myprint() &gt; &#123;&gt; printf &quot;%-16s - %s\\n&quot;, 1, 4&gt; &#125;&gt; BEGIN &#123;FS=&quot;\\n&quot;; RS=&quot;&quot;&#125;&gt; &#123;&gt; myprint()&gt; &#125;&apos; data1Riley Mullen - (312)555-1234Frank Williams - (317)555-9876Haley Snell - (313)555-4938 创建函数库： 首先，创建一个存储所有gawk函数的文件： 123456789101112$ cat funclibfunction myprint() &#123; printf &quot;%-16s - %s\\n&quot;, $1, $4&#125;function myrand(limit) &#123; return int(limit * rand())&#125;function printthird() &#123; print $3&#125;$ funclib文件含有三个函数定义，需要使用-f命令行参数来使用他们，很遗憾，不能将-f命令行参数和内联gawk脚本放在一起使用，不过可以在同一个命令行中使用多个-f参数，因此要使用库，只要创建一个含有你的gawk程序的文件，然后在命令行上同时指定库文件和程序文件就行了： 123456$ cat script4BEGIN &#123; FS=&quot;\\n&quot;; RS=&quot;&quot;&#125;&#123; myprint()&#125;$ gawk -f funclib -f script4 data2 处理数据文件时，关键是要先把相关的记录放在一起，然后对相关数据进行必要的计算，举个例子如下： 我们手边有一个数据文件，其中包含了两个队伍（每对两名选手）的保龄球比赛得分情况： 12345$ cat scores.txtRich Blum,team1,100,115,95Barbara Blum,team1,110,115,100Christine Bresnahan,team2,120,115,118Tim Bresnahan,team2,125,112,116 每位选手都有三场比赛的成绩，这些成绩保存在数据文件中，每位选手由位于第二列的队名来标识，下面的脚本对每对的成绩进行了排序，并计算了总分和平均分。 1234567891011121314151617$ cat bowling.sh#!/bin/bashfor team in $(gawk -F, &#123;print $2&#125; scores.txt | unique)do gawk -v team=$team &apos;BEGIN&#123;FS=&quot;,&quot;; total=0&#125;&apos; &#123; if ($2 == team) &#123; total += $3 + $4 + $5 &#125; &#125; END &#123; avg = total / 6; print &quot;Total for&quot;, team, &quot;is&quot;, total, &quot;, the average is&quot;, avg &#125;&apos; scores.txtdone$ for 循环中的第一条语句过滤出数据文件中的队名，然后使用uniq命令返回不重复的队名，for循环再对每个队进行迭代 1234$ ./bowling.shTotal for team1 is 635, the average is 105.833Total for team2 is 706, the average is 117.667$","tags":[{"name":"Linux, Shell","slug":"Linux-Shell","permalink":"https://glemontree.github.io/tags/Linux-Shell/"}]},{"title":"[Linux] Shell编程第十四课","date":"2017-12-03T11:57:31.000Z","path":"2017/12/03/[Linux] Shell编程第十四课/","text":"有两种格式可以在shell中创建函数： 采用关键字function，后跟分配给该代码块的函数名： 123function name &#123; commands&#125; 更加接近于其他编程语言中定义函数的方式： 123name() &#123; commands&#125; 要在脚本中使用函数，只需要像其他shell命令一样，在行中指定函数名就可以了： 1234567891011121314#!/bin/bash#using a function in a scriptfunction func1 &#123; echo &quot;This is an example of a function&quot;&#125;count=1while [ $count -le 5 ]do func1 count=[ count + 1 ]doneecho &quot;This is the end of the loop&quot;func1echo &quot;Now this is the end of the script&quot; bash shell把函数当作一个小型脚本，运行结束时会返回一个退出状态码 默认退出状态码 默认情况下，函数的退出状态码是函数中最后一条命令返回的退出状态码，在函数执行结束后，可以用$?来确定函数的退出状态码 使用return命令 bash shell使用return命令来退出函数并返回特定的退出状态码，return命令允许你指定一个整数值来定义函数的退出状态码。 12345678#!/bin/bashfunction db1 &#123; read -p &quot;Enter a value: &quot; value echo &quot;doubling the value&quot; return $[ $value * 2 ]&#125;db1echo &quot;The new value is $?&quot; 使用这种方法从函数中返回值，需小心： 函数一结束就取返回值 退出状态码必须是0~255 如果在用$?变量提取函数返回值之前执行了其他命令，函数的返回值就会丢失。 使用函数输出，将函数的输出保存到变量中：result=’db1’，这个命令将db1函数的输出赋给$result变量： 1234567#!/bin/bash function db1&#123; read -p &quot;Enter a value: &quot; value echo $[ $value * 2 ] &#125; result=$(db1) echo &quot;The new value is $result&quot; 函数可以使用标准的参数环境变量来表示命令行上传给函数的参数，例如函数名会在$0变量中定义，函数命令行上的任何参数都会通过$1、$2等定义，也可以用特殊变量$#来判断传给函数的参数数目： 123456789101112131415#!/bin/bashfunction addem &#123; if [ $# -eq 0 ] || [ $# -gt 2 ] then echo -1 elif [ $# -eq 1 ] then echo $[ $1 + $1 ] else echo $[ $1 + $2 ] fi&#125;echo -n &quot;Adding 10 and 15: &quot;value=$(addem 10 15)echo $value 由于函数使用特殊参数环境变量作为自己的参数值，因此无法直接获取脚本在命令行中的参数值： 1234567891011#!/bin/bashfunction badfunc1 &#123; echo $[ $1 * $2 ]&#125;if [$# -eq 2] then value=$(badfunc1) echo &quot;The result is $value&quot;else echo &quot;Usage: badtest1 a b&quot;fi 尽管函数也使用了$1和$2变量，但它们和脚本主体中的$1和$2变量并不相同，要在函数中使用这些值，必须在调用函数时手动将它们传过去。 1234567891011#!/bin/bashfunction func &#123; echo $[ $1 * $2 ]&#125;if [$# -eq 2]then value=$(func $1 $2) echo &quot;The result is $value&quot;else echo &quot;Usage: badtest a b&quot;fi 在函数内部使用的任何变量都可以被声明为局部变量，只要在变量声明的前面加上local关键字即可：local temp，当然也可以在变量赋值语句中使用local关键字： 1local temp=[ value + 5 ] 向函数传数组参数： 123456789#!/bin/bashfuncton testit &#123; echo &quot;The parameters are: $@&quot; thisarray=$1 echo &quot;The received array is $&#123;thisarray[*]&#125;&quot;&#125;myarray=(1 2 3 4 5)echo &quot;The original array is: $&#123;myarray[*]&#125;&quot;testit $myarray 1234$ ./badtest3The original array is: 1 2 3 4 5The parameters are: 1The received array is 1 如果你试图将数组变量作为函数参数，函数只会取数组变量的第一个值，要解决这个问题，你可以将该数组变量的值分解成单个的值，然后将这些值作为函数参数使用，在函数内部，可以将所有的参数重新组合成一个新的变量： 123456789#!/bin/bashfunction testit &#123; local newarray newarray=(&apos;echo &quot;$@&quot;&apos;) echo &quot;The new array value is: $&#123;newarray[*]&#125;&quot;&#125;myarray=(1 2 3 4 5)echo &quot;The original array is $&#123;myarray[*]&#125;&quot;testit $&#123;myarray[*]&#125; 另一个例子如下: 12345678910111213141516#!/bin/bashfunction addarray &#123; local sum=0 local newarray newarray=($(echo &quot;$@&quot;)) for value in $&#123;newarray[*]&#125; do sum=$[ $sum + $value ] done echo $sum&#125;myarray=(1 2 3 4 5)echo &quot;The original array is $&#123;myarray[*]&#125;&quot;arg1=$(echo &#123;myarray[*]&#125;)result=$(addarray arg1)echo &quot;The result is $result&quot; 从函数里向shell脚本传回数组变量可以使用echo语句按正确顺序输出单个数组值，然后脚本再将它们放进一个新的数组变量中： 12345678910111213141516171819#!/bin/bashfunction arraydblr &#123; local orginarray local newarray local elements local i originarray=((echo &quot;$@&quot;)) newarray=((echo &quot;$@&quot;)) elements=[ $# - 1 ] for (( i = 0; i &lt;= $elements; i++ )) &#123; newarray[$i]=$[ $&#123;originarray[$i]&#125; * 2 ] &#125; echo $&#123;newarray[*]&#125;&#125;myarray=(1 2 3 4 5)echo &quot;The original array is: $&#123;myarray[*]&#125;&quot;arg1=(echo $&#123;myarray[*]&#125;)result=($(arraydblr arg1))echo &quot;The new array is: $&#123;result[*]&#125;&quot; 给一个递归的例子： 1234567891011121314#!/bin/bashfunction factorial &#123; if [ $1 -eq 1 ] then echo 1 else local temp=$[ $1 - 1 ] local result=$(factorial $temp) echo $[ $result * $1 ] fi &#125;read -p &quot;Enter value: &quot; valueresult=(factorial $value)echo &quot;The factorial of value is: $result&quot; bash shell 允许创建库文件，然后在多个脚本中引用该库文件，这个过程的第一步就是创建一个包含脚本中所需函数的公用库文件： 12345678910111213141516$cat myfuncsfunction addem &#123; echo $[ $1 + $2 ]&#125;function multem &#123; echo $[ $1 * $2 ]&#125;function divem &#123; if ($2 -ne 0) then echo $[ $1 / $2 ] else echo -1 fi&#125; 下一步就是在用到这些函数的脚本文件中包含myfuncs库文件，和环境变量一样，shell函数仅在定义它的shell会话内有效，如果你在shell命令行界面的提示符下运行myfuncs shell脚本，shell会创建一个新的shell并在其中运行这个脚本，它会为那个新的shell定义这三个函数，但当你运行另外一个要用到这些函数的脚本时，它们是无法使用的。 使用函数库的关键在于source命令，source命令会在当前shell上下文中执行命令，而不是创建一个新的shell，可以用source命令在shell脚本中运行库文件脚本，这样脚本就可以使用库中的函数了。 source命令有个快捷的别名，称作点操作符，要在shell脚本中运行myfuncs库文件，只需要这样：. ./myfuncs： 12345678910#!/bin/bash. ./myfuncs value1=10 value2=5 result1=(addem $value1 $value2) result2=(multem $value1 $value2) result3=(diven $value1 $value2) echo &quot;The result of adding them is: $result1&quot; echo &quot;The result of multiplying them is: $result2&quot; echo &quot;The result of dividing them is: $result3&quot; 在命令行上创建函数： 采用单行方式定义参数： 1234$ function divem &#123; echo $[ $1 + $2 ]; &#125;$ divem 100 520$ 当在命令行上定义函数时，需要在每个命令后面加上分号，这样shell就能知道在哪里是命令的起止了。 采用多行方式定义函数： 123456$ function multem &#123;&gt; echo [ 1 * $2 ]&gt; &#125;$ multem 2 510$ 在函数的尾部使用花括号，shell就会知道你已经完成了函数的定义。 在命令行上定义的函数在退出shell时函数就会消失，一个好的方法就是将函数定义在一个特定的位置，这个位置在每次启动一个新shell的时候，都会由shell重新载入。 可以将函数放在.bashrc中，有两种方法： 直接在.bashrc文件中定义函数 读取函数文件，只要是在shell脚本中，都可以使用source命令将库文件中的函数添加到你的.bashrc脚本中 更好的是，shell还会将定义好的函数传给子shell进程，这样一来，这些函数就自动能够用于该shell会话的任何sehll脚本了","tags":[{"name":"Linux, Shell","slug":"Linux-Shell","permalink":"https://glemontree.github.io/tags/Linux-Shell/"}]},{"title":"[Linux] Shell编程第十三课","date":"2017-12-03T11:55:01.000Z","path":"2017/12/03/[Linux] Shell编程第十三课/","text":"默认情况下，bash shell会忽略收到的任何SIGQUIT（3）和SIGTERM（5）信号，但是bash shell会处理收到的SIGHUP（1）和SIGINT（2）信号，如果bash shell收到了SIGHUP信号，它就会退出，但在退出之前，它会将SIGHUP信号传给所有由该shell所启动的进程（包括正在运行的shell脚本） Ctrl+C组合键会生成SIGINT信号，并将其发送给当前在shell中运行的所有进程，该信号会停止shell中当前运行的进程。 可以在进程运行期间暂停进程，而无需终止它，Ctrl+Z组合键会生成一个SIGTSTP信号，停止shell中运行的任何进程，停止进程和终止进程不同：停止进程会让程序继续停留在内存中，并能从上次停止的位置继续运行。shell将shell中运行的每个进程称为作业，并为每个作业分配唯一的作业号，它会给第一个作业分配作业号1，第二个作业号2，可以使用ps -l命令察看已停止的作业，此时S列中进程的状态为T，表示命令要么被追踪，要么被停止了。 trap命令允许你来指定shell脚本要监看并从shell中拦截的Linux信号，如果脚本收到了trap命令中列出的信号，该信号不再由shell处理，而是交由本地处理： trap commands signals，commands表示想要shell执行的命令，signals表示待捕获的信号，可以用数值或Linux信号名来指定信号。 要捕获shell脚本的退出，只要在trap命令后加上EXIT信号即可：trap “echo Goodbye…” EXIT 在trap命令与希望恢复默认行为的信号列表之前加上两个破折号可以删除已设置好的捕获：trap – SIGINT 在命令后加上&amp;符号就可以让shell脚本以后台模式运行：./test.sh &amp;，当执行了上面这条命令后，会输出类似于下面这条语句：[1] 3231，其中方括号中的数字是shell分配给后台进程的作业号，下一个数是Linux系统分配给进程的进程ID（PID）。 nohup命令运行了另外一个命令来阻断所有发送给该进程的SIGHUP信号，这会在退出终端会话时阻止进程退出： 1nohup ./test.sh &amp; 由于nohup命令会解除终端和进程的关联，进程也就不再同STDOUT和STDERR联系在一起，为了保存该命令产生的输出，nohup命令会自动将STDOUT和STDERR的消息重定向到一个名为nohup.out文件中，需要注意的是当运行位于同一个目录中的多个命令时所有的输出都会被发送到同一个nohup.out文件中 当使用Ctrl+Z命令将进程停止后，你可以使用kill命令停止该进程，要重启停止的进程需要向其发送一个SIGCONT信号 jobs命令可以查看分配给shell的作业，以及它们的作业号和作业中使用的命令，要想察看作业的PID，可以在jobs命令中加入-l选项，jobs输出中有加号和减号，带加号的作业被当作默认作业，在私用作业控制命令时，如果未在命令行指定任何作业号，该作业会被当成作业控制命令的操作对象，当前的默认作业完成处理后，带减号的作业成为下一个默认作业，任何时候都只有一个带加号的作业和一个带减号的作业，不管shell中有多少个正在运行的作业。 要以后台模式重启一个作业，可用bg命令加上作业号，当然如果该作业是默认作业，只需要使用bg命令就可以将其以后台模式重启；要以前台模式重启作业，可用带作业号的fg命令。 调度优先级是个整数值，从-20（最高优先级）到+19（最低优先级），默认情况下，bash shell以优先级0来启动所有进程。 nice命令允许你设置命令启动时的调度优先级，要让命令以更低的优先级运行，只要用nice的-n命令行来指定新的优先级级别：nice -n 10 ./test.sh &gt; test.out &amp;，可以用这条命令显示进程的谦让度值：ps -p 4973 -o pid,ppid,ni,cmd。当然，nice命令阻止普通系统用户来提高命令的优先级。 nice命令的-n选项并不是必须的，只需要在破折号后面跟上优先级就行了：nice -10 ./test.sh &gt; test.out renice命令可以改变系统上已运行命令的优先级，它允许你指定运行进程的PID来改变它的优先级： 1$ ./test.sh &amp; 123456789[1] 5055$ps -p 5055 -o pid,ppid,ni,cmdPID PPID NI CMD5055 4721 0 /bin/bash ./test.sh$renice -n 10 -p 50555055: old priority 0, new priority 10ps -p 5055 -o pid,ppid,ni,cmdPID PPID NI CMD5055 4721 10 /bin/bash ./test.sh renice命令只能对属于你的进程执行renice，只能通过renice降低进程的优先级，root用户可以通过renice来任意调整进程的优先级。 at命令允许指定Linux系统何时运行脚本，at命令会将作业提交到队列中，指定shell何时运行该脚本，at的守护进程atd会以后台模式运行，检查作业队列来运行作业，大多数Linux发行版本在启动时运行此守护进程。 atd守护进程会检查系统上的一个特殊目录（/var/spool/at）来获取用at命令提交的作业，默认情况下，atd守护进程会每60s检查一下这个目录，有作业时，atd守护进程会检查作业设置运行的时间，如果时间跟当前时间匹配，atd守护进程会运行此作业 at命令的格式如下：at [-f filename] time，默认情况下at命令会将STDIN的输入放到队列中，你可以用-f参数来指定用于读取命令（脚本文件）的文件名，time参数指定了Linux系统何时运行该作业，如果指定的时间已经错过，at命令会在第二天的那个时间运行指定的作业。 at命令能识别多种不同的时间格式： 标准的小时和分钟格式： 10:15 AM/PM指示符：10:15 PM 特定可命名时间，比如now、noon、midnight、teatime（4PM） 除了指定运行作业的时间，也可以通过不同的日期格式指定特定的日期： 标准日期格式：MMDDYY、MM/DD/YY、DD.MM.YY 文本日期：Jul 4、Dec 25，加不加年份均可 你也可以指定时间增量： 当前时间+25min 明天10:15 PM 10:15+7天 在使用at命令时，该作业会被提交到作业队列，针对不同优先级，存在26种不同的作业队列，通过用小写字母a~z和大写字母A~Z来指代，作业队列的字母排序越高，作业运行的优先级越低（更高的nice值），默认情况下，at的作业会被提交到a作业队列，如果想以更高优先级运行作业，可以用-q参数指定不同的队列字母。 at命令指定的作业在运行时，显示器并不会关联到该作业，Linux系统会将提交该作业的用户的电子邮件地址作业STDOUT和STDERR，任何法道STDOUT和STDERR的输出会通过邮件系统发送给该用户。 at命令会显示分配给作业的作业号以及为作业安排的运行时间。 在使用at命令时，最好在脚本中对STDOUT和STDERR进行重定向。 atq命令可以列出系统中有哪些作业在等待，作业列表中列出了作业号、系统运行该作业的日期和时间以及所在的作业队列 一旦知道了哪些作业在作业队列中等待，就能用atrm命令来删除等待中的作业，指明想要删除的作业号即可 Linux使用cron程序来安排要定期指定的作业，cron程序会在后台运行并检查一个特殊的表（称为cron时间表），以获知已安排执行的作业。 cron时间表采用一种特别的格式来指定作业何时运行：min hour dayofmonth month dayofweek command，cron时间表允许你用特定值、取值范围或者通配符来指定条目，例如想在每天的10:15运行一个命令： 15 10 * command cron程序会用提交作业的用户账户运行该脚本，因此你必须有访问该命令和命令中指定的输出文件的权限 可以使用crontab命令来处理cron时间表，要列出已有的cron时间表，可以用-l选项，默认情况下，用户的cron时间表文件不存在，要为cron时间表添加条目，可以用-e选项，在添加条目时crontab命令会启用一个文本编辑器。 如果你创建的脚本对精确的执行时间要求不高，用预配置的cron脚本目录会更方便，有4个基本目录：hourly、daily、monthly、weekly： 12345678$ ls /etc/cron.*ly/etc/cron.daily: cups makewhatis.cron prelink tmpwatch/etc/cron.hourly:0anacron/etc/cron.monthly:readahead-monthly.cron/etc/cron.weekly: 因此，如果脚本需要每天运行一次，只要将脚本复制到daily目录，cron就会每天执行它","tags":[{"name":"Linux, Shell","slug":"Linux-Shell","permalink":"https://glemontree.github.io/tags/Linux-Shell/"}]},{"title":"[Linux] Shell编程第十二课","date":"2017-12-03T11:54:12.000Z","path":"2017/12/03/[Linux] Shell编程第十二课/","text":"每个进程一次最多可以有9个文件描述符 重定向错误：STDERR文件描述符被设为2，可以选择只重定向错误消息，将该文件描述符放在重定向符号前，该值必须紧紧地放在重定向符号前，否则不会工作： 1ls -al badfile 2&gt; test4 12$cat test4ls: cannot access badfile: No such file or directory 如果想重定向错误和正常输出，必须用两个重定向符号，需要在符号前面放上待重定向数据所对应的文件描述符，然后指向用于保存数据的输出文件： 1ls -al test test2 test3 badtest 2&gt; test6 1&gt; test7 也可以将STDERR和STDOUT的输出重定向到同一个输出文件中，可以使用特殊的重定向符号&amp;&gt; 1ls -al test test2 test3 badtest &amp;&gt; test7 如果有意在脚本中生成错误消息，可以将单独的一行输出重定向到STDERR，你需要做的就是使用输出重定向符来将输出消息重定向到STDERR文件描述符，在重定向到文件描述符时，必须在文件描述符数字之前加一个&amp;： 1echo &quot;This is an error message&quot; &gt;&amp;2 这样会在脚本的STDERR文件描述符所指向的位置显示文本，而不是通常的STDOUT： 123#!/bin/bashecho &quot;This is an error&quot; &gt;&amp;2echo &quot;This is normal output&quot; 123$ ./test.shThis is an errorThis is normal output 默认情况下，Linux会将STDERR导向STDOUT，但是如果你在运行脚本时重定向了STDERR，脚本中所有导向STDERR的文本都会被重定向： 1$ ./test.sh 2&gt; test9 此时错误信息就会被重定向到test9文件中，而正常信息还是会显示在显示器上 如果脚本中有大量数据需要重定向，那重定向每个echo语句就会很繁琐，你可以用exec命令告诉shell脚本执行期间重定向某个特定文件描述符： 1234#!/bin/bashexec 1&gt;testoutecho &quot;This is a test of redirecting all output&quot;echo &quot;from a script to another file&quot; 1$./test.sh exec命令会启动一个新的shell并将STDOUT文件描述符重定向到文件，脚本中发给STDOUT的所有输出会被重定向到文件 1234567#!/bin/bashexec 2&gt;testerrorecho &quot;This is the start of the script&quot;echo &quot;now redirecting all output to another location&quot;exec 1&gt;testoutecho &quot;This output should go to the testout file&quot; echo &quot;but this should go to the testerror file&quot; &gt;&amp;2 1234567$ ./test.shThis is the start of the scriptnow redirecting all output to another location$ cat testoutThis output should go to the testout file$ cat testerrorbut this should go to the testerror file 可以将STDIN从键盘重定向到其他位置，exec命令允许你将STDIN重定向到Linux系统上的文件中： 1exec 0&lt; testfile 这个命令会告诉shell从文件中获取输入而不是STDIN： 12345678#!/bin/bashecho 0&lt; testfilecount=1while read linedo echo &quot;Line #count: line&quot; count=[ count + 1 ]done 1$ ./test.sh 一个进程最多可以使用9个文件描述符，除了0、1、2外另外6个都可以在shell脚本中使用，用作输入和输出重定向： 12345#!/bin/bashexec 3&gt;testoutecho &quot;This should display on the monitor&quot;echo &quot;and this should be stored in the file&quot; &gt;&amp;3echo &quot;Then this should be back on the monitor&quot; 12345$ ./testThis should display on the monitorThen this should be back on the monitor$ cat testoutand this should be stored in the file 恢复重定向的文件描述符： 1234567#!/bin/bashexec 3&gt;&amp;1exec 1&gt;testoutecho &quot;This should store in the output file&quot;echo &quot;along with this line&quot;echo 1&gt;&amp;3echo &quot;Now things should be back to normal&quot; 12345$ ./test.shNow things should be back to normal $ cat testoutThis should store in the output filealong with this line 上面这段代码中首先将文件描述符3重定向到文件描述符1的当前位置，也就是STDOUT，这意味着任何发送给文件描述符3的输出都将显示在显示器上。 第二个exec命令将STDOUT重定向到文件，shell现在将发送给STDOUT的输出直接重定向到输出文件中，但是文件描述符3仍然会指向STDOUT原来的位置，也就是显示器，如果此时将输出数据发送到文件描述符3，它仍然会显示在显示器上，尽管STDOUT已经被重定向了。 在向STDOUT（现在指向一个文件）发送一些输出后，脚本将STDOUT重定向到文件描述符3的当前位置（现在仍然是显示器），这意味着现在STDOUT又指向了它原来的位置：显示器。 创建读写文件描述符，可以用一个文件描述符对同一个文件进行读写，对同一个文件进行读写，shell会维护一个内部指针， 指明在文件中的当前位置，任何读写都会从文件指针上次的位置开始： 12345#!/bin/bashexec 3&lt;&gt;testfileread line &lt;&amp;3echo &quot;Read: $line&quot;echo &quot;This is a test line&quot; &gt;&amp;3 12345678910$ cat testfileThis is the first line.This is the second line.This is the third line.$ ./test.shcat testfileThis is the first line.This is a test line ine.This is the third line. 当脚本向文件中写入数据时，它会从文件指针所处的位置开始，read命令读取了第一行数据，所以它使得文件指针指向了第二行数据的第一个字符，在echo语句将数据输出到文件时，它会将数据放到文件指针的当前位置，覆盖了该位置的已有数据。 关闭文件描述符：要关闭文件描述符，将它重定向到特殊符号&amp;-： 1exec 3&gt;&amp;- 列出打开的文件描述符： lsof命令会列出整个Linux系统打开的所有文件描述符，lsof命令位于/usr/sbin命令，要想以普通用户账户来运行它，必须通过全路径来引用:/usr/sbin/lsof。 lsof有几个常用的命令行选项，-p选项允许指定进程ID（PID），-d选项允许指定要显示的文件描述符编号，要想知道进程的当前PID，可以用特殊环境变量$$（shell会将它设为当前PID），-a选项用来对其他两个选项的结果进行AND运算 阻止命令输出： 通过将STDERR重定向到null文件中将全部消息删除，shell输出到null文件的任何数据都不会保存，更不会显示： 12ls -al &gt; /dev/nullls -al badfile test16 2&gt; /dev/null 也可以在输入重定向中将/dev/null作为输入文件，由于/dev/null中不含有任何内容，因此通常可以用它来快速清除现有文件中的数据，而不用先删除文件再重新创建，这是清除日志文件的一个常用方法。 大多数Linux发行版配置了在启动时自动删除/tmp目录的所有文件，mktemp命令可以在/tmp目录中创建一个唯一的临时文件，shell会创建这个文件，但不用默认的umask值，它会将文件的读和写权限分配给文件的属主，并将你设为文件的属主，一旦创建了文件，你就在脚本中有了完整的读写权限，但其他人无法访问（root用户除外） 默认情况下，mktemp命令会在本地目录中创建一个文件，要用mktemp命令在本地目录中创建一个临时文件，你只要指定一个文件名模板就醒了，模板可以包含任意文本文件名，在文件名末尾加上6个X就行了： 1$ mktemp testing.XXXXXX mktmp命令会用6个字符码替换这6个X，从而保证文件名在目录中是唯一的，你可以创建多个临时文件，他可以保证每个文件是唯一的： 1234567891011#!/bin/bashtempfile=$(mktemp test.XXXXXX)exec 3&gt;$tempecho &quot;This script writes to temp file $tempfile&quot;echo &quot;This is the first line&quot; &gt;&amp;3echo &quot;This is the second line&quot; &gt;&amp;3echo &quot;This is the last line&quot; &gt;&amp;3exec 3&gt;&amp;-echo &quot;Done creating temp file. The contents are:&quot;cat $tempfilerm -f $tempfile 2&gt; /dev/null 123456$ ./testThis script writes to temp file test19.vCHoyaDone creating temp file. The contents are:This is the first lineThis is the second line.This is the last line. -t选项会强制mktemp命令在系统的临时目录创建该文件，此时mktemp命令会返回用来创建临时文件的全路径，而不是只有文件名 -d选项会使得mktemp命令来创建一个临时目录而不是临时文件： 12345678910#!/bin/bashtempdir=$(mktemp -d dir.XXXXXX)cd $tempdirtempfile1=$(mktemp temp.XXXXXX)tempfile2=$(mktemp temp.XXXXXX)exec 7&gt; $tempfile1exec 8&gt; $tempfile2echo &quot;Sending data to directory $tempdir&quot;echo &quot;This is a test line of data for $tempfile1&quot; &gt;&amp;7echo &quot;This is a test line of data for $tempfile2&quot; &gt;&amp;8 tee命令相当于管道的一个T型接头，它将从STDIN过来的数据同时发往两处，一处是STDOUT，另一处是tee命令行所指定的文件名： 1tee filename 1$ date | tee testfile 默认情况下，tee命令会在每次使用时覆盖输出文件内容，如果想将数据追加到文件中，必须使用-a选项： 1$ date | tee -a testfile 举例：读取csv格式的数据文件，输出SQL INSERT语句来将数据插入数据库： 12345678910#!/bin/bashoutfile=members.sqlIFS=,while read lname fname address city state zipdo cat &gt;&gt; $outfile &lt;&lt; EOF INSERT INTO members (lname, fname, address, city, state, zip) VALUES (&apos;lname&apos;, &apos;fname&apos;, &apos;address&apos;, &apos;city&apos;, &apos;state&apos;, &apos;zip&apos;); EOFdone &lt; $&#123;1&#125; 脚本中使用了3处重定向，while循环使用read语句来从数据文件中读取文本，这是通过在done语句中出现的重定向符号来实现的，命令行的第一个参数即members.csv文件会作为待读取数据的文件。脚本中另外两处重定向操作出现在同一条语句中： 1cat &gt;&gt; $outfile &lt;&lt; EOF 这条语句中包含一个输出追加重定向和一个输入追加重定向，输出重定向将cat命令的输出追加到$outfile变量指定的文件中，cat命令的输入不再取自标准输入，而是被重定向到脚本中存储的数据，EOF符号标记了追加到文件中的数据的起止（内联输入重定向）。","tags":[{"name":"Linux, Shell","slug":"Linux-Shell","permalink":"https://glemontree.github.io/tags/Linux-Shell/"}]},{"title":"[Linux] Shell编程第十课","date":"2017-12-03T11:50:53.000Z","path":"2017/12/03/[Linux] Shell编程第十课/","text":"bash中for命令的基本格式如下： 1234for var in listdo commandsdone 例如： 123456#!/bin/bash# basic for commandfor test in Alabama Alaska Arizona Arkansas California Coloradodo echo The next state is $testdone 1234567$ ./test1The next state is AlabamaThe next state is AlaskaThe next state is ArizonaThe next state is ArkansasThe next state is CaliforniaThe next state is Colorado 在最后一次迭代后，$test变量的值会在shell脚本的剩余部分一直保持有效，它会一直保持最后一次迭代的值 当list列表中含有单引号时，可以使用下面两种方法中的其中一种： 使用转义字符（反斜线）来将单引号转义 使用双引号来定义用到单引号的值 for循环假定每个值是用空格进行分隔的，此时如果单独的数据中含有空格，就必须用双引号将这些值圈起来 从变量读取列表，例如： 123456789$ cat test4.sh#!/bin/bash# using a variable to hold the listlist=&quot;Alabama Alaska Arizona Arkansas Colorado&quot; list=$list&quot; Connecticut&quot; for state in $listdo echo &quot;Have you ever visited $state?&quot;done 1234567$ ./test4.shHave you ever visited Alabama?Have you ever visited Alaska?Have you ever visited Arizona?Have you ever visited Arkansas?Have you ever visited Colorado?Have you ever visited Connecticut? 注意第五行的向变量中存储的已有文本字符串尾部添加文本的一个常用方法 生成列表中所需值的另外一种方法是使用命令的输出，可以用命令替换来执行任何能产生输出的命令： 123456#!/bin/bashfile=&quot;states&quot;for state in $(cat file)do echo &quot;Visit beautiful $state&quot;done 123456789$ ./test5Visit beautiful AlabamaVisit beautiful AlaskaVisit beautiful ArizonaVisit beautiful ArkansasVisit beautiful ColoradoVisit beautiful ConnecticutVisit beautiful DelawareVisit beautiful Florida 上面的这个例子中将各个地名放在了单独的一行，for命令会以每次一行的方式遍历cat命令的输出，但这并没有解决数据中有空格的问题，如果你列出的一行中有空格，for命令仍然会将每个单词当作单独的值。 造成这个问题的根本原因是特殊的环境变量IFS，叫做内部字段分隔符（internal field separator），IFS环境变量定义了bash shell用作字段分隔符的一系列字符，默认情况下，bash shell会将下面的字符当作字段分隔符： 空格 制表符 换行符 如果bash shell在数据中看到了这些字符中的任意一个，他就会假定这表明了列表中一个新数据字段的开始。当然你可以修改IFS的值，例如你可以在shell脚本中临时更改IFS环境变量的值：IFS=$&#39;\\n&#39;，这样就只能识别换行符 在处理代码量较大的脚本时，可能需要在一个地方修改IFS的值，然后忽略这次修改，在脚本的其他地方继续沿用IFS的默认值，可以这样实现： 1234IFS.OLD=$IFSIFS=$&apos;\\n&apos;&lt;在代码中使用新的IFS值&gt;IFS=$IFS.OLD 如果要指定多个IFS字符，只要将它们在赋值行串联起来即可： 1IFS=$&apos;\\n&apos;:;&quot; 这个赋值会将换行符、冒号、分号和双引号作为字段分隔符 用通配符读取目录 1234567891011#!/bin/bashfor file in /home/rich/test/*do if [ -d &quot;$file&quot; ] then echo &quot;$file is a directory&quot; elif [ -f &quot;$file&quot; ] then echo &quot;$file is a file&quot; fidone 该代码用test命令测试了每个条目（使用方括号方法），以查看它的目录（通过-d参数）还是文件（通过-f参数）。需要注意的是，在Linux中目录名和文件名是可以包含空格的，所以需要将$file使用双引号圈起来，否则会出错，在test命令中，bash shell会将额外的单词当作参数，进而造成错误。 bash中C语言风格的循环语句：for ((variable assignment; condition; iteration process))，例如：for (( a = 1; a &lt; 10; a++ ))，有以下几点需要注意： 变量赋值可以有空格 条件中的变量不以美元符开头 迭代过程中的算式未用expr命令格式 while命令的基本格式如下： 123while test commanddodone 最常见的test command的用法是用方括号来检查循环命令中用到的shell变量的值： 1234567#!/bin/bashvar1=10;while [ $var1 -gt 10 ] do echo $var1 var1=$[$var1 - 1]done while命令允许你在while语句定义多个测试命令，只有最后一个测试命令的退出状态码会被用来决定什么时候结束循环。 循环处理文件数据，通常必须遍历存储在文本中的数据，这需要使用到两种技术： 使用嵌套循环 修改IFS环境变量 通过修改IFS环境变量，就能强制for命令将文件中的每一行都当作单独的一个条目来进行处理，即使数据中有空格也是如此，一旦从文件中提取出了单独的行，可能需要再次利用循环来提取行中的数据。典型的例子就是处理/etc/passwd文件中的数据，首先需要遍历/etc/passwd文件，并将IFS变量的值改成冒号： 123456789101112#!/bin/bashIFS.OLD=$IFSIFS=$&apos;\\n&apos;for entry in $(cat /etc/passwd)do echo &quot;Values in $entry -&quot; IFS=: for value in $entry do echo &quot; $value&quot; donedone 熟悉C语言的都知道break命令可以用于退出当前的循环，有时你在内部循环，但需要停止外部循环，break命令可以接受单个命令行参数值：break n，其中n指定了要跳出的循环层级，默认情况下n为1，表明跳出的是当前循环，如果将n设为2，break命令会停止下一级的外部循环。 注意：for循环的循环条件((xxx;xxx;xxx))表达式和括号之前的空格是可有可无的，但是对于if命令的test条件判断（[]）方括号和表达式之间必须有空格 在shell脚本中，可以对循环的输出使用管道或进行重定向，这可以在done命令之后添加一个处理命令来实现： 12345678910#!/bin/bashfor file in /home/gtp/*do if [ -d &quot;$file&quot; ] then echo &quot;$file is a directory&quot; elif echo &quot;$file is a file&quot; fidone &gt; output.txt shell会将for命令的输出重定向到文件output.txt中，而不是在屏幕上。当然这种方法同样适用于将循环的结果管接到另一个命令，此时需要使用 | 符号，而不是 &gt; 符号 查找可执行文件： 12345678910111213#!/bin/bashIFS=:for folder in $PATHdo echo &quot;$folder:&quot; for file in $folder/* do if [ -x $file ] then echo &quot; $file&quot; fi donedone 创建多个用户帐户： 不用为每个需要创建的新用户账户手动输入useradd命令， 而是可以将需要添加的新用户账户放在一个文件中，然后创建一个脚本来实现，这个文本文件的格式如下：userid,user name，两个值之间用,分隔，这样就形成了一种名为逗号分隔符的文件格式（或者是.csv），这种文件格式在电子表格中极其常见，所以你可以轻松的在电子表格程序中创建用户账户列表，然后将其保存成.csv格式，以备shell脚本读取并处理。 要读取文件中的数据，首先将IFS分隔符设置为逗号，并将其放入while语句的条件测试部分，然后使用read命令读取文件中的各行： 1while IFS=&apos;,&apos; read -r userid name read命令会自动读取.csv文本文件中的下一行内容，当read命令返回false时，即文件读取完毕，循环结束。 要想把数据从文件中送入while命令， 只需在while命令尾部使用一个重定向就可以了： 1234567#!/bin/bashinput=&quot;users.csv&quot;while IFS=&apos;,&apos; read -r userid namedo echo &quot;adding $userid&quot; useradd -c &quot;$name&quot; -m $useriddone &lt; &quot;$input&quot; ​","tags":[{"name":"Linux, Shell","slug":"Linux-Shell","permalink":"https://glemontree.github.io/tags/Linux-Shell/"}]},{"title":"[Linux] Shell编程第九课","date":"2017-12-03T11:48:07.000Z","path":"2017/12/03/[Linux] Shell编程第九课/","text":"sed编辑器可以根据命令来处理数据流中的数据，这些命令要么从命令行中输入，要么存储在一个命令文本文件中，sed编辑器会执行下列操作： 一次从输入中读取一行数据 根据所提供的编辑器命令匹配数据 按照命令修改流中的数据 将新的数据输出到STDOUT 在流编辑器将所有命令与一行数据匹配完毕后，它会读取下一行数据并重复这个过程，当处理完所有数据后，它就会终止，sed命令的格式如下：sed options script file 选项允许你修改sed命令的行为： -e script 在处理输入时，将script中指定的命令添加到已有的命令中 -f file 在处理输入时，将file中指定的命令添加到已有的命令中 -n 不产生命令输出，使用print命令来完成输出 script参数指定了应用于数据流上的单个命令，如果需要多个命令，要么使用-e选项在命令行中指定，要么使用-f选项在单独的文件中指定。 默认情况下，sed编辑器会将指定的命令应用到STDIN数据流上，可以直接将数据通过管道输入sed编辑器处理： echo “This is a test” | sed ‘s/test/big test/‘ This is a big test 这个例子在sed编辑器中使用了s命令，s命令会用斜线间指定的第二个文本字符串来替换第一个文本字符串模式，需要注意的是sed编辑器并不会修改文本文件的数据，它只会将修改后的数据发送到STDOUT中。 要在sed命令行中执行多个命令时，只要用-e选项就可以了： sed -e &#39;s/brown/green/; s/dog/cat/&#39; data1.txt 两个命令都作用到文件中的每一行数据中，命令之间用分号隔开，并且在命令末尾和分号之间不能有空格，如果不想用分号，只要在命令行中输入第一个单引号标示出sed程序脚本的起始，bash会继续提示你输入更多命令，直到输入了标示结束的单引号： 1234sed -e &apos;&gt; s/brown/green/&gt; s/fox/elephant/&gt; s/dog/cat/&apos; data1.txt 可以在sed命令中通过-f选项来指定sed文件： 1sed -f script1.sed data1.txt 替换命令(s)在替换多行中的文本时能正常工作，但默认情况下它只替换每行出现的第一处，要让替换命令能够替换一行中不同地方出现的文本必须使用替换标记，替换标记会在替换字符串之后设置： 1s/pattern/replacement/flags 有4种可用的替换标记： 数字，表明新文本将替换第几处模式匹配的地方 g，表明新文本将会替换所有匹配的文本 p，表明原先行的内容要打印出来 w file， 将替换的结果写入到文件中 p替换标记会打印与替换命令中指定的模式匹配的行，这通常会和sed的-n选项一起使用，-n选项会禁止sed编辑器输出，但p标记会输出修改过的行，将二者配合使用的效果就是只输出被替换命令修改过的行 如果你想用C shell替换/etc/passwd文件中的bash shell，必须这么做： 1sed &apos;s/\\/bin\\/bash/\\/bin\\/csh&apos; /etc/passwd 由于正斜线通过用作字符串分隔符，因而出现在模式文本中的话，必须用反斜线来转义，要解决这个问题，sed编辑器允许选择其他字符来作为替换命令中的字符串分隔符： 1sed &apos;s!/bin/bash!/bin/csh!&apos; /etc/passwd 默认情况下，sed编辑器中使用的命令会作用与文本数据的所有行，如果只想命令作用于特定行或某些行，则必须使用行寻址，在sed编辑器中有两种形式的行寻址： 以数字形式表示行区间 用文本模式来过滤出行 两种形式都使用相同的格式来指定地址： 1[address]command 也可以将特定地址的多个命令分组： 12345address &#123;command1command2command3&#125; sed编辑器会将指定的每条命令作用到匹配指定地址的行上。 数字方式的行寻址 sed编辑器会将文本流中的第一行编号为1，然后继续按顺序为接下来的行分配行号，在命令中指定的地址可以是单个行号，或是用起始行号、逗号、结尾行号指定的一定区间范围的行。 1sed &apos;2s/dog/cat/&apos; data1.txt (sed编辑器只修改地址指定的第二行的文本) 1sed &apos;2,3s/dog/cat/&apos; data1.txt (sed编辑器将修改地址指定的二、三行的文本) 如果想将命令作用到文本中从某行开始的所有行，可以用特殊地址-美元符 1sed &apos;2,$s/dog/cat/&apos; data1.txt 使用文本模式过滤器 sed编辑器允许指定文本模式来过滤出命令要作用的行： 1/pattern/command 必须用正斜线将要指定的pattern封起来，sed编辑器会将该命令作用到指定文本模式的行上： 1sed &apos;/Samantha/s/bash/csh&apos; /etc/password 上面这条命令将会将/etc/password文件中Samantha用户的bash改为csh 如果需要在单行上指定多条命令，可以用花括号将多条命令组合在一起： 1234sed &apos;2&#123;&gt; s/fox/elephant/&gt; s/dog/cat/&#125;&apos; data1.txt 删除命令d会删除匹配指定寻址模式的所有行，当和指定地址一起使用时，可以从数据流中删除特定的文本行，例如： 1sed &apos;3d&apos; data.txt 也可以使用两个文本模式来删除某个区间内的行，你指定的第一个模式会打开行删除功能，第二个模式会关闭行删除功能，sed编辑器会删除两个指定行之间的所有行： 1sed &apos;/1/,/3/d&apos; data.txt 指定完上面的命令后，文本文件中出现1和3之间的行以及它们之间的行都会被删除，需要注意的是只要在sed编辑器在数据流中匹配了开始模式，删除功能就会打开，这可能会导致意外。 12345678910$ cat data7.txtThis is line number 1.This is line number 2.This is line number 3.This is line number 4.This is line number 1 again.This is text you want to keep.This is the last line in the file.$ sed &apos;/1/,/3/d&apos; data7.txtThis is line number 4 第二个出现数字”1”的行再次触发了删除命令，因为没有找到停止模式，所以就将数据流中的剩余行全部删除。 插入和附加文本 插入命令(i): 在指定行前增加一个新行 附加命令(a): 在指定行后增加一个新行 格式如下： 1sed &apos;[address]command\\new line&apos; new line中的文本将会出现在sed编辑器输出中你指定的位置，例如： 1echo &quot;Test line 2&quot; | sed &apos;i\\Test line 1&apos; 运行结果如下： 12Test line 1Test line 2 下面是一个将一个新行插入到数据流第三行前： 1sed &apos;3i\\This is an inserted line.&apos; data.txt 如果你有一个多行数据流，想要将新行附加到数据流的末尾，只要用代表数据最后一行的美元符就可以了： 1sed &apos;$a\\This is a new line of text.&apos; data.txt 要插入或附加多行文本，就必须对要插入或附加的文本中的每一行使用反斜线，直到最后一行： 123sed &apos;1i\\&gt; This is one line of new text.\\&gt; This is another line of new text.&apos; data.txt 修改行 1sed &apos;3c\\This is a changed line of text.&apos; data.txt 当然也可以用文本模式来寻址： 1sed &apos;/number 3/c\\This is a changed line of text.&apos; data.txt 你也可以在修改命令中使用地址区间： 1sed &apos;2,3c\\This is a new line of text.&apos;data.txt sed编辑器会用这一行文本来替换数据流中的两行文本，而不是逐一修改这两行文本。 转换命令： 转换命令(y)是唯一一个可以处理单个字符的sed编辑器命令，格式如下： 1[address]y/inchars/outchars/ 转换命令会对inchars和outchars进行一对一的映射，inchars中的第一个字符会被转换为outchars中的第一个字符，第二个字符会被转换成outchars中的第二个字符，如果两者长度不同会报错。 1sed &apos;y/123/789/&apos; data.txt 转换命令是一个全局命令，也就是说它会文本行中找到的所有指定字符自动进行转换，而不会考虑它们出现的位置： 12echo &quot;This 1 is a test of 1 try.&quot; | sed &apos;y/123/456&apos;This 4 is a test of 4 try. 跟替换命令中的p标记类似，p命令可以打印sed编辑器输出中的一行： 1$ echo &quot;this is a test&quot; | sed &apos;p&apos; 输出结果如下： 12this is a testthis is a test 它所做的就是打印已有的数据文本，打印命令最常见的用法就是打印包含匹配文本模式的行： 123456789$ cat data6.txtThis is line number 1.This is line number 2.This is line number 3.This is line number 4.$$ sed -n &apos;/number 3/p&apos; data6.txtThis is line number 3.$ 在命令行上用-n选项，你可以禁止输出其他行，只打印包含匹配文本模式的行。 如果需要在修改之前查看行： 1234sed -n &apos;/3/&#123;&gt; p&gt; s/line/test/p&gt; &#125;&apos; data.txt 输出结果如下： 12This is line number 3.This is test number 3. sed编辑器命令会查找包含数字3的行,然后执行两条命令。首先,脚本用p命令来打印出原始行;然后它用s命令替换文本,并用p标记打印出替换结果。输出同时显示了原来的行文本和新的行文本。 等号命令会打印行在数据流中的当前行号，每次数据流中出现一个换行符，sed编辑器就会认为一行文本结束了。 如果你要在数据流中查找特定文本模式的话： 1234sed -n &apos;/number 4/&#123;&gt; =&gt; p&gt; &#125;&apos; data.txt 输出结果如下： 124This is line number 4 利用-n选项，就能让sed编辑器只显示包含匹配文本模式的行的行号和文本。 列出行 列出命令(l)可以打印数据流中的文本和不可打印的ASCII字符，任何不可打印的字符要么在其八进制前加一个反斜线，要么使用标准C风格的命名法，比如\\t： 123456$ cat data9.txtThis line contains tabs.$$ sed -n &apos;l&apos; data9.txtThis\\tline\\tcontains\\ttabs.$$ 行尾的美元符表示换行符 写入文件 w命令用来向文件写入行： 1[address]w filename filename可以使用相对路径或绝对路径，但不管是哪种，运行sed编辑器的用户必须有文件的写权限： 1sed &apos;1,2w test.txt&apos; data.txt 执行上面的命令后会将data.txt文件中一二行写入到test.txt中 读取文件 读取命令(r)允许你将一个独立文件的数据插入到数据流中： 1[address]r filename 123456789101112$ cat data12.txtThis is an added line.This is the second added line.$$ sed &apos;3r data12.txt&apos; data6.txtThis is line number 1.This is line number 2.This is line number 3.This is an added line.This is the second added line.This is line number 4.$ 同样的方法在使用文本模式地址时也适用。 12345678$ sed &apos;/number 2/r data12.txt&apos; data6.txtThis is line number 1.This is line number 2.This is an added line.This is the second added line.This is line number 3.This is line number 4.$ 如果你要在数据流的末尾添加文本,只需用美元符地址符就行了。 12345678sed &apos;$r data12.txt&apos; data6.txtThis is line number 1.This is line number 2.This is line number 3.This is line number 4.This is an added line.This is the second added line.$","tags":[{"name":"Linux, Shell","slug":"Linux-Shell","permalink":"https://glemontree.github.io/tags/Linux-Shell/"}]},{"title":"[Linux] Shell编程第八课","date":"2017-12-03T11:47:18.000Z","path":"2017/12/03/[Linux] Shell编程第八课/","text":"if-then语句，其格式如下： 1234if commandthen commandsfi bash shell的if语句会运行if后面的那个命令，如果该命令的退出状态码是0（该命令成功运行），位于then部分的命令就会被执行，如果该命令的退出状态码是其他值，then部分的命令就不会执行，bash shell会继续执行脚本中的下一个命令，fi语句表示if-then语句到此结束。举个例子如下： 12345#!/bin/bashif pwd thenecho &quot;It worked&quot;fi 在if-then语句的then部分，可以使用不止一条命令，bash shell会把这些命令当成一个块，如果if语句的命令的退出状态码是0，所有的命令都会被执行，如果if语句的命令的退出状态不为0，所有的命令都会被跳过。 if-then-else语句，其格式如下： 123456if commandthen commandselse commandsfi 当if语句的命令中返回的退出状态码是0，then部分的命令会被执行，当if语句中的命令返回非0退出状态码时，bash shell会执行else部分的命令 test命令提供了在if-then语句中测试不同条件的途径，如果test命令中列出的条件成立，test命令就会退出并返回状态码0，如果条件不成立，test命令就会退出并返回非零的退出状态码，test命令的格式如下：test condition，结合if-then语句如下： 1234if test conditionthen commandsfi 如果不写test命令的condition部分，它会以非零的退出状态码退出，并执行else语句块： 1234567#!/bin/bashif testthen echo &quot;NO expression returns a True&quot;else echo &quot;No expression returns a False&quot;fi bash shell提供了另一种条件测试方法，无需在if-then语句中声明test命令： 1234if [ condition ]then commandsfi 方括号定义了测试条件，需要注意的是第一个方括号之后和第二个方括号之前必须加上一个空格，否则就会报错。 test命令可以判断三类条件： 数值比较 字符串比较 文件比较 数值比较 使用test命令最常见的情形就是对两个数值进行比较，下面列出了测试两个值时可用的条件参数： n1 -eq n2 检查n1是否与n2相等 n1 -ge n2 检查n1是否大于或等于n2 n1 -gt n2 检查n1是否大于n2 n1 -le n2 检查n1是否小于或等于n2 n1 -lt n2 检查n1是否小于n2 n1 -ne n2 检查n1是否不等于n2 数值条件测试可以用于数字和变量上 字符串比较 str1 = str2 检查str1和str2是否相同 str1 != str2 检查str1和str2是否不同 str1 &lt; str2 检查str1是否比str2小 str1 &gt; str2 检查str1是否比str2大 n str1 检查str1的长度是否非0 z str1 检查str1的长度是否为0 字符串顺序：当要开始使用测试条件的大于或小于功能时，常常会出现下面两个问题： 大于号和小于号必须转义，否则shell会把它们当作重定向符号，把字符串值当作文件名 大于和小于顺序和sort命令所采用的不同 123456789#!/bin/bashvar1=baseballvar2=hockeyif [ var1 &gt; var2 ]then echo &quot;$var1 is greater than $var2&quot;else echo &quot;$var1 is less than $var2&quot;fi 在上面这段代码中，脚本把大于号解释成了输出重定向，因此，创建了一个hockey的文件，由于重定向的顺利完成，test命令返回了退出状态码0，要解决这个问题，就需要使用转义大于号： 123456789#!/bin/bashvar1=baseballvar2=hockeyif [ var1 \\&gt; var2 ]then echo &quot;$var1 is greater than $var2&quot;else echo &quot;$var1 is less than $var2&quot;fi 看另外一种情况： 123456789#!/bin/bashvar1=Testingvar2=testingif [ var1 &gt; var2 ]then echo &quot;$var1 is greater than $var2&quot;else echo &quot;$var1 is less than $var2&quot;fi 这个的结果输出是Testing is less than testing，这是为什么呢，这是因为在比较测试时，大写字母会被认为是小于小写字母的，但sort命令恰好相反。比较测试中使用的是标准的ASCII顺序，根据每个字符的ASCII数值来决定排序结果，sort命令使用的是系统的本地化语言设置中定义的排序顺序，对于英语，本地化设置指定了在排序顺序中小写字母出现在大写字母前。 文件比较 允许你测试Linux文件系统上文件和目录的状态： -d file 检查file是否存在并是一个目录 -e file 检查file是否存在 -f file 检查file是否存在并是一个文件爱你 -r file 检查file是否存在并可读 -s file 检查file是否存在并非空 -w file 检查file是否存在并可写 x file 检查file是否存在并可执行 O file 检查file是否存在并属当前用户所有 G file 检查file是否存在并且默认组与当前用户相同 file1 -nt file2 检查file1是否比file2新 file1 -ot file2 检查file1是否比file2旧 双括号命令允许在比较过程中使用高级数学表达式，双括号命令的格式如下：((expression))，expression可以是任意的数学赋值或比较表达式，双括号中表达式的大于号不需要进行转义： 1234567#!/bin/bashvar1=10;if (($var1 **2 &gt; 90))then ((var2 = $var1 ** 2)) echo &quot;The square of var1 is var2&quot;fi 双方括号命令提供了指针字符串比较的高级特性，其格式如下：[[ expression ]]，双方括号里的expression使用了test命令中的采用的标准字符串比较，但它提供了另一个特性-模式匹配，例如： 1234567#!/bin/bashif [[ $USER == r* ]]then echo &quot;Hello $USER&quot;else echo &quot;Sorry, I do not know you&quot;fi case命令： 12345case variable inpattern1 | pattern2) commands1;;pattern3) commands2;;*) default commands;;esac 举个例子： 123456789101112#!/bin/bashcase $USER inrich | vmuser) echo &quot;Welcome, $USER&quot; echo &quot;Please enjoy your visit&quot;;;testing) echo &quot;Special testing account&quot;;;jessica) echo &quot;Do not forget to log off when you&apos;re done&quot;;;*) echo &quot;Sorry, yuo are not allowed here&quot;;;esac ​","tags":[{"name":"Linux, Shell","slug":"Linux-Shell","permalink":"https://glemontree.github.io/tags/Linux-Shell/"}]},{"title":"[Linux] Shell编程第七课","date":"2017-12-03T11:45:42.000Z","path":"2017/12/03/[Linux] Shell编程第七课/","text":"在创建shell脚本文件时必须在文件的第一行指定要使用的shell，其格式为：#!/bin/bash， 在通常的shell脚本中，井号（#）用作注释行，shell脚本不会处理shell脚本中的注释行，但是第一行是个例外，后面的！号会告诉shell用哪个shell来运行脚本。 为了运行shell脚本，有两种方法： 将shell脚本文件所处的目录添加到PATH环境变量中 在提示符中用绝对路径或相对文件路径来引用shell脚本文件 需要的是当创建一个shell脚本文件后，默认的shell脚本文件没有可执行的权限，可以通过chmod命令来为shell添加可执行的权限，例如：chmod u+x test1 在shell脚本文件中，如果想把文本字符串和命令输出显示在同一行中，可以使用echo语句的-n参数，例如： 12echo -n &quot;The time and date are: &quot;date 这样文本字符串和命令输出就会显示在同一行，需要注意的是此时字符串的两侧需要使用引号 在Shell脚本中，可以在环境变量前面加上$符号来使用环境变量：$UID $HOME shell脚本中的用户变量是区分大小写的，所以Var1 和 var1是不同的 使用等号将值赋给用户变量，在变量、等号和值之间不能出现空格，例如：var1=10，shell脚本会自动决定变量值的数据类型，在脚本的整个生命周期中shell脚本中定义的变量会一直保持着它们的值，但在shell脚本结束时会被删除掉，与系统变量类似，用户变量可通过$符号引用。 有两种方法可以将命令输出赋给变量： 反引号字符（`） $()格式 命令替换允许你将shell命令的输出赋给变量，例如:testing=$(date)，那么变量testing将获得date命令的输出。 举个例子，在脚本中通过命令替换获得当前日期并用它来生成唯一文件名： 123#!/bin/bashtoday=$(date +%y%m%d)ls /usr/bin -al &gt; log.$today 命令替换会创建出一个子shell来运行对应的命令，子shell是由运行该脚本的shell所创建出来的一个独立的子shell，正因为如此子shell所执行命令是无法使用脚本中所创建的变量的。在命令提示符下使用路径./运行命令的话也会创建出子shell，要是运行命令的时候不加入路径，就不会创建子shell，如果你使用的是内建的shell命令，并不会涉及子shell。 bash shell用大于号完成将命令的输出发送到一个文件中，例如command &gt; outputfile，如果希望不覆盖文件原有内容，而是将命令的输出追加到已有文件中，可以使用&gt;&gt;来追加数据 输入重定向将文件的内容重定向到命令，使用&lt;来实现: command &lt; inputfile，例如：wc &lt; test表示将test文件中的数据输入到wc中，wc命令可以对数据中的文本进行计数，默认情况下会输出3个值： 文本的行数 文本的词数 文本的字节数 内联输入重定向无需使用文件进行重定向，只需要在命令行中指定用于输入重定向的数据即可，内联输入重定向符号是&lt;&lt;，除了这个符号，必须指定一个文本标记来划分输入数据的开始和结尾，任何字符串都可作为文本标记，但在数据的开始和结尾文本标记必须一致： 123command &lt;&lt; markerdatamarker 举个例子： 12345wc &lt;&lt; EOFtest string 1test string 2test string 3EOF 在bash中，在将一个数学运算结果赋给某个变量时，可以用美元符和方括号($[ operation ])将数学表达式围起来，例如： 123456#!/bin/bashvar1=100var2=50var3=45var4=[var1 * (var2 - var3)]echo $var4 bash shell数学运算符只支持整数运算，若要进行浮点数运算，可以考虑zshell bc命令可以进入bash计算器，要退出bash计算器，必须输入quit。浮点运算是由内建变量scale控制的，必须将这个值设置为你希望在计算结果中保留的小数位数，否则无法得到期望的结果。bc -q指令可以不显示bash计算器冗长的欢迎信息。 在脚本中可以这样使用bash计算器，需要使用命令替换运行bc命令，并将输出赋给给一个变量variable=$(echo &quot;options; expression&quot; | bc)，第一部分options允许你设置变量，如果需要设置不止一个变量，可以用分号将其分开，expression参数定义了通过bc执行的数学表达式： 123#!/bin/bashvar1=$(&quot;scale=4; 3.44 / 5&quot; | bc)echo The answer is $var1 另外一种使用方法是使用内联输入重定向： 123456variable=$(bc &lt;&lt; EOFoptionsstatementexpressionsEOF) 举个例子： 123456789101112!#/bin/bashvar1=10.46var2=43.67var3=33.2var4=71var5=$(bc &lt;&lt; EOFscale = 4a1 = (var1 * var2)a2 = (var3 * var4)a1 + a2EOF) 需要注意的是在bash计算器中创建的变量只在bash计算器中有效，不能在shell脚本中使用。 shell中每个运行的命令都使用退出状态码告诉shell它已经运行完毕，退出状态码是一个0-255之间的整数值，在命令结束运行时由命令传给shell。 可以使用变量$?来保存上个已执行命令的退出状态码，一个成功结束的命令的退出状态码是0，如果一个命令结束时有错误，退出状态码就是一个正数值 默认情况下shell脚本会以脚本中的最后一个命令的退出状态码退出，可以使用exit命令在脚本结束时指定一个退出状态码","tags":[{"name":"Linux, Shell","slug":"Linux-Shell","permalink":"https://glemontree.github.io/tags/Linux-Shell/"}]},{"title":"[Linux] Shell编程第六课","date":"2017-12-03T11:45:01.000Z","path":"2017/12/03/[Linux] Shell编程第六课/","text":"必须在存储设备上创建分区来容纳文件系统，分区可以是整个硬盘，也可以是部分硬盘，以容纳虚拟目录的一部分 fdisk工具用来帮助管理安装在系统上的任何存储设备上的分区，要启动fdisk命令，必须指定要分区的存储设备的设备名，另外还得有超级用户权限，你应该这样使用fdisk工具：sudo fdisk /dev/sda 可以使用p命令将一个存储设备的详细信息显示出来，使用n命令在存储设备上创建新的分区 分区可以按主分区或扩展分区创建，主分区可以被文件系统直接格式化，而扩展分区只能容纳其他主分区，扩展分区出现的原因是每个存储设备上只能有4个分区。可以通过创建多个扩展分区，然后在扩展分区内创建主分区进行扩展。 输入p命令后显示的ID列定义了Linux怎么对待该分区，fdisk允许创建多种分区类型，使用l命令列出可用的不同类型，默认类型是83，该类型定义了一个Linux文件系统，如果你想为其他文件系统创建一个分区（比如Windows的NTFS分区），只要选择一个不同的分区类型即可。 创建了想要的分区之后，用w命令将更改保存到存储设备上，存储设备的分区信息被写入分区表中，Linux系统通过ioctl()调用来获知新分区的出现，设置好分区后可以使用Linux文件系统对其进行格式化。 在将数据写入分区之前，必须用某种文件系统对其进行格式化，每种文件系统都有自己的命令行程序进行格式化分区，要想知道某个文件系统工具是否可用，可以使用type命令，例如：type mkfs.ext4 为分区创建了文件系统之后，下一步就是将它挂载到虚拟目录下的某个挂载点，这样就可以将数据储存到新文件系统中了。 要强制Linux在启动时自动挂载新的文件系统，可以将其添加到/etc/fstab文件中。 fsck命令能够检查和修复大部分类型的Linux文件系统：fsck options filesystem，你可以在命令行中列出多个要检查的文件系统，文件系统可以通过设备名、在虚拟目录中的挂载点以及分配给文件系统的唯一UUID来引用。 只能在未挂载的文件系统上运行fsck命令，对大多数文件系统来说，你只需卸载文件系统来进行检查，检查完成之后重新挂载就好了，但因为根文件系统含有所有核心的Linux命令和日志文件，所以无法在处于运行状态的系统上卸载它。","tags":[{"name":"Linux, Shell","slug":"Linux-Shell","permalink":"https://glemontree.github.io/tags/Linux-Shell/"}]},{"title":"[Linux] Shell编程第五课","date":"2017-12-03T11:44:05.000Z","path":"2017/12/03/[Linux] Shell编程第五课/","text":"Linux中广泛使用的两种主要的PMS（Package management system, PMS）基础工具是dpkg和rpm，基于debian的发行版（如Ubuntu和Mint）使用的是dpkg命令，这些发行版的PMS工具也是以该命令为基础的，dpkg会直接和Linux系统上的PMS交互，用来安装、管理和删除软件包；基于Red Hat的发行版（如Fedora、OpenSUSE）使用的是rpm命令，该命令是其PMS的底层基础。 dpkg命令是基于Debian系PMS工具的核心，包含在这个PMS中的其他工具还有： apt-get apt-cache aptitude dpkg是软件包管理系统工具，而aptitude则是完整版的软件包管理系统。 如果安装了aptitude，只需要在shell提示符键入aptitude即可，如果想快速显示某个特定包的详细信息，可以直接在命令行下以单个命令的方式使用aptitude：aptitude show package_name 无法通过aptitude看到跟某个特定软件包相关的所有文件的列表，要得到这个列表，就必须使用dpkg命令：dpkg -L package_name，同样可以进行反向操作，查找某个特定文件属于哪个软件包：dpkg --search absolute_file_name，注意在使用的时候必须用绝对文件路径。 可以使用aptitude命令加search选项确定准备安装的软件名称：aptitude search package_name，search选项的好处就是无需在package_name周围加通配符，通配符会隐式添加，在每个包名字的前面都有一个p或i，如果看到一个i，说明这个包已经安装到了你的系统上，如果看到一个p或v，说明这个包可用，但还没安装。 使用aptitude install命令安装软件包：aptitude install package_name 可以使用aptitude safe-upgrade命令更新系统上的软件，这个命令不需要使用软件包名称作为参数，因为safe-upgrade选项会将所有已安装的包更新到软件仓库中的最新版本。 要想只删除软件包而不删除数据和配置文件，可以使用aptitude的remove选项，要想删除软件包和相关的数据和配置文件，可用purge选项：sudo aptitude purge wine，查看软件包是否已删除，可以再用aptitude的search选项，如果在软件包的前面看到一个c，说明软件已删除，但配置文件尚未从系统中删除，如果前面是个p的话，说明配置文件也已删除。 aptitude默认的软件仓库位置是在安装Linux发行版时设置的，具体位置存储在/etc/apt/sources.list中，sources.list中使用下面的结构来指定仓库源： deb(or deb-src) address distribution_name package_type_list，deb或deb-src的值表明了软件包的类型，deb说明这是一个已编译程序源，而deb-src则说明这是一个源代码的源；address条目是软件仓库的Web地址；distribution_name是这个软件仓库的发行版版本的名称，这未必是说你使用的发行版名称，它只是说明这个Linux发行版正在使用这个软件仓库；package_type_list可能不止一个词，它还表明仓库里面有什么类型的包。","tags":[{"name":"Linux, Shell","slug":"Linux-Shell","permalink":"https://glemontree.github.io/tags/Linux-Shell/"}]},{"title":"[Linux] Shell编程第四课","date":"2017-12-03T11:43:24.000Z","path":"2017/12/03/[Linux] Shell编程第四课/","text":"Linux系统会为各种功能创建不同的用户账户，而这些账户并不是真的用户，这些账户叫做系统账户，是系统上运行的各种服务进程访问资源用的特殊账户，所有运行在后台的服务都需要一个系统用户账户登录到Linux系统上 Linux为系统账户预留了500以下的UID值，为普通用户创建账户时，大多数Linux系统会从500开始，将第一个可用UID分配给这个账户 Linux系统将用户密码保存在另一个单独的文件中（叫做shadow文件，位置在/etc/shadow），只有特定的程序可以访问这个文件 useradd命令可以一次性创建新用户账户及设置用户HOME目录结构，useradd命令使用系统的默认值以及命令行参数来设置用户账户，系统默认值被设置在/etc/default/useradd文件中，可以使用加入了-D选项的useradd命令查看所有Linux系统中的这些默认值：# /user/sbin/useradd -D GROUP=100 HOME=/home INACTIVE=-1 EXPIRE= SHELL=/bin/base SKEL=/etc/skel CREATE_MAIL_SPOOL=yes 在创建新用户时，如果不在命令行中指定具体的值，useradd命令就会使用-D选项所显示的那些默认值： 新用户被添加到GID为100的公共组 新用户的HOME目录将会位于/home/loginname 新用户帐号密码在过期后不会被禁用 新用户帐号为被设置过期日期 新用户账户将bash shell作为默认shell 系统会将/etc/skel目录下的内容复制到用户的HOME目录下 系统为该用户账户在mail目录下创建一个用于接收邮件的文件 useradd命令允许管理员创建一份默认的HOME目录配置，然后把它作为创建新用户HOME目录的模板，这样就能自动在每个新用户的HOME目录里放置默认的系统文件，在本例中，系统会自动将/etc/skel目录下的文件复制到你创建的每个用户的HOME目录。 默认情况下，useradd命令不会创建HOME目录，但是-m命令行选项会使其创建HOME目录，例如useradd -m test。 默认情况下userdel命令会只删除/etc/passwd文件中的用户信息，而不会删除系统中属于该账户的任何文件，如果加上-r参数，userdel会删除用户的HOME目录以及邮件目录 组权限允许多个用户对系统中的对象（比如文件、目录、设备等）共享一组共用的权限 Ubuntu会为每个用户创建一个单独的与用户帐号同名的组，在添加用户前后可用grep命令或tail命令查看/etc/group文件的内容比较 系统账户用的组通常会分配低于500的GID值，而用户组的GID则会从500开始分配，/etc/group文件有4个字段： 组名 组密码 GID 属于该组的用户列表 umask命令用来设置所创建文件和目录的默认权限，例如我的系统中输入umask命令控制台会输出0002，第一位代表了一项特别的安全特性，叫做粘着位，后面的3位表示文件或目录对应的umask八进制值，需要需要的是umask值只是一个掩码，它会屏蔽掉不想授予该安全级别的权限，要把umask值从对象的全权限值中减掉，对文件来说，全权限的值为666，而对目录来说，则是777。在大多数Linux发行版中，umask值通常会设置在/etc/profile启动文件中，不过有一些是设置在/etc/login.defs文件中，例如ubuntu，可以使用umask命令为默认的umask设置一个新值","tags":[{"name":"Linux, Shell","slug":"Linux-Shell","permalink":"https://glemontree.github.io/tags/Linux-Shell/"}]},{"title":"[Linux] Shell编程第三课","date":"2017-12-03T11:42:36.000Z","path":"2017/12/03/[Linux] Shell编程第三课/","text":"全局环境变量对于shell会话和所有生成的子shell都是可见的，局部环境变量则只对创建他们的shell可见，系统环境变量基本上都是使用全大写字母，以区别于普通用户的环境变量。 要查看环境变量，可以使用env命令或者printenv命令，要显示个别环境变量的值可以使用printenv命令，例如printenv HOME，也可以使用echo来显示环境变量的值，但是必须在变量前面加上$符号，例如echo $HOME set命令会显示为某个特定进程设置的所有环境变量，包括局部变量、全局变量以及用户自定义变量 设置用户自定义环境变量：通过等号给环境变量赋值，值可以是数值或字符串，例如：my_variable=hello，如果要给变量赋一个含有空格的字符串值，必须用单引号来界定字符串的首和尾。需要注意的是变量名、等号和值之间是没有空格的。 创建全局环境变量：先创建一个局部环境变量，然后再把它导出到全局环境中，这个过程使用export命令来完成，变量名前不要加$，例如：my_variabel=&quot;I am global now&quot;; export my_variable; echo $my_variable; 在定义并导出环境变量后，启动一个子shell，此时在子shell中修改这个变量的值，这种改变只会在当前子shell中生效，不会反映到父shell中，子shell甚至无法使用export命令改变父shell中全局变量的值。 可以使用unset命令来删除环境变量，在unset命令中引用环境变量时不要使用$，例如：unset my_variable 在环境变量操作时，需要用到变量，使用$，如果要操作变量，不使用$ 如果你在子进程中删除了一个全局环境变量，这只对子进程有效，该全局变量在父进程中依然可用 /etc/profile文件是系统默认的bash shell的主启动文件，系统上的每个用户登录时都会执行这个启动文件，每个发行版的/etc/profile文件都有不同的设置和命令 $HOME目录下的启动文件： $HOME/.bash_profile $HOME/.bashrc $HOME/.bash_login $HOME/.profile 这些文件都有一个作用就是提供一个用户专属的启动文件来定义该用户所用到的环境变量，大多数Linux发行版只用到这个4个启动文件中的一个或两个，每个用户都可以编辑这些文件并添加自己的环境变量，这些环境变量会在启动bash shell会话时生效。 数组是能够存储多个值的变量，这些值可以单独使用，也可以作为整个数组来引用，要给某个环境变量设置多个值，可以把值放在括号里，值和值之间用空格分隔：mytest=(one two three four five)，如果你使用下面的方式来使用数组，那么得到的结果就是数组的第一个元素：echo $mytest要引用一个单独的数组元素，就必须用代表它在数组中位置的数组索引值，索引值用方括号括起来，并且索引值从0开始，例如：echo ${mytest[2]}要想显示整个数组变量，可用星号(*)作为通配符放在索引值的位置：echo ${mytest[*]}","tags":[{"name":"Linux, Shell","slug":"Linux-Shell","permalink":"https://glemontree.github.io/tags/Linux-Shell/"}]},{"title":"[Linux] Shell编程第二课","date":"2017-12-03T11:41:45.000Z","path":"2017/12/03/[Linux] Shell编程第二课/","text":"top命令能够实时显示进程信息： 输出的第一部分显示的系统的概况：第一行显示了当前时间、系统的运行时间、登录的用户数以及系统的平均负载 平均负载有三个值，最近1分钟的、最近5分钟的和最近15分钟的平均负载，值越大说明系统的负载越高，如果近15分钟的平均负载都很高，说明系统有问题 第二行显示了进程概要信息，有多少进程处于运行、休眠、停止或是僵化状态 第三行显示了CPU的概要信息 第四行和第五行显示了系统内存的状态 最后一部分显示了当前运行中的进程的详细列表 在top命令运行时键入f允许选择对输出进行排序的字段，键入d允许修改轮询间隔，键入q退出top killall命令支持通过进程名而不是PID来结束进程，同时还支持通配符 df命令可以查看所有已挂载磁盘的使用情况，df命令最常用的参数就是-h，它会把输出中的磁盘空间按照用户易读的方式显示 如果在卸载设备时，系统提示设备繁忙，无法卸载设备，通常是有进程还在访问该设备或使用该设备上的文件，这时可用lsof命令获得使用它的进程信息，然后在应用中停止使用该设备或停止该进程，例如：lsof /path/to/device/node sort命令是对数据进行排序的 默认情况下，sort命令会按照会话指定的默认语言的排序规则对文本文件中的数据进行排序。默认情况下，sort命令会把数字当作字符来执行标准的字符排序，要解决这个问题，可以使用-n参数，它会告诉sort命令把数字识别成数字而不是字符，并且按值排序，例如：sort -n file2 k和-t参数对按字段分隔的数据进行排序时非常有用，可以用-t参数来指定分隔符，然后用-k参数来指定排序的字段，例如对/etc/passwd文件中的内容按照用户ID进行数值排序：sort -t ‘:’ -k 3 -n /etc/passwd r参数将结果按降序输出 grep命令会在输入或指定的文件中查找包含匹配指定模式的字符的行，grep输出的就是包含了匹配模式的行，grep的语法为：grep [options] pattern [file]。 举例： 基本搜索：grep three file1 反向搜索（输出不匹配该模式的行，加-v参数）：grep -v t file1 显示匹配模式的行所在的行号，加-n参数：grep -n t file1 只需要知道有多少行含有匹配的模式，加-c参数：grep -c t file1 指定多个匹配模式，使用-e参数：grep -e t -e f file1 gzip：压缩文件 gzcat：查看压缩过的文本文件的内容 gnuzip：解压文件 ps –forest可以显示进程之间的关系 外部命令是存在于bash shell之外的程序，它们并不是shell程序的一部分，外部命令程序通常位于/bin、/usr/bin、/sbin和/usr/sbin中，当外部命令执行时会创建出一个子进程，这个子进程也叫做衍生子进程。 内建命令不需要使用子进程来执行，它们已经和shell编译成了一体，不需要借助外部程序文件来运行，可以利用type命令来了解某个命令是否是内建的。 输入!!，然后按回车键能够唤出刚刚用过的那条命令来执行 命令历史记录被保存在隐藏文件.bash_history中，位于用户的主目录中，bash命令的历史纪录是先放在内存中，当shell退出时才被写入历史文件中。","tags":[{"name":"Linux, Shell","slug":"Linux-Shell","permalink":"https://glemontree.github.io/tags/Linux-Shell/"}]},{"title":"[Linux] Shell编程第一课","date":"2017-12-03T11:40:27.000Z","path":"2017/12/03/[Linux] Shell编程第一课/","text":"当使用man命令查看命令手册时，这些手册页是由分页程序来显示的，可以通过点击空格进行翻页，或者使用回车逐行查看。 如果不记得命令名怎么办？可以使用关键字搜索手册页，语法是：man -k 关键字，例如要查找和终端相关的命令，可以输入man -k terminal Linux手册页常用的节名有以下： Name 显示命令名和一段简短的描述 Synopsis 命令的语法 Configuration 命令配置信息 Description 命令的一般性描述 Options 命令选项描述 Exit Status 命令的退出状态指示 Return Value 命令的返回值 Errors 命令的错误信息 Environment 描述所使用的环境变量 Files 命令用到的文件 Versions 命令的版本信息 Conforming To 命令所遵循的标准 Notes 其他有帮助的资料 Bugs 提供提交Bug的路径 Example 展示命令的用法 Authors 命令开发人员的信息 Copyright 命令源代码的版权情况 See Also 与该命令类型的其他命令 Linux使用正斜线(/)而不是反斜线()在文件路径中划分目录，在Linux中，反斜线用来标识转义字符 Linux会在根驱动器上创建一些特别的目录，称之为挂载点，挂载点是虚拟目录中用于分配额外存储设备的目录，虚拟目录会让文件和目录出现在这些挂载点目录中，然而实际上它们却存储在另外一个驱动器中 在Linux PC上安装的第一块硬盘称为根驱动器，根驱动器包含了虚拟目录的核心，其他目录都是从那里开始创建的 可以使用带-F参数的ls命令轻松区分文件和目录，-F参数在目录名后加了正斜线(/)，在可执行文件的后面加上星号(*) ls命令的-R参数叫做递归选项，它列出了当前目录下包含的子目录中的文件 选项不一定要分开输入：ls -F -R，也可以合并：ls -FR 要查看文件或目录的inode编号，可以给ls命令加入-i参数 只能对处于同一存储媒体的文件创建硬链接，要想在不同存储媒体的文件之间创建链接，只能使用符号链接 在使用rm命令时，要养成加入-i参数的好习惯 默认情况下，rmdir命令只删除空目录 tree工具能够以一种美观的方式展示目录、子目录及其中的文件，不过需要安装该工具 file命令具有以下一些功能： file命令能够探测文件的内部，并决定文件是什么类型 使用file命令作为另一种区分目录的方法 将file命令应用于一个符号链接文件时，file命令可以显示链接到了哪个文件上 将file命令应用于一个二进制可执行程序，file命令能够确定该程序编译时所面向的平台以及需要何种类型的库 tail命令会显示文件最后几行的内容，默认情况下显示文件的末尾10行，可以向tail命令中加入-n参数来修改所显示的行数，例如：tail -n 2 log_file 会显示文件的最后两行。tail命令还有一个重要的参数就是-f参数，它允许你在其他进程使用该文件时查看文件的内容，tail命令会保持活动状态，并不断显示添加到文件中的内容，这是实时监测系统日志的绝妙方式。","tags":[{"name":"Linux, Shell","slug":"Linux-Shell","permalink":"https://glemontree.github.io/tags/Linux-Shell/"}]},{"title":"[Java] Java并发编程实战之任务执行","date":"2017-12-02T10:37:09.000Z","path":"2017/12/02/[Java] Java并发编程实战之任务执行/","text":"任务是一组逻辑工作单元，而线程则是使任务异步执行的机制 Executor提供了一种标准的方法将任务的提交过程和执行过程解耦开来，并用Runnable表示任务，Executor基于生产者-消费者模式，提交任务的操作相当于生产者（生产待完成的工作单元），执行任务的线程则相当于消费者（执行完这些工作单元）。 如果要在程序中实现一个生产者-消费者的设计，那么最简单的方式就是使用Executor 每当看到下面形式的代码时：new Thread(runnable).start()，并且你希望获得一种更灵活的执行策略时，请考虑使用Executor来代替Thread。 java.lang.concurrent提供了线程池作为实现executor框架的一部分： 1234567891011121314151617181920public class TaskExecutionWebServer &#123; private static final int nTHREADS = 100; private static final Executor exec = Executors.newFixedThreadPool(NTHREADS); public static void main(String[] args) throws IOException &#123; ServerSocket socket = new ServerSocket(80); while (true) &#123; final Socket connection = socket.accept(); Runnable task = new Runnable() &#123; public void run() &#123; handleRequest(connection); &#125; &#125;; exec.execute(task); &#125; &#125; private static void handleRequest(Socket connection) &#123; &#125;&#125; Executor的实现通常会创建线程来执行任务，但JVM只有在所有（非守护）线程全部终止后才会退出，因此，如果无法正确的关闭Executor，那么JVM将无法结束。 Executor框架使用Runnable作为其基本的任务表示形式，Runnable是一种有很大局限的抽象，虽然run能写入到日志文件或者将结果放入某个共享的数据结构，但它不能返回一个值或抛出一个受检查的异常。 Callable认为主入口点（即call）将返回一个值，并可能抛出一个异常。 Future表示一个任务的生命周期，并提供了相应的方法来判断是否已经完成或取消，以及获取任务的结果和取消任务等。get方法的行为取决于任务的状态（尚未开始、正在运行、已完成）。如果任务已经完成，那么get会立即返回或者抛出一个Exception，如果任务没有完成，那么get将阻塞并直到任务完成。如果任务抛出了异常，那么get将该异常封装为ExecutionException并重新抛出。如果任务被取消，那么get将抛出CancellationException，如果get抛出了ExecutionException，那么可以通过getCause()获得被封装的初始异常。 1234567891011public interface Callable&lt;V&gt; &#123; V call() throws Exception;&#125;public interface Future&lt;V&gt; &#123; boolean cancel(boolean mayInterruptIfRunning); boolean isCancelled(); boolean inDone(); V get() throws InterruptedException, ExecutionException, CancellationException; v get(long timeout, TimeUnit unit) throws InterruptedException, ExecutionException, CancellationException, TimeoutException;&#125; 要使用Callable来表示无返回值的任务，可使用Callable&lt;void&gt;","tags":[{"name":"Java 并发","slug":"Java-并发","permalink":"https://glemontree.github.io/tags/Java-并发/"}]},{"title":"[Java] Java并发编程实战之基础构建模块","date":"2017-11-30T13:37:18.000Z","path":"2017/11/30/[Java] Java并发编程实战之基础构建模块/","text":"同步容器类包括Vector和Hashtable以及Collections.synchronizedXxx等工厂方法创建的，这些类实现线程安全的方式是：将它们的状态封装起来，并对每个公有方法都进行同步，使得每次只有一个线程能访问容器的状态。 同步容器类通过其自身的锁来保护它的每一个方法。 看下面这种情况： 123456789public static Object getlast(Vector list) &#123; int lastIndex = list.size() - 1; return list.get(lastIndex);&#125;public static void deleteLast(Vector list) &#123; int lastIndex = list.size() - 1; list.remove(lastIndex);&#125; 虽然Vector.get()和Vectot.remove()方法都是同步方法，但是在getLast()方法和deleteLast()方法中都先经历了list.size()方法，当getLast()方法执行完int lastIndex = list.size() - 1;后，如果此时有另外一个线程执行deleteLast()方法，那么lastIndex的值就是无效的，因此，这两个方法不是同步的。 我们可以这样解决： 12345678910111213public static Object getlast(Vector list) &#123; synchronized(list) &#123; int lastIndex = list.size() - 1; return list.get(lastIndex); &#125;&#125;public static void deleteLast(Vector list) &#123; synchronized(list) &#123; int lastIndex = list.size() - 1; list.remove(lastIndex); &#125;&#125; 对容器类进行迭代的标准方式是使用Iterator，然而，如果有其他线程并发的修改容器，那么即使是使用迭代器也无法避免在迭代期间对容器加锁。当容器类在迭代过程中被修改时，会抛出ConcurrentModificationException异常。 如果不希望在迭代期间对容器加锁，那么一种替代方法就是克隆容器，并在副本上进行迭代，由于副本封闭在线程内，因此其他线程不会在迭代期间对其进行修改，这样就可以避免出现ConcurrentModificationException异常。 同步容器将所有对容器状态的访问都串行化，以实现它们的线程安全性，这种方法的代价是严重降低并发性，Java5.0提供了多种并发容器类来改进同步容器的性能。 并发容器是针对多个线程并发访问设计的，在Java5.0中增加了ConcurrentHashMap用来替代同步且基于散列的Map以及CopyOnWriteArrayList，用于在遍历操作为主要操作的情况下代替同步的List。 同步容器类在执行每个操作期间都持有一个锁，与HashMap一样，ConcurrentHashMap也是一个基于散列的Map，但它使用了一种完全不同的加锁策略来提供更高的并发性和伸缩性，ConcurrentHashMap并不是将每个方法都在同一个锁上同步并使得每次只能有一个线程访问容器，而是使用一种粒度更细的加锁机制来实现更大程度的共享，这种机制成为分段锁。 在这种机制中，任意数量的读取线程可以并发的访问Map，执行读取操作的线程和执行写入操作的线程可以并发的访问Map，并且一定数量的写入线程可以并发的修改Map。 ConcurrentHashMap提供的迭代器不会抛出ConcurrentModificationException，因此不需要在迭代过程中对容器进行加锁 ConcurrentHashMap不能被加锁来执行独占访问，因此我们无法使用客户端加锁来创建新的原子操作，在ConcurrentHashMap中一些常见的复合操作例如若没有则添加、若相等则移除和若相等则替换都已经实现为原子操作并且在ConcurrentHashMap接口中声明。 123456public interface ConcurrentHashMap&lt;K, V&gt; extends Map&lt;K, V&gt; &#123; V putIfAbsent(K key, V value); boolean remove(K key, V value); boolean replace (K key, V oldValue, V newValue); V replace(K key, V newValue);&#125; 上面的这些方法在ConcurrentHashMap中已经实现为同步方法。 CopyOnWriteArrayList用于替代同步List，在某些情况下它提供了更好的并发性能，并且在迭代期间不需要对容器进行加锁或复制。 在每次修改时，都会创建并重新发布一个新的容器副本，从而实现可变性。“写入时复制”容器的迭代器保留一个指向底层基础数组的引用，这个数组当前位于迭代器的起始位置，由于它不会被修改，因此在对其进行同步时只需确保数组内容的可见性。 因此，多个线程可以同时对这个容器进行迭代，而不会彼此干扰或者与修改容器的线程相互干扰，“写入时复制”容器返回的迭代器不会抛出ConcurrentModificationException，并且返回的元素与迭代器创建时的元素完全一致，而不必考虑之后修改操作所带来的影响。 阻塞队列提供了可阻塞的put和take方法，以及支持定时的offer和poll方法。BlockingQueue简化了生产者-消费者设计的实现过程，它支持任意数量的生产者和消费者。一种最常见的生产者-消费者设计模式就是线程池与工作队列的组合，在Executor任务执行框架中就体现了这种模式。 阻塞队列提供的offer方法，如果数据项不能被添加到队列中，那么将返回一个失败状态，这样你就能够创建更多灵活的策略来处理负荷过载的情况，例如减轻负载，将多余的工作项序列并写入硬盘，减少生产者线程的数量。 在类库中包含了BlockingQueue的多种实现，其中，LinkedBlockingQueue和ArrayBlockingQueue是FIFO队列，二者区别与LinkedList和ArrayList类似，但比同步List拥有更好的并发性能。PriorotyBlockingQueue是一个按照优先级排序的队列，当你希望按照某种顺序而不是FIFO来处理元素时，这个队列将十分有用。 CountDownLatch是一种灵活的闭锁实现，它可以使一个或多个线程等待一组事件发生。闭锁状态包括一个计数器，该计数器被初始化为一个正数，表示需要等待的事件数量，countDown方法递减计数器，表示有一个事件发生了，而await方法等待计数器达到0，这表示所有需要等待的事件都已经发生，如果计数器的值非零，那么await会一直阻塞直到计数器为0，或者等待中的线程中断，或者等待超时。 看下面这个例子，创建一定数量的线程，利用他们并发的执行指定的认为。在这里例子中使用了两个闭锁，分别表示起始门和结束门，起始门计数器的初始值为1，而结束门计数器的初始值为工作线程的数量： 1234567891011121314151617181920212223242526272829public class TestHarness &#123; public long timeTasks(int nThreads, final Runnable task) throws InterruptedException &#123; final CountDownLatch startGate = new CountDownLatch(1); final CountDownLatch endGate = new CountDownLatch(nThreads); for (int i = 0; i &lt; nThreads; i++) &#123; Thread t = new Thread() &#123; public void run() &#123; try &#123; startGate.await(); try &#123; task.run(); &#125; finally &#123; endGate.countDown(); &#125; &#125; catch(InterruptedException ignored) &#123; &#125; &#125; &#125;; t.start(); &#125; long start = System.nanoTime(); startGate.countDown(); endGate.await(); long end = System.nanoTime(); return end - start; &#125;&#125; 这里启动门将使得主线程能够同时释放所有工作线程，而结束门则使主线程能够等到最后一个线程执行完成。 FutureTask表示的计算是通过Callable来实现的，相当于一种可生成结果的Runnable，Future.get的行为取决于任务的状态，如果任务已经完成，那么get会立即返回结果，否则get将阻塞直到任务进入完成状态，然后返回结果或者抛出异常，FutureTask将计算结果从执行计算的线程传递到获取这个结果的线程。 FutureTask在Executor框架中表示异步任务，此外还可以用来表示一些时间较长的计算，这些计算可以在使用计算结果之前启动： 123456789101112131415161718192021222324252627public class Preloader &#123; private final FutureTask&lt;ProductInfo&gt; future = new FutureTask&lt;ProductInfo&gt;(new Callable&lt;ProductInfo&gt;() &#123; public ProductInfo call() throws DataLoadException &#123; return loadProductInfo(); &#125; &#125;); private final Thread thread = new Thread(future); public void start() &#123; thread.start(); &#125; public ProductInfo get() throws DataLoadException, InterruptedException &#123; try &#123; return future.get(); &#125; catch (ExecutionException e) &#123; Throwable cause = e.getCause(); if (cause instanceof DataLoadException) &#123; throw (DataLoadException) cause; &#125; else &#123; throw launderThrowable(cause); // throw 语句可以调用函数 &#125; &#125; &#125;&#125; 在上面的程序中，当程序随后需要ProductInfo时，可以调用get方法，如果数据已经加载，那么将返回这些数据，否则将等待加载完成后再返回。 计数信号量（Semaphore）用来控制同时访问某个特定资源的操作数量，或者同时执行某个指定操作的数量，计数信号量还可以用来实现某种资源池。 Semaphore中管理着一组虚拟的许可，许可的初始数量可通过构造函数指定，在执行操作时首先获得许可，并在使用以后释放许可。如果没有许可，那么acquire将阻塞到有许可，release方法将放回一个许可信号量。 Semaphore可以用于实现资源池，例如数据库连接池，我们可以构造一个固定长度的资源池，当池为空时，请求资源就会失败，但你真正想看到的行为是阻塞而不是失败，并且当非空时解除阻塞。如果将Semaphore 的计数值初始化为池的大小，并在从池中获取一个资源之前首先调用acquire方法获取一个许可，在将资源返回给池后调用release释放许可，那么acquire将一直阻塞知道资源池不为空。 可以使用Semaphore将任何一种容器变成有界阻塞容器，如下所示： 123456789101112131415161718192021222324252627282930public class BoundedHashSet&lt;T&gt; &#123; private final Set&lt;T&gt; set; private final Semaphore sem; public BoundedHashSet(int bound) &#123; this.set = Collections.synchronizedSet(new HashSet&lt;T&gt;()); sem = new Semaphore(bound); &#125; public boolean add(T o) throws InterruptedException &#123; sem.acquire(); boolean wasAdded = false; try &#123; wasAdded = set.add(o); return wasAdded; &#125; finally &#123; if (!wasAdded) &#123; sem.release(); &#125; &#125; &#125; public boolean remove(Object o) &#123; boolean wasRemoved = set.remove(o); if (wasRemoved) &#123; sem.release(); &#125; return wasRemoved; &#125;&#125; 在上面的代码中，信号量的初始值会被初始化为容器的最大值，add操作在向底层容器中添加一个元素之前，会首先获取一个许可，如果add操作没有成功，那么会释放许可，否则就会一直占用着许可，也即少了一个许可，对应到容器中就是容器中已经有了一个元素，容器的空间减一。 闭锁是一次性对象，一旦进入终止状态，就不能被重置。 Barrier类似于闭锁，它能阻塞一组线程直到某个事件发生，栅栏与闭锁的关键区别在于所有线程必须同时到达栅栏位置，才能继续执行。闭锁用于等待事件，而栅栏用于等待其他线程。 CyclicBarrier可以使一定数量的参与方反复的在栅栏位置汇集，它在并行迭代算法中非常有用：这种算法将一个问题拆分为一系列相互独立的子问题，当线程到达栅栏位置时将调用await方法，这个方法将阻塞直到所有线程都到达栅栏位置。如果所有线程都到达了栅栏位置，那么栅栏将打开，此时所有线程都被释放，而栅栏将被重置以便下次使用。 如果对await的调用超时，或者await阻塞的线程被中断，那么栅栏就被认为是打破了，所有阻塞的await调用都将终止并抛出BrokenBarrierException，如果成功的通过栅栏，那么await将为每个线程返回一个唯一的到达索引号，我们可以利用这些索引来选举产生一个领导线程，并在下次迭代中由该领导线程执行一些特殊的工作。 CyclicBarrier还可以使你将一个栅栏操作传递给构造函数，这是一个Runnable，当成功通过栅栏时会在一个子任务线程中执行它，但在阻塞线程被释放前不会被执行。 构造函数CyclicBarrier(int parties, Runnable barrierAction)，当线程在CyclicBarrier对象上调用await()方法时，栅栏的计数器将增加1，当计数器为parties时，栅栏将打开。 ​","tags":[{"name":"Java 并发","slug":"Java-并发","permalink":"https://glemontree.github.io/tags/Java-并发/"}]},{"title":"[Java] Java并发编程实战之对象的组合","date":"2017-11-30T09:02:06.000Z","path":"2017/11/30/[Java] Java并发编程实战之对象的组合/","text":"将数据封装在对象内部，可以将数据的访问限制在对象的方法上，从而更容易确保线程在访问数据时总能持有正确的锁。 看下面的例子： 1234567891011121314public class PersonSet &#123; private final Set&lt;Person&gt; mySet = new HashSet&lt;Person&gt;(); // HashSet不是线程安全的，但由于mySet是私有的，并且不会逸出，因此HashSet被封装在PersonSet中 public synchronized void addPerson(Person p) &#123; mySet.add(p); &#125; public synchronized boolean containsPerson(Person p) &#123; return mySet.contains(p); &#125; interface Person &#123; &#125;&#125; PersonSet的状态由HashSet来管理，而HashSet不是线程安全的，但由于mySet是私有的并且不会逸出，因此HashSet被封装在PersonSet中。唯一能访问mySet的代码路径是addperson和containsPerson，在执行它们时需要获得PersonSet上的锁（this），-PersonSet的状态完全由它的内置锁保护，因此PersonSet是一个线程安全的类。 这个实力并未对Person的线程安全型做任何假设，但如果Person类是可变的，那么在访问从PersonSet中获得的Person对象时，还需要额外的同步，要想安全的使用Person对象，最可靠的方法是使Person成为一个线程安全的类。 实例封闭是构建线程安全类的一个最简单的方式，实例封装还使得不同的状态变量可以由不同的锁来保护。 Java的内置锁也称为监视器锁或监视器 线程安全性的委托 我们在一个无状态的类中增加一个AtomicLong类型的域，由于AtomicLong是线程安全的，因此该类也是一个线程安全的类，因此我们可以说该类将它的线程安全性委托给AtomicLong来保证。 独立的状态变量 我们还可以将线程安全委托给多个状态变量，只要这些变量是彼此独立的，即组合而成的类并不在其包含的多个状态变量上增加任何不变性条件。 12345678910111213141516171819202122public class VisualComponent &#123; private final List&lt;KeyListener&gt; keyListeners = new CopyOnWriteArrayList&lt;KeyListener&gt;(); //CopyOnWriteArrayList是线程安全的链表 private final List&lt;MouseListener&gt; mouseListeners = new CopyOnWriteArrayList&lt;MouseListener&gt;();//两个状态变量是彼此独立的 public void addKeyListener(KeyListener listener) &#123; keyListeners.add(listener); &#125; public void addMouseListener(MouseListener listener) &#123; mouseListeners.add(listener); &#125; public void removeKeyListener(KeyListener listener) &#123; keyListeners.remove(listener); &#125; public void removeMouseListener(MouseListener listener) &#123; mouseListeners.remove(listener); &#125;&#125; 在现有的线程安全类中添加功能： 继承这个线程安全的类 看下面的代码： 12345678910public class BetterVector&lt;E&gt; extentds vector&lt;E&gt; &#123; static final long serialVersionUID = -3963416950630760754L; public synchronized boolean putIfAbsent(E x) &#123; boolean absent = !contains(x); if (absent) &#123; add(x); &#125; return absent; &#125;&#125; 继承方法存在的问题就是： 如果底层的类改变了同步策略并选择了不同的锁来保护它的状态变量，那么子类就会被破坏，因此在同步策略改变后它无法再使用正确的锁来控制对基类状态的并发访问。 在上面的例子中，如果vector底层不再使用synchronized对contains()和add()方法加锁，那么putIfAbsent()方法就不是线程安全的。 扩展类的功能，但并不是继承类本身，而是将类放在一个扩展类中 看下面的代码： 12345678910public BadListHelper&lt;E&gt; &#123; public List&lt;E&gt; list = Collections.synchronizedList(new ArrayList&lt;E&gt;()); public synchronized boolean putIfAbsent(E x) &#123; boolean absent = !list.contains(x); if (absent) &#123; list.add(x); &#125; return absent; &#125;&#125; 上面这个类并不是线程安全的，问题在于在错误的锁上进行了同步，list使用的同步锁并不是BadListHelper上的锁。 可以将上面的代码改成下面的形式： 123456789101112class GoodListHelper&lt;E&gt; &#123; public List&lt;E&gt; list = Collections.synchronizedList(new ArrayList&lt;E&gt;()); public boolean putIfAbsent(E x) &#123; synchronized(list) &#123; boolean absent = !list.contains(x); if (absent) &#123; list.add(x); &#125; return absent; &#125; &#125;&#125; 继承会破坏实现的封装性，客户端加锁会破坏同步策略的封装性。 当为现有的类添加一个原子操作时，有一种更好的方法就是组合。 看下面的代码： 123456789101112131415public class ImprovedList&lt;T&gt; implements List&lt;T&gt; &#123; private final List&lt;T&gt; list; public ImprovedList(List&lt;T&gt; list) &#123; this.list = list; &#125; public synchronized boolean putIfAbsent(T x) &#123; boolean contains = list.contains(x); if (contains) &#123; list.add(x); &#125; return !contains; &#125;&#125; ImprovedList通过将List对象委托给底层的List实例来实现List的操作，同时还添加了一个原子的putIfAbsent方法。 ImprovedList通过自身的内置锁增加了一层额外的加锁，它并不关心底层的List是否是线程安全的。事实上，我们使用了Java监视器模式来封装现有的List，并且只要在类中拥有指向底层List的唯一外部引用，就能确保线程安全性。 本文参考自Java并发编程实战(学习笔记三 第四章 对象的组合)。","tags":[{"name":"Java 并发","slug":"Java-并发","permalink":"https://glemontree.github.io/tags/Java-并发/"}]},{"title":"[Java] Java并发编程实战之对象的共享","date":"2017-11-29T05:05:03.000Z","path":"2017/11/29/[Java] Java并发编程实战之对象的共享/","text":"对于非volatile类型的64位数值变量（double和long），JVM允许将64位的读操作和写操作分解为两个32位的操作。当读取一个非volatile类型的long变量时，如果对变量的读操作和写操作在不同的线程中执行，那么很可能会读取到某个值的高32位和另一个值的低32位。 在多线程中使用共享且可变的long和double类型的变量是不安全的，除非使用关键字volatile来声明，或者使用锁进行保护 加锁的含义不仅仅局限于互斥行为，还包括内存可见性，为了确保所有线程都能看到共享变量的最新值，所有执行读操作或者写操作的线程都必须在同一个锁上进行同步 volatile变量用来确保将变量的更新操作通知到其他线程，当把变量声明为volatile类型后，编译器与运行时都会注意到这个变量是共享的，因此不会将该变量上的操作同其他内存操作一起重排序，volatile类型变量不会被缓存在寄存器或者对其他处理器不可见的地方，因此在读取volatile类型的变量时总会返回最新写入的值。 加锁机制既可以确保可见性又可以确保原子性，而volatile变量只能确保可见性 看下面这段代码： 123456789public class ThisEscape &#123; public ThisEscape(EventSource source) &#123; source.registerListener(new EventListener() &#123; // 匿名内部类会持有一个外部类的引用 public void onEvent(Event e) &#123; doSomething(e); &#125; &#125;); &#125;&#125; 在ThisEscape中给出了逸出的一个特殊示例，即this引用在构造函数中逸出，当内部的EventListener实例发布时，在外部封装的ThisEscape实例也逸出了。当且仅当对象的构造函数返回时，对象才处于可预测的一致的状态，因此，当从对象的构造函数中发布对象时，只是发布了一个尚未构造完成的对象，即使发布对象的语句在构造函数最后一行也是如此。 如果this引用在构造过程中逸出，那么这种对象就被认为是不正确构造。 不要在构造函数中使this引用逸出。 在构造函数中使this逸出的一个常见错误是在构造函数中启动一个线程，当对象在其构造函数中创建一个线程时，无论是显示创建还是隐式创建，this引用都会被新创建的线程共享。在对象尚未完全构造之前，新的线程就可以看见它。 在构造函数中创建线程并没有错误，但最好不要立刻启动它，而是通过一个start或initialize方法来启动。 发布一个对象的意思是指使对象在当前作用域之外的代码中使用，例如将一个指向该对象的引用保存在其他代码可以访问的地方，或者在某一个非私有的方法中返回该引用，或者将引用传递到其他类的方法中。 如果想在构造函数中注册一个事件监听器或启动线程，那么可以使用一个私有的构造函数和一个公共的工厂方法，从而避免不正确的构造过程： 1234567891011121314151617public class SaleListener &#123; private final EventListener listenerl; privaet SafeListener() &#123; listener = new EventListener() &#123; // 虽然内部类中持有了外部类的引用，但是listener并没有在构造函数中发布出去，而是在newInstance()函数中才发布出去，此时外部类已经构造完成。 public void onEvent(Event e) &#123; doSomething(e); &#125; &#125;; &#125; public static SafeListener newInstance(EventSource source) &#123; SafeListener safe = new SafeListener(); source.registerListener(safe.listener); return safe; &#125;&#125; 只有在构造函数返回时，this引用才应该从线程中逸出。构造函数可以将this引用保存到某个地方，只要其他线程不会在构造函数完成之前使用它。 线程封闭：线程封闭的对象只能由一个线程拥有，对象被封闭在该线程中，并且只能由这个线程修改 只读共享：在没有额外同步的情况下，共享的只读对象可以由多个线程并发访问，但任何线程都不能修改它。 线程安全共享：线程安全的对象在其内部实现同步，因此多个线程可以通过对象的公有接口来进行访问而不需要进一步的访问 ​","tags":[{"name":"Java 并发","slug":"Java-并发","permalink":"https://glemontree.github.io/tags/Java-并发/"}]},{"title":"[Java] Java并发编程实战之线程安全性","date":"2017-11-28T11:43:21.000Z","path":"2017/11/28/[Java] Java并发编程实战之线程安全性/","text":"一个对象是否是线程安全的，取决于它是否被多个线程访问，要使得对象是线程安全的，需要采用同步机制来协同对可变状态的访问 在线程安全类中封装了必要的同步机制，因此客户端无需进一步采用同步措施 无状态对象一定是线程安全的，大多数Servlet都是无状态的，从而极大的降低了在实现Servlet线程安全性时的复杂性 为了确保线程安全性，先检查后执行和读取-修改-写入等操作必须是原子性的 先检查后执行（延迟初始化） 12345678910public class LazyInitRace &#123; private ExpensiveObject instance = null; public ExpensiveObject getInstance() &#123; if (instance == null) &#123; instance = new ExpensiveObject(); &#125; return instance; &#125;&#125; 假设线程A和线程B同时执行getInstance()方法，A看到instance为空，因而创建一个新的ExpensiveObject实例，B同样需要判断instance是否为空，此时的instance是否为空，要取决于不可预测的时序，包括线程的调度方式，以及A需要花多长时间来初始化ExpensiveObject并设置instance，如果当B检查时，instance为空，那么在两次调用getInstance()时可能会得到不同的结果 读取-修改-写入 当在无状态的类中添加一个状态时，如果该状态完全由线程安全的对象来管理，那么这个类仍然是线程安全的： 123456789101112public class CountingFactorizer implements Servlet &#123; private final AtomicLong count = new AtomicLong(0); public long getCount() &#123; return count.get(); &#125; public void service(ServletRequest request, ServletResponse response) &#123; BigInteger i = extarctFromRequest(request); BigInteger[] factors = factor(i); count.incrementAndGet(); encodeIntoResponse(response, factors); &#125;&#125; 内置锁是可重入的，如果某个线程试图获得一个由它自己持有的锁，那么这个请求就会成功。在下面的代码中，子类改写了父类的synchronized方法，然后调用父类中的方法，如果此时没有可重入的锁，那么这段代码就会产生死锁，由于Widget和LoggingWidget中doSomething方法都是synchronized方法，因此每个doSomething方法在执行前都会获取Widget上的锁，然而如果内置锁是不可重入的，那么在调用super.doSomething()时将无法获得Widget上的锁，因为这个锁已经被持有，从而线程将永远停顿下去。 1234567891011public class Widget &#123; public synchronized void doSomething() &#123; &#125;&#125;public class LoggingWidget extends Widget &#123; public synchronized void doSomething() &#123; super.doSomething(); &#125;&#125; 如果用同步来协调对某个变量的访问，那么在访问这个变量的所有位置都需要使用同步，而且，当使用锁来协调对某个变量的访问时，在访问变量的所有位置上都需要使用同一个锁。一种常见的错误是只有在写入共享变量时才需要使用同步，然而事实并非如此。 对于可能被多个线程同时访问的可变状态变量，在访问它时都需要持有同一个锁。 对象的域并不一定要通过内置锁来保护，当获取与对象关联的锁时，并不能阻止另外一个线程访问该对象，某个线程在获得对象的锁之后，只能阻止其他线程获得同一个锁（其他的线程仍然可以访问该对象中未使用对象锁保护的代码）。 并非所有的数据都需要使用锁进行保护，只有被多个线程同时访问的可变数据才需要使用锁来保护。 尽量将不影响共享状态且执行时间较长的操作从同步代码块中分离出去。 看下面这段代码： 1234567891011121314151617181920212223242526272829303132333435public class CacheFactorizer implements Servlet &#123; private BigInteger lastNumber; private BitInteger[] lastFactors; private long hits; private long cacheHits; public synchronized long getHits() &#123; return hits; &#125; public synchronized double getCacheHitRatio() &#123; return (double) cacheHits / (double) hits; &#125; public void service(ServletRequest request, ServletResponse response) &#123; BigInteger i = extarctFromRequest(request); BigInteger[] factors = null; synchronized(this) &#123; ++hits; if (i.equals(lastNumber)) &#123; ++cacheHits; factors = lastFactors.clone(); &#125; &#125; if (factors == null) &#123; factors = factor(i); // 将耗时操作从同步代码中分离出来 synchronized(this) &#123; lastNumber = i; lastFactors = factors.clone(); &#125; &#125; encodeIntoResponse(response, factors); &#125;&#125; 重新构造后的CacheFactorizer实现了在简单性与并发性之间的平衡。在获取和释放锁等操作上都需要一定的开销，因此如果将同步代码块分解的过细，那么通常并不好，尽管这样做并不会破坏原子性。当访问状态变量或者在复合操作的执行期间，CacheFactorizer需要持有锁，但在执行时间较长的因数分解运算之前需要释放锁，这样既确保了线程安全性，也不会过多的影响并发性，而且在每个同步代码块中的代码路径都足够短。 当执行时间较长的或者可能无法快速完成的操作时（网络IO或控制台IO），一定不要持有锁","tags":[{"name":"Java 并发","slug":"Java-并发","permalink":"https://glemontree.github.io/tags/Java-并发/"}]},{"title":"[Java] ClassLoader机制","date":"2017-11-28T10:38:02.000Z","path":"2017/11/28/[Java] ClassLoader机制/","text":"什么是ClassLoader在程序启动的时候，并不会一次性加载程序所要用的所有class文件，而是根据程序的需要，通过Java的类加载机制（ClassLoader）来动态加载某个class文件到内存当中，只有当class文件被载入了内存之后，才能被其他的class所引用。 Java默认提供的三个ClassLoader BootStrap ClassLoader 启动类加载器，是Java类加载层次中最顶层的类加载器，负责加载JDK中的核心库，如rt.jar、resources.jar、charsets.jar等。 Extension ClassLoader 扩展类加载器，负责加载Java的扩展类库，默认加载JAVA_HOME/jre/lib/ext/目录下的所有jar。 App ClassLoader 系统类加载器，负责加载应用程序classpath目录下的所有jar和class文件 当然，用户可以根据需要进行自定义ClassLoader，自定义的ClassLoader必须继承自java.lang.ClassLoader类，也包括Java提供的另外两个ClassLoader（Extension ClassLoader和App ClassLoader），但是BootStrap ClassLoader不继承自ClassLoader，因为它不是一个普通的Java类，底层由C++编写，已嵌入到了JVM内核当中，当JVM启动后，BootStrap ClassLoader也随着启动，负责加载核心库后，并构造Extension ClassLoader和App ClassLoader。 ClassLoader加载类的原理原理ClassLoader使用的是双亲委托模型来搜索类，每个ClassLoader实例都有一个父类加载器的引用，虚拟机内置的类加载器（BootStrap ClassLoader）本身没有父加载器，但可以作为其他ClassLoader实例的父类加载器。当一个ClassLoader实例需要加载某个类时，它会试图亲自搜索某个类之前，先把这个任务委托给它的父类类加载器，这个过程是由上往下依次检查的，首先由最顶层的类加载器BootStrap ClassLoader试图加载，如果没有加载到，则把任务转交给Extension ClassLoader试图加载，如果也没有加载到，则转交给App ClassLoader进行加载，如果它也没有加载的到的话，则返回给委托的发起者，由它到指定的文件系统或网络等URL中加载该类，如果它们都没有加载到这个类的话，则抛出ClassNotFoundException异常，否则将这个找到的类生成一个类的定义，并将它加载到内存当中，最后返回这个类在内存中的Class实例对象。 为什么要使用双亲委托模型？因为这样可以避免重复加载，当父类加载了该类的时候，就没有必要子ClassLoader再加载一次，考虑到安全因素，试想一下，如果不使用双亲委托模式，那我们就可以随时使用自定义的String来动态替代Java核心api中定义的类型，这样会存在很大的安全隐患，而双亲委托模式就可以避免这种情况，因为String已经在启动时被引导类加载器（BootStrap ClassLoader）加载，所以使用自定义的ClassLoader永远无法也无法加载一个自己写的String。 JVM在搜索类的时候，如何判断两个class是相同的呢？JVM在判定两个class是否相同时，不仅要判断两个类名是否相同，而且要判断是否由同一个类加载器实例加载的，只有两者同时满足的情况下，JVM才会认为这两个class是相同的。就算两个class是同一份class字节码，如果被两个不同的ClassLoader实例所加载，JVM也会认为它们是两个不同class。 定义自己的ClassLoader既然JVM已经提供了默认的类加载器，为什么还要定义自已的类加载器呢？因为Java中提供的默认ClassLoader，只加载指定目录下的jar和class，如果我们想加载其它位置的类或jar时，比如：我要加载网络上的一个class文件，通过动态加载到内存之后，要调用这个类中的方法实现我的业务逻辑。在这样的情况下，默认的ClassLoader就不能满足我们的需求了，所以需要定义自己的ClassLoader。 定义自已的类加载器分为两步： 继承java.lang.ClassLoader 重写父类的findClass方法 JDK已经在loadClass方法中帮我们实现了ClassLoader搜索类的算法，当在loadClass方法中搜索不到类时，loadClass方法就会调用findClass方法来搜索类，所以我们只需重写该方法即可。如没有特殊的要求，一般不建议重写loadClass搜索类的算法。 说明本文转载自深入分析Java ClassLoader原理。","tags":[{"name":"Java ClassLoader","slug":"Java-ClassLoader","permalink":"https://glemontree.github.io/tags/Java-ClassLoader/"}]},{"title":"[Effective Java] 创建和销毁对象","date":"2017-11-02T07:47:21.000Z","path":"2017/11/02/[Effective Java] 考虑用静态工厂方法代替构造器/","text":"考虑用静态工厂方法代替构造器创建类实例的方法 公有构造器 公有静态工厂方法 静态工厂方法与构造器相比的优势 静态工厂方法有名称 如果构造器的参数本身没有确切的描述正被返回的对象，那么具有适当名称的静态工厂会更容易使用，举个例子，构造器BigInteger(int, int, Random)返回的BigInteger可能为素数，如果用名为BigInteger.probablePrime的静态工厂方法来表示，显然更加清楚。 另外，当一个类需要多个带有相同签名的构造器时，就用静态工厂方法代替构造器。 不必在每次调用它们的时候都创建一个新对象 可以返回原返回类型的任何子类型的对象 在创建参数化类型实例的时候，它们使代码变得更加简洁 在调用参数化类的构造器时，即使类型参数很明显，也必须指明，这通常要求你接连两次提供类型参数： 1Map&lt;String, List&lt;String&gt;&gt; m = new HashMap&lt;String, List&lt;String&gt;&gt;(); 随着类型参数变得越来越长，越来越复杂，这显然是不合适的。但是有了静态工厂方法，编译器就可以替你找到类型参数，这就是类型推导： 123public static &lt;K, V&gt; HashMap&lt;K, V&gt; newInstance() &#123; return new HashMap&lt;K, V&gt;();&#125; 你就可以用下面简洁的代码代替上面这段繁琐的声明： 1Map&lt;String, List&lt;String&gt;&gt; m = HashMap.newInstance(); 静态工厂方法的一些惯用名称 valueOf 该方法返回的实例与它的参数具有相同的值，这样的静态工厂方法实际上是类型转换方法 of valueOf的一种更加简洁的替代 getInstance 返回的实例是通过方法的参数来描述的，但是不能够说与参数具有相同的值，对于Singleton来说，该方法没有参数，并返回唯一的实例 newInstance 与getInstance实例一样，但newInstance能够确保返回的每个实例都与所有其他实例不同 遇到多个构造器参数时要考虑用构建器当构造器参数很多时，重叠构造器模式可行，但是当有许多参数的时候，客户端代码会很难写，并且难以阅读。如果读者想知道那些值是什么意思，必须很仔细的数着这些参数来一探究竟，更为可怕的是，一长串相同类型的参数会导致一些微妙的错误，如果客户端不小心颠倒了其中两个参数的顺序，编译器并不会报错，但是在程序运行的时候会出现错误，这种错误往往还比较难以发现。 遇到许多构造器参数的时候，还可以使用JavaBeans模式，在这种模式下，调用一个无参构造器来创建对象，然后调用setter方法来设置每个必要的参数。JavaBeans模式最大的问题就是阻止了把类做成不可变的可能，需要程序员付出额外的努力来确保它的线程安全。 对于多个构造器参数还有第三种方法，即Builder模式。我们先看代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758public class NutritionFacts &#123; private final int servingSize; private final int servings; private final int calories; private final int fat; private final int sodium; private final int carbonhydrate; public static class Builder &#123; // Required parameters private final int servingSize; private final int servings; // Optional parameters - initialized to default values private int calories = 0; private int fat = 0; private int carbonhydrate = 0; private int sodium = 0; public Builder(int servingSize, int servings) &#123; this.servingSize = servingSize; this.servings = servings; &#125; public Builder calories(int val) &#123; calories = val; return this; &#125; public Builder fat(int val) &#123; fat = val; return this; &#125; public Builder carbonhydrate(int val) &#123; carbonhydrate = val; return this; &#125; public Builder sodium(int val) &#123; sodium = val; return this; &#125; public NutritionFacts build() &#123; return new NutritionFacts(this); &#125; &#125; private NutritionFacts(Builder builder) &#123; servingSize = builder.servingSize; servings = builder.servings; calories = builder.calories; fat = builder.fat; sodium = builder.sodium; carbonhydrate = builer.carbonhydrate; &#125;&#125; 注意NutritionFacts是不可变的，下面是客户端代码： 1NutritionFacts cocaCola = new NutritionFacts.Builder(240, 8).calories(100).sodium(35).carbonhydrate(27).build(); 如果类的构造器或者静态工厂中具有多个参数，设计这种类时，Builder模式就是种不错的选择，特别是当大多数参数可选的时候。","tags":[{"name":"对象","slug":"对象","permalink":"https://glemontree.github.io/tags/对象/"}]},{"title":"[MyBatis] mybatis","date":"2017-11-02T03:30:32.000Z","path":"2017/11/02/[MyBatis] mybatis/","text":"动态sql if标签 根据查询条件来动态拼装sql语句，其格式如下： 1&lt;if test=&quot;&quot;&gt;&lt;/if&gt; 其中test表示判断表达式（使用OGNL），其从参数中取值进行判断，当然遇见特殊符号需要些转义字符，比如&amp;&amp;， 其在xml文件中无法识别，需要使用转义字符。看下面这个例子： 123456789101112131415161718192021&lt;select id=\"getEmpsByConditionIf\" resultType=\"com.glemontree.mybatis.bean.Employee\"&gt; select * from tbl_employee where &lt;!-- test：判断表达式 (OGNL) 从参数中取值进行判断 遇见特殊符号应该去写转义字符：比如&amp;&amp; --&gt; &lt;if test=\"id != null\"&gt; id = #&#123;id&#125; &lt;/if&gt; &lt;if test=\"lastName != null and lastName != ''\"&gt; and last_name like #&#123;lastName&#125; &lt;/if&gt; &lt;if test=\"email != null and email.trim() != ''\"&gt; and email = #&#123;email&#125; &lt;/if&gt; &lt;!-- ognl会进行字符串与数字自动转换 --&gt; &lt;if test=\"gender == 0 or gender == 1\"&gt; and gender = #&#123;gender&#125; &lt;/if&gt;&lt;/select&gt; 此时会根据传入参数的情况动态拼接sql语句，下面看下测试用例： 123456789101112131415@Testpublic void testDynamicSql() throws IOException &#123; SqlSessionFactory sqlSessionFactory = getSqlSessionFactory(); SqlSession openSession = sqlSessionFactory.openSession(); try &#123; EmployeeMapperDynamicSQL mapper = openSession.getMapper(EmployeeMapperDynamicSQL.class); Employee employee = new Employee(2, \"%e%\", \"jerry@gmail.com\", null); List&lt;Employee&gt; employees = mapper.getEmpsByConditionIf(employee); for (Employee emp : employees) &#123; System.out.println(emp); &#125; &#125; finally &#123; openSession.close(); &#125;&#125; 在上面的sql语句拼接中如果id为null的话，sql语句拼接会出现问题，有以下两种解决方法： 给where后面加上1=1，以后的条件都是and xxx，如下： 123456789101112131415161718192021&lt;select id=\"getEmpsByConditionIf\" resultType=\"com.glemontree.mybatis.bean.Employee\"&gt; select * from tbl_employee where 1 = 1 &lt;!-- test：判断表达式 (OGNL) 从参数中取值进行判断 遇见特殊符号应该去写转义字符：比如&amp;&amp; --&gt; &lt;if test=\"id != null\"&gt; and id = #&#123;id&#125; &lt;/if&gt; &lt;if test=\"lastName != null and lastName != ''\"&gt; and last_name like #&#123;lastName&#125; &lt;/if&gt; &lt;if test=\"email != null and email.trim() != ''\"&gt; and email = #&#123;email&#125; &lt;/if&gt; &lt;!-- ognl会进行字符串与数字自动转换 --&gt; &lt;if test=\"gender == 0 or gender == 1\"&gt; and gender = #&#123;gender&#125; &lt;/if&gt;&lt;/select&gt; mybatis使用where标签来将所有的查询条件包括在内，mybatis就会将where标签中拼装的sql多出来的and或者or去掉，where只会去掉第一个多出来的and或者or： 1234567891011121314151617181920212223&lt;select id=\"getEmpsByConditionIf\" resultType=\"com.glemontree.mybatis.bean.Employee\"&gt; select * from tbl_employee &lt;where&gt; &lt;!-- test：判断表达式 (OGNL) 从参数中取值进行判断 遇见特殊符号应该去写转义字符：比如&amp;&amp; --&gt; &lt;if test=\"id != null\"&gt; id = #&#123;id&#125; &lt;/if&gt; &lt;if test=\"lastName != null and lastName != ''\"&gt; and last_name like #&#123;lastName&#125; &lt;/if&gt; &lt;if test=\"email != null and email.trim() != ''\"&gt; and email = #&#123;email&#125; &lt;/if&gt; &lt;!-- ognl会进行字符串与数字自动转换 --&gt; &lt;if test=\"gender == 0 or gender == 1\"&gt; and gender = #&#123;gender&#125; &lt;/if&gt; &lt;/where&gt;&lt;/select&gt; trim标签 看下面这个例子： 12345678910111213141516171819202122232425&lt;select id=\"getEmpsByConditionTrim\" resultType=\"com.glemontree.mybatis.bean.Employee\"&gt; select * from tbl_employee &lt;!-- 后面多出的and 或者 or where标签不能解决 prefix：前缀 trim标签体中时整个字符串拼串后的结果，prefix给拼串后的整个字符串加一个前缀 prefixOverrides：前缀覆盖，去掉整个字符串前面多余的字符 suffix：后缀 给拼串后的整个字符串加一个后缀 suffixOverrides：后缀覆盖，去掉整个字符串后面多余的字符 --&gt; &lt;trim prefix=\"where\" prefixOverrides=\"\" suffix=\"\" suffixOverrides=\"and\" &gt; &lt;if test=\"id != null\"&gt; id = #&#123;id&#125; and &lt;/if&gt; &lt;if test=\"lastName != null and lastName != ''\"&gt; last_name like #&#123;lastName&#125; and &lt;/if&gt; &lt;if test=\"email != null and email.trim() != ''\"&gt; email = #&#123;email&#125; and &lt;/if&gt; &lt;!-- ognl会进行字符串与数字自动转换 --&gt; &lt;if test=\"gender == 0 or gender == 1\"&gt; gender = #&#123;gender&#125; &lt;/if&gt; &lt;/trim&gt;&lt;/select&gt; 在这种情况下，将and添加在每个if标签中语句的后面，此时如果gender为空的话，email语句后面会多出一个and，那么在执行查询的时候就会报错，此时可使用trim标签。 choose标签 其起到分支选择的作用，类型与switch-case。 12345678910111213141516171819&lt;select id=\"getEmpsByConditionChoose\" resultType=\"com.glemontree.mybatis.bean.Employee\"&gt; select * from tbl_employee &lt;where&gt; &lt;choose&gt; &lt;when test=\"id != null\"&gt; id = #&#123;id&#125; &lt;/when&gt; &lt;when test=\"lastName != null\"&gt; last_name like #&#123;lastName&#125; &lt;/when&gt; &lt;when test=\"email != null\"&gt; email = #&#123;email&#125; &lt;/when&gt; &lt;otherwise&gt; gender = 0 &lt;/otherwise&gt; &lt;/choose&gt; &lt;/where&gt;&lt;/select&gt; set标签 1234567891011121314151617&lt;update id=\"updateEmp\"&gt; update tbl_employee &lt;set&gt; &lt;if test=\"lastName != null\"&gt; last_name = #&#123;lastName&#125;, &lt;/if&gt; &lt;if test=\"email != null\"&gt; email = #&#123;email&#125;, &lt;/if&gt; &lt;if test=\"gender != null\"&gt; gender = #&#123;gender&#125; &lt;/if&gt; &lt;/set&gt; &lt;where&gt; id = #&#123;id&#125; &lt;/where&gt; &lt;/update&gt; 加上set标签后可以去掉多余的,。 foreach标签 foreach用作批量查询 1234567891011121314151617&lt;select id=\"getEmpsByConditionForeach\" resultType=\"com.glemontree.mybatis.bean.Employee\"&gt; select * from tbl_employee where id in &lt;!-- collection：指定要遍历的集合，list类型的参数会特殊处理封装在map中，map的key就叫list item：遍历出的元素赋给指定的变量 #&#123;变量名&#125;就能取出变量值，也就是当前遍历出的元素 open：遍历出所有结果拼接一个开始的字符 close：遍历出所有结果拼接一个结束的字符 index：遍历list时是索引，item就是当前值，遍历map时表示key，item就是map的值 --&gt; &lt;!-- separator是放在foreach中每个条目之间的 --&gt; &lt;foreach collection=\"ids\" item=\"item_id\" separator=\",\" open=\"(\" close=\")\"&gt; #&#123;item_id&#125; &lt;/foreach&gt;&lt;/select&gt; 测试代码如下： 1234List&lt;Employee&gt; list = mapper.getEmpsByConditionForeach(Arrays.asList(1, 2, 3, 4));for (Employee emp : list) &#123; System.out.println(emp);&#125; foreach用作批量保存 12345678&lt;!--MySQL下批量保存，可以foreach遍历，mysql支持values(),(),()语法--&gt;&lt;insert id=\"addEmps\"&gt; insert into tbl_employee(last_name, email, gender) values &lt;foreach collection=\"emps\" item=\"emp\" separator=\",\"&gt; (#&#123;emp.lastName&#125;, #&#123;emp.email&#125;, #&#123;emp.gender&#125;) &lt;/foreach&gt;&lt;/insert&gt; 同样的，这里的separator逗号是放在(#{emp.lastName}, #{emp.email}, #{emp.gender})条目之间的。其测试代码如下： 123456789101112131415@Testpublic void testBatchSave() throws IOException &#123; SqlSessionFactory sqlSessionFactory = getSqlSessionFactory(); SqlSession openSession = sqlSessionFactory.openSession(); try &#123; EmployeeMapperDynamicSQL mapper = openSession.getMapper(EmployeeMapperDynamicSQL.class); List&lt;Employee&gt; emps = new ArrayList&lt;Employee&gt;(); emps.add(new Employee(null, \"smith\", \"smith@gmail.com\", \"1\")); emps.add(new Employee(null, \"allen\", \"allen@gmail.com\", \"0\")); mapper.addEmps(emps); openSession.commit(); &#125; finally &#123; openSession.close(); &#125;&#125; 需要注意的，在执行增删改时不要忘记调用openSession.commit();。 这里还有另外一种写法： 1234567&lt;insert id=\"addEmps\"&gt; &lt;foreach collection=\"emps\" item=\"emp\" separator=\";\"&gt; insert into tbl_employee(last_name, email, gender) values (#&#123;emp.lastName&#125;, #&#123;emp.email&#125;, #&#123;emp.gender&#125;) &lt;/foreach&gt;&lt;/insert&gt; 这样写之后是让MySQL一次执行多条sql语句，需要让MySQL支持一次执行多条sql语句，在MySQL的配置中加入： 1jdbc.url=jdbc:mysql://localhost:3306/mybatis?allowMultiQueries=true 这种使用分号（;）分隔多个sql可以用于其他的批量操作（删除、修改）。 oracle数据库批量保存 oracle不支持使用values(),(),()，oracle下可以使用下面的语句插入一条记录： 1insert into employees(employee_id, last_name, email) values(employee_seq.nextval, 'test_01', 'test_01@gmail.com'); employee_seq.nextval用于获取下一个id号。 但是oracle不支持values(),(),()，在oracle下可以使用下面的这些批量方式： 多个insert放在begin - end之间 1234begin insert into employees(employee_id, last_name, email) values(employee_seq.nextval, 'test_01', 'test_01@gmail.com'); insert into employees(employee_id, last_name, email) values(employee_seq.nextval, 'test_02', 'test_02@gmail.com');end; 利用中间表 12345678insert into employees(employee_id, last_name, email) select employees_seq.nextval, lastName, email form ( select 'test_a_01' lastName, 'test_a_e01' email from dual union select 'test_a_02' lastName, 'test_a_e02' email from dual union select 'test_a_03' lastName, 'test_a_e03' email from dual ) 下面看下在mybatis中的实现： 123456789101112131415161718&lt;!--第一种批量方式--&gt;&lt;insert id=\"addEmps\" databaseId=\"oracle\"&gt; begin &lt;foreach collection=\"emps\" item=\"emp\"&gt; insert into employees(employee_id, last_name, email) values(employee_seq.nextval, #&#123;emp.lastName&#125;, #&#123;emp.email&#125;); &lt;/foreach&gt; end;&lt;/insert&gt;&lt;!--第二种批量方式--&gt;&lt;insert id=\"addEmps\" databaseId=\"oracle\"&gt; insert into employees(employee_id, last_name, email) select employees_seq.nextval, lastName, email form ( &lt;foreach collection=\"emps\" item=\"emp\" separator=\"union\"&gt; select #&#123;emp.lastName&#125; lastName, #&#123;emp.email&#125; email from dual &lt;/foreach&gt; )&lt;/insert&gt; 两个内置参数 两个内置参数分别为_parameter和_databaseId。 _parameter代表整个参数，如果是单个参数，_parameter就表示这个参数，如果是多个参数，参数会被封装为一个map，_parameter就是代表这个map。 _databaseId如果配置了DatabaseIdProvider标签，_databaseId就代表当前数据库的别名。 12345678910111213&lt;select id=\"getEmpsTestInnerParameter\" resultType=\"com.glemontree.mybatis.bean.Employee\"&gt; &lt;if test=\"_databaseId=='mysql'\"&gt; select * from tbl_employee &lt;!--无法直接通过传入的employee参数判断是否有参数，因为如果你通过#&#123;lastName&#125;!=null来判断，你已经默认了employee不为空，所以只能通过_parameter!=null来判断--&gt; &lt;if test=\"_parameter!=null\"&gt; where last_name=#&#123;lastName&#125; &lt;/if&gt; &lt;/if&gt; &lt;if test=\"_databaseId=='oracle'\"&gt; select * from employees &lt;/if&gt;&lt;/select&gt; bind标签 bind标签可以将OGNL表达式的值绑定到一个变量中方便后来引用这个变量的值： 1&lt;bind name=\"_lastName\" value=\"'%' + lastName + '%'\"/&gt; 这样在代码中传入参数后可以通过bind标签修改这个参数绑定到一个新的变量中以便在后面引用。 1234select * from tbl_employee &lt;if test=\"_parameter != null\"&gt; where last_name like #&#123;_lastName&#125;&lt;/if&gt; sql标签（与增删改查标签同级的标签） sql标签用来抽取可重用的sql片段，方便后面引用： 123&lt;sql id=\"insertColumn\"&gt; employee_id, last_name, email&lt;/sql&gt; 然后就可以在后面进行引用，原来我们是这样写的： 1insert into employees(employee_id, last_name, email) 现在我们可以这样写： 1234insert into employees(&lt;!--include 标签的作用就是引用外部定义的sql--&gt; &lt;include refid=\"insertColumn\"/&gt;) 同样的，sql标签里面也可以写动态标签，比如： 12345678&lt;sql id=\"insertColumn\"&gt; &lt;if test=\"_databaseId=='oracle'\"&gt; employee_id, last_name, email &lt;/if&gt; &lt;if test=\"_databaseId=='mysql'\"&gt; last_name, email, gender &lt;/if&gt;&lt;/sql&gt; 在实际的编程中： sql抽取：经常将要查询的列名或者插入用的列名抽取出来方便引用。 include来引用已经抽取的sql include还可以自定义一些property，sql标签内部就能使用自定义的属性：${prop}","tags":[{"name":"mybatis","slug":"mybatis","permalink":"https://glemontree.github.io/tags/mybatis/"}]},{"title":"[TCP/IP] 动态主机配置","date":"2017-11-02T03:27:58.000Z","path":"2017/11/02/[TCPIP] 动态主机配置/","text":"DHCP协议通过同DHCP服务器的交互，设备可以获得一个有效的IP地址，使得它可以在特定网络环境下运行。DHCP服务器一般有两个数据库，一个数据库维护静态分配的物理地址和IP地址地址绑定，它记录了特定客户端主机将被分配的特定IP地址，客户主机可以永久使用这些IP地址；第二个数据库维护了一个IP地址池，其中记录了可以动态分配的IP地址，当客户端主机请求临时主机分配时，如果客户段的物理地址在静态数据库中有对应的IP地址项，则服务器将该IP地址将被分配给客户段，如果没有对应项，则服务器在地址池中为客户段分配一个地址。 DHCP协议有着自身的报文组织形式，并且使用UDP进行报文的传输。LwIP中实现了DHCP客户端的功能，当该客户端启动时，它会自动向DHCP服务器（默认网关，192.168.1.1）发送地址分配请求，若得到正确的响应，它会将有效地址设置到网络接口结构的相关字段中。 测试程序要使用LwIP提供的DHCP功能，首先需要设置用户配置文件lwipopts.h，打开与DHCP功能相关的宏开关： 12#define LWIP_DHCP 1#define MEMP_NUM_SYS_TIMEOUT 6 LWIP_DHCP为1表示允许系统的DHCP功能，同时与DHCP功能相关的dns.c将会被编译；MEMP_NUM_SYS_TIMEOUT指明了编译器将为内核结构sys_timeo分配的内存池个数，默认值为3，DHCP模块需要使用两个定时器结构来实现定时操作，在无操作系统模拟层环境下运行时，用户需要周期性的调用DHCP的两个定时函数dhcp_coarse_tmr和dhcp_fine_tmr，它们的典型周期是60s和500ms。 使用了DHCP，用户就不必手动为网络接口分配IP地址了，因此需要对lwip_init_task进行修改： 12345678910111213141516// lwipdemo.c#include \"dhcp.h\" // DHCP相关的头文件#include \"includes.h\" // 操作系统相关的头文件struct netif rt18019_netif;void lwip_init_task(void) &#123; struct ip_addr ipaddr, netmask, gw; tcpip_init(NULL, NULL); // 初始化协议栈 IP4_ADDR(&amp;gw, 0, 0, 0, 0); IP4_ADDR(&amp;ipaddr, 0, 0, 0, 0); IP4_ADDR(&amp;netmask, 0, 0, 0, 0); // 初始化网络接口，注册回调函数 netif_add(&amp;rt18019_netif, &amp;ipaddr, &amp;netmask, &amp;gw, NULL, ethernetif_init, tcpip_input); netif_set_default(&amp;rt18019_netif); netif_set_up(&amp;re18019_netif); dhcp_start(&amp;rt18019_netif); / 启动DHCP客户端&#125; 函数dhcp_start将为系统启动一个DHCP客户端，该客户端基于UDP实现，函数会在内核中为客户端申请一个UDP控制块，并将控制块和DHCP服务器（默认网关，192.168.1.1）进行绑定。","tags":[{"name":"动态主机配置","slug":"动态主机配置","permalink":"https://glemontree.github.io/tags/动态主机配置/"}]},{"title":"[TCP/IP] TCP封包解包与大小端问题","date":"2017-11-02T03:26:19.000Z","path":"2017/11/02/[TCPIP] TCP封包解包与大小端问题/","text":"建立统一成小端，虽然网络字节序是大端，但是目前主流的设备也就是X86是小端的，那些大端的机器同时也支持小端，像ARM、POWERPC都是支持小端的； 字节序一般是对数字而言的，要处理数字字节序的问题也很简单，不要使用系统默认的数字读入或读取方式读取数据（因为这样采用的是默认的字节序），而是自己通过程序将数字拆成大端或小端的数据，这样就保证了统一的字节序； 字节序的本质问题就是两个字节以及以上的类型值的问题，网络传输数据的时候是二进制流，数据发送时是什么样，接收时还是什么样，如果在socket两端的机器大小端相同或者没有两个字节以上的数据（就像字符串里都是单个字节组成的数据，但是如果struct里面包含了多个字节的数据就需要转换了），网络字节序便没什么用，只有socket两端的机器大小端不一样，它们对于二进制数据比如0x1234的理解才不一样，所以需要调用hton*那一系列的函数进行相应的转换才能得到正确的数据； 对于socket来说，它只认识byte[]，socket负责把byte[]从源端运到目标端，至于byte[]怎么解析完全是业务层的事情； 为什么基于TCP的通讯程序需要进行封包和解包TCP是一个流协议，所谓流就是没有界限的一串数据，大家可以想想河里的流水，是连成一片的，其间是没有分界线的，但一般通讯程序开发是需要定义一个个相互独立的数据包的，比如用于登录的数据包，用于注销的数据包。由于TCP流的特性以及网络状况，在进行数据传输时会出现以下几种情况： 假设我们连续调用两次send分别发送两端数据data1和data2，在接收端有以下几种接收情况： 先接收到data1，然后接收到data2； 先接收到data1的部分数据，然后接收到data1余下的部分以及data2的全部； 先接收到了data1的全部数据和data2的部分数据，然后接收到了data2的余下数据； 一次性接收到了data1和data2的全部数据。 对于第一种情况正是我们所需要的，不再做讨论，对于第二、三、四种情况就是“粘包”，就需要我们把接收到的数据进行拆包，拆成一个个独立的数据包，为了拆包就必须在发送端进行封包。 注意：对于UDP来说不存在拆包的问题，因为UDP是个“数据包”协议，也就是两段数据之间是有界限的，在接收端要么接收到一个完整的一段数据要么接收不到数据，不会少接收也不会多接收。 粘包原因粘包可能会发生在发送端也可能会发生在接收端。 由Nagle算法造成的发送端的粘包：Nagle算法是一种改善网络传输效率的算法，当我们提交一段数据给TCP时，TCP并不会立即发送此段数据，而是等待一段时间，看看在等待期间是否还有要发送的数据，若有则会一次把这两段数据发送出去； 接收端接收不及时造成的接收端粘包：TCP会把接收到的数据存在自己的缓冲区中，然后通知应用层去读取数据，当应用层由于某些原因不能及时的把TCP的数据取出来，就会造成TCP缓冲区中存放了几段数据。 解决方法利用底层的缓冲区进行拆包。对于阻塞socket来说，我们可以利用一个循环来接收包头长度的数据，然后解析出代表包体长度的那个变量，再用一个循环来接收包体长度的数据。 12345678910111213141516171819char PackageHead[1024];char PackageContext[1024 * 20];int len;PACKAGE_HEAD* pPackageHead;while(false == m_bClose) &#123; memset(PackageHead, 0, sizeof(PACKAGE_HEAD)); len = m_TcpSock.ReceiveSize((char*)PackageHead, sizeof(PACKAGE_HEAD)); if (len == SOCKET_ERROR) &#123; break; &#125; if (len == 0) &#123; break; &#125; pPackageHead = (PACKAGE_HEAD*)PackageHead; memset(PackageContext, 0, sizeof(PackageContext)); if (pPackageHead-&gt;nDataLen &gt; 0) &#123; len = m_TcpSocket.ReceiveSize((char*)PackageContext, pPackageHead-&gt;nDataLen); &#125;&#125;","tags":[{"name":"封包 解包 大小端","slug":"封包-解包-大小端","permalink":"https://glemontree.github.io/tags/封包-解包-大小端/"}]},{"title":"[TCP/IP] 网络接口管理","date":"2017-11-02T03:24:48.000Z","path":"2017/11/02/[TCPIP] 网络接口管理/","text":"LwIP在逻辑上分为4个层次：链路层、网络层、传输层、应用层 LwIP协议栈内部使用了一个名为netif的网络接口结构来描述各种网络设备 LwIP为每个接口分配一个netif结构，用这个结构来描述每种接口的特性，如接口IP地址、接口状态等，同时在该结构中为每个接口注册对应的操作函数，如数据包输入函数、输出函数等。内核将所有网络接口的netif结构组织在一个叫做netif_list的链表上，当有IP数据包需要发送时，IP层会根据数据包的目的IP地址，在netif_list链表中选择一个最合适的网络接口，并调用其注册的数据包发送函数将数据包发送出去；当网卡接收到数据包时，其注册的数据包输入函数也会被调用，完成将数据包交给IP层的任务。 数据结构 netif.h 1234567891011121314151617181920212223242526272829303132#define NETIF_MAX_HWADDR_LEN 6U // 网络接口最大物理地址长度，这里定义为以太网网卡MAC地址的长度6// 下面几个宏为网络接口属性、状态相关的宏，主要用于描述netif中flags字段的各位#define NETIF_FLAG_UP 0x01U //网络接口是否已被上层使能#define NETIF_FLAG_BROADCAST 0x02U //网络接口是否支持广播#define NETIF_FLAG_POINTTOPOINT 0x04U //网络接口是否属于点到点连接#define NETIF_FLAG_DHCP 0x08U //网络接口是否支持DHCP功能#define NETIF_FLAG_LINK_UP 0x10U //网络接口的底层链路是否已经使能#define NETIF_FLAG_ETHARP 0x20U //网络接口是否支持ARP功能#define NETIF_FLAG_IGMP 0x40U //网络接口是否支持IGMPstruct netif &#123; struct netif* next; //指向下一个netif结构，在构成链表netif_list时使用 struct ip_addr ip_addr; //网络接口的IP地址 struct ip_addr netmask; //子网掩码 struct ip_addr gw; //网关地址 err_t (*input)(strcut pbuf* p, strut netif* inp); //该函数向IP层输入数据包 err_t (*output)(struct netif* netif, struct pbuf* p, struct ip_addr* ipaddr); // 该函数发送IP包 err_t (*linkoutput)(struct netif* netif, struct pbuf* p); // 该函数实现底层数据包发送 void* state; //该字段用户可以自由设置，例如用于指向一些底层设备相关的信息 u16_t mtu; //该接口允许的最大数据包长度 u8_t hwaddr_len; //该接口物理地址长度 u8_t hwaddr[NETIF_MAX_HWARRR_LEN]; //该接口的物理地址 u8_t flags; //该接口的状态、属性字段 char name[2]; //该接口的名字 u8_t num; //接口的编号 //在接口自输入使能或者有环回接口的情况下，下面的字段用于描述接口发送给自己的数据包 struct pbuf* loop_first; //指向发送给自己的数据包的第一个pbuf struct pbuf* loop_last; //指向发送给自己的数据包的最后一个pbuf&#125;; ​","tags":[{"name":"网络接口","slug":"网络接口","permalink":"https://glemontree.github.io/tags/网络接口/"}]},{"title":"[TCP/IP] 网际协议IP","date":"2017-11-02T03:23:02.000Z","path":"2017/11/02/[TCPIP] 网际协议IP/","text":"IP是整个TCP/IP协议的核心，TCP、UDP、ICMP、IGMP等协议都基于IP来传送协议数据，常见的广域网路由器就工作在IP层，它们负责将IP数据报从源主机送至目的主机。 网络相关知识 IP是一种不可靠的无连接数据报协议，它提供尽量最大努力交付服务，但是并不保证每个分组都能被正确送达，此外，IP不会对运载的数据进行差错校验和跟踪。 IP地址被分为A，B，C，D，E五类，在分类地址中，IP地址由网络号和主机号组成，网络号标识某个网络，主机号标识该网络内的某台主机，这两个部分的长度是可变的，主要取决于地址的类型：对于A类地址，第一个字节定义网络号，后三个字节定义主机号；对于B类地址，前两个字节定义网络号，后两个字节定义主机号；对于C类网络地址，前三个字节定义网络号，最后一个字节定义主机号；对于D类和E类地址，不进行主机号和网络号的划分，D类地址是多播（组播）地址，而E类地址保留未用。 网络地址：用来标识不同的网络，不指向具体的哪一个主机或设备，而是标识属于同一个网络的主机或网络设备的集合。当一个数据包到达一个网络时，该网络的路由器首先判断数据包的目的网络是否与本地网络号相匹配，如果两个地址不匹配，那么路由器将会根据合适的算法对数据包进行转发，只有两个地址相互匹配，路由器才会查找响应的主机号进行主机的匹配，最后将数据包发送到指定的主机。 子网编址：将网络进一步划分为子网的设计，允许多个物理网络共享一个网络前缀，但每个子网都有自己的子网地址。在子网编址中，将主机号再划分为一个子网号和主机号。 NAT（网络地址转换） 通常，企业内部使用的局域网路由器都是具有NAT功能的，具有NAT功能的路由器至少有一个内部端口和一个外部端口，内部端口是路由器为了与局域网内的用户通信而使用的，它使用一个内部专用的IP地址，例如常见的路由器内部IP地址为192.168.1.1，外部端口是路由器用来与外部网络通信用的，它通常具有一个有效的IP地址，例如一个有效的C类地址222.197.179.21。 当内部网络用户连接互联网时，NAT将用户的内部IP地址转换成一个外部公共IP地址，反之，数据从外部返回时，NAT将目的地址替换成用户的内部IP地址。 NAT的实现方式有很多种，使用最广泛的是端口多路复用，它基于TCP或UDP协议端口号以及IP地址来实现NAT功能。假如我们的局域网用户（专用地址是192.168.1.78）需要使用TCP协议与Internet中的一个Http服务器进行通信（IP地址为130.21.45.20，服务端口号是80），则它将发送一个包含源IP地址、源端口号、目的IP地址、目的端口号的IP分组到路由器处，这里假设这四个值为：（192.168.1.78, 1234, 130.21.45.20, 80），具有NAT功能的路由器会在内部维护一个NAT转换表，当路由器收到该分组时，会在表中为连接（192.168.1.78, 1234, 130.21.45.20, 80）分配一个路由器内部的NAT端口（假设为5678），另一方面，路由器在转发该分组时，会先更改分组中的源IP地址和端口号（分别改为路由器外部IP地址和NAT端口），然后才将数据包发送出去，所以被路由器转发出去的数据包中的信息为（222.178.197.21,5678,130.21.45.20,80），当服务器响应这个数据包时，它返回的数据报头部信息应为（130.21.45.20,80,222.178.197.21,5678），路由器接收到这个分组后，会在NAT转换表中查找NAT端口号为5678的连接，并把数据分组中的IP地址信号和端口信号更改为NAT转换表中记录的信息（130.21.45.20,80,192.168.1.78, 1234），最后把这个数据包返回给用户主机。 经过NAT两次简单的转换，局域网用户就实现了与外部网络的数据包交互，但是路由器应该为每个连接分配一个唯一的NAT端口号，并及时回收那些不用的端口号。 数据报 IP层的数据包，更正式的叫IP数据报或IP分组，在以太网中，IP数据报和ARP报文都是组装在以太网数据帧中发送的。 IP数据报的组织形式：通常有两部分组成，即IP首部和数据，首部常见长度为20个字节，IP数据报对数据的格式没有规定，所以IP数据报可以用来运输任意类型的数据。 IP数据报的组成： 版本号（4bit）：包含了创建数据报所使用的IP协议版本信息，对于IPv4，该值为4，对于IPv6，该值为6 首部长度（4bit）：这个长度以字为单位（4字节），对于不含任何选项字段的IP首部，该长度值为5（5*4=20字节），该字段最大值为15，所以最大IP首部长度为60字节 服务类型字段（8bit）：Type of Service, TOS，该字段主要用于描述当前IP数据报急需的服务类型，如最小延时、最大吞吐量、最高可靠性、最小费用等，路由器在转发数据报时可以根据这个字段的值来为数据报选择最合理的路由路径 总长度字段（16bit）：描述了整个IP数据报（IP首部和数据区）的总字节数，理论来说，IP数据报总长度最大可达65535字节，但在实际应用中，底层链路不允许这么大的数据包出现在链路中，在以太网中，以太网数据帧中的数据长度最长为1500字节（MTU），当一个很大的IP数据报需要发送时，IP层首先要检查底层接口设备的MTU，然后将大的数据报划分为几个分片包，最后分别递交给底层发送；另一方面，当以太网数据帧中的数据量较少时，例如小于46字节，底层会在以太网数据中加入一定的填充字节以满足长度要求 标识字段（16bit）：用于标识IP层发送出去的每一份IP数据报，没发送一份报文，则该值加1，数据包被分片时，该字段会被复制到每一个分片中，在接收端，会使用这个字段值来组装所有分片为一个完整的数据报 标志字段（3bit）：第一位保留，第二位为不分片位，当该位被置位时，IP数据报在发送或转发过程中，不能进行分片，在这种情况下，如果这个数据报由于太大而不能被放在任何物理网络中进行发送，那么这个数据报会被丢弃，当该位为0时，IP层将在需要的时候对数据包进行分片处理；第三位表示更多分片位，当该位被置1时，说明该分片不是某个数据报的最后一个分片，当该位为0时，表示该分片时某个数据报的最后一个分片，或者是某个数据报的唯一分片 片偏移字段（13bit）：当前分片所携带的数据在整个数据报中的相对位置（以8字节为单位），目的站必须收到从0偏移量到最高偏移量的所有分片，才能将分片重装为一个完整的数据报，每个分片在网络中单独传输，它们到达终点的顺序可能会各不相同，但在目的端，将按照分片的偏移量来顺序组织各个分片 生存时间（TTL）：描述IP数据报最多能被转发的次数，每经过一次转发，该值会减一，当该值为0时，路由器会丢弃该分组，同时一个ICMP差错报文会返回到源主机 协议字段（8bit）：描述数据报中的数据是来自于哪个上层协议，该位为1表示ICMP协议，为2表示IGMP协议，为6表示TCP协议，为17表示UDP协议 首部检验和（16bit）：针对IP首部进行校验，它并不关心内部数据在传输过程中出错与否，对于数据的校验是上层协议负责的，如ICMP、IGMP、TCP、UDP协议都会计算它们头部以及整个数据区的校验和 IP层输出 发送数据报 当传输层协议（TCP或UDP）要发送数据时，它们会将数据按照自己的格式组装在一个pbuf 中，并将payload指针指向协议首部，然后调用IP层的数据报发送函数ip_output 发送数据，ip_output的调用者需要为它提供数据报首部中的目的IP地址、源IP地址、协议类型、TTL等重要信息，ip_output的函数源代码如下，它主要的工作是根据目的IP地址为该数据报选择一个合适的网络接口，然后调用函数ip_output_if将数据报发送出去。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455/* 函数功能：被传输层协议调用以发送数据报，该函数查找网络接口并调用函数ip_output_if完成最终的发送工作 @p: 传输层协议需要发送的数据包pbuf，payload指针已指向协议首部 @src:源IP地址，若为NULL，则使用网络接口结构中保存的IP地址 @dest：目的IP地址，若为IP_HDRINCL，则表示p中已经有了填写好的IP数据报首部，且payload指针也已经指向了IP首部 @ttl：IP首部中的TTL字段 @tos：IP首部中的服务类型 @proto：IP首部中的协议类型值*/err_t ip_output(struct pbuf* p, struct ip_addr* src, struct ip_addr* dest, u8_t ttl, u8_t tos, u8_t proto) &#123; struct netif* netif; //根据目的IP地址为数据报寻找一个合适的网络接口 if ((netif = ip_route(dest)) == NULL) &#123; return ERR_RTE; &#125; return ip_output_if(p, src, dest, ttl, tos, proto, netif);&#125;err_t ip_output_if(struct pbuf* p, struct ip_addr* src, struct ip_addr* dest, u8_t ttl, u8_t tos, u8_t proto, struct netif* netif) &#123; struct ip_hdr* iphdr; static u16_t ip_id = 0; // 静态变量，记录IP数据报的编号（标识字段） if (dest != IP_HDRINCL) &#123; u16_t ip_hlen = IP_HLEN; // IP_HLEN为默认的IP首部长度，20 if (pbuf_header(p, IP_HLEN)) &#123; // 移动payload指针，指向pbuf中的IP首部 return ERR_BUF; &#125; iphdr = p-&gt;payload; // iphdr指向数据报首部 IPH_TTL_SET(iphdr, ttl); IPH_PROTO_SET(iphdr, proto); ip_addr_set(&amp;(iphdr-&gt;dest), dest); IPH_VHLTOS_SET(iphdr, 4, ip_hlen / 4, tos); // 填写版本号+首部长度+服务类型 IPH_LEN_SET(iphdr, htons(p-&gt;tot_len)); // 填写数据报总长度 IPH_OFFSET_SET(iphdr, 0); // 填写标志位和片偏移字段，都为0 IPH_ID_SET(iphdr, htons(ip_id)); // 填写标识字段 ++ip_id; // 数据报编号值加1 if (ip_addr_isany(src)) &#123;// 若src为空，则将源IP地址填写为网络接口的IP地址 ip_addr_set(&amp;(iphdr-&gt;src), &amp;(netif-&gt;ip_addr)); &#125; else &#123; ip_addr_set(&amp;(iphdr-&gt;src), src); &#125; IPH_CHKSUM_SET(iphdr, 0); // 清0校验和字段 IPH_CHKSUM_SET(iphdr, inet_chksum(iphdr, ip_hlen)); // 计算并填写首部校验和 &#125; else &#123; iphdr = p-&gt;payload; dest = &amp;(iphdr-&gt;dest); &#125; // 下面开始发送IP数据报，分为三种情况进行处理 if (ip_addr_cmp(dest, &amp;netif-&gt;ip_addr)) &#123; // 如果目的IP地址是本网卡的地址 return netif_loop_output(netif, p ,dest); &#125; if (netif-&gt;mtu &amp;&amp; (p-&gt;tot_len &gt; netif-&gt;mtu)) &#123; return ip_frag(p, netif, dest); &#125; return netif-&gt;output(netif, p, dest);&#125; 对于最后一种情况，会调用网卡结构注册的output函数来完成数据报的发送工作，这里这个函数应为etharp_output，它会解析MAC地址，组装以太网帧并发送。 ​ ​","tags":[{"name":"IP","slug":"IP","permalink":"https://glemontree.github.io/tags/IP/"}]},{"title":"[TCP/IP] 数据包管理","date":"2017-11-02T03:19:55.000Z","path":"2017/11/02/[TCPIP] 数据包管理/","text":"数据包处理过程链路层判断收到的数据包类型，提取数据包中的数据字段，记录主机物理地址信息；IP层根据数据包中的IP地址实现数据的存储和转发，根据数据包编号实现数据包的重装，提取数据包中关于传输层的信息，向上层递交数据包并记录递交结果；TCP使用数据包中的信息更新TCP状态机并向应用程序递交数据。 数据包管理在协议栈内核中移动的数据包有很多，比如：首先从网卡上接收的原始数据包，它可以是包含TCP报文的长达数百字节的数据包，也可以是仅有几十字节的ARP数据包；对于要发送的数据包，上层应用可能将各种各样的数据递交给LwIP内核发送，这些数据可能存在于应用进程管理的内存空间内，也可能存在于外部flash中。 数据在各层之间传递时，LwIP极力避免数据的拷贝工作，因为这样会耗费大量的时间和内存。 数据包结构pbuf 数据包管理机构采用数据结构pbuf来描述协议栈中使用的数据包： 123456789struct pbuf &#123; struct pbuf* next; // 构成pbuf链表时指向下一个pbuf结构 void* payload; // 数据指针，指向pbuf所激励的数据领域 u16_t tot_len; // 当前pbuf及其后续所有pbuf中包含的数据总长度 u16_t len; // 当前pbuf的数据的长度 u8_t type; // 当前pbuf的类型 u8_t flags; // 状态位 u16_t ref; // 指向该pbuf的指针数，即该pbuf被引用的次数&#125;; next：指向下一个pbuf结构，因为实际发送或接受的数据包可能很大，而每个pbuf能够管理的数据可能会有限，所以存在需要多个pbuf结构才能完全描述一个数据包的情况。 payload：数据指针，指向该pbuf管理的数据起始地址，这里数据起始地址可以是紧跟在pbuf结构之后的RAM空间中，也可能是ROM中的某个地址中，而决定这点的是当前pbuf的类型，即type字段的值。 len：当前pbuf中的有效数据长度，而tot_len表示当前pbuf和其后所有pbuf的有效数据的总长度，显然tot_len是len字段和pbuf链表中下一个pbuf的tot_len字段之和，pbuf链表中第一个pbuf的tot_len字段表示整个数据包的长度，而最后一个pbuf的tot_len字段必然同len字段相等。 type：表示pbuf的类型。 flags：通常设为0。 ref：pbuf被引用的次数，引用表示有其他指针指向当前buf，这里的指针可以是其他pbuf的next指针，也可以是其他形式的指针，初始化一个pbuf的时候，ref字段值被设置为1（因为该pbuf的地址一定会被返回给一个指针变量），当有其他指针指向该pbuf时，必须调用相关函数将pbuf的ref字段值增加。 pbuf的类型 有4中类型，分别是PBUF_RAM，PBUF_ROM，PBUF_REF和PBUF_POOL： 123456typedef enum &#123; PBUF_RAM, // pbuf描述的数据在pbuf结构之后的连续内存堆中 PBUF_ROM, // pbuf描述的数据在ROM中 PBUF_REF, // pbuf描述的数据在RAM中，但位置与pbuf结构所处位置无关 PBUF_POOL // pbuf结构与其描述的数据处于同一内存池中&#125;pbuf_type; 这4种类型中，PBUF_RAM类型的pbuf空间是通过内存堆分配得到的，使用最多，协议栈的待发送数据和应用程序的待发送数据一般都采用这个形式，申请PBUF_RAM类型的pbuf时，协议栈会在内存堆中分配相应空间，这里的大小包括如前所述的pbuf结构大小和相应缓冲区大小，它们在一片连续的内存堆存储区中。 1p = (struct pbuf*)mem_malloc(LWIP_MEM_ALIGN_SIZE(SIZEOF_STRUCT_PBUF + offset) + LWIP_MEM_ALIGN_SIZE(length)); 通过这种方式分配的pbuf空间其pbuf结构和相应数据在一片连续的内存区域中，但是需要注意的是payload并没有指向整个数据区的起始处，而是间隔了一定区域，这段区域就是上面的offset，它用来存储数据包的各种首部字段，如TCP报文首部、IP首部、以太网帧首部等。 PBUF_POOL类型和PBUF_RAM类型的pbuf很类似，但它的空间是通过内存池分配得到的，这种类型的pbuf可以在极短的时间内得到分配，在网卡接收数据包时，我们就使用了这种方式包装数据。在申请PBUF_POOL类型pbuf时，协议栈会在内存池MEMP_PBUF_POOL中选择一个或多个POOL，以满足用户空间大小的申请，源代码是通过下面一条语句来完成POOL申请的，如果用户发送的数据很长，那么系统会多次调用上面的语句，为用户分配多个POOL。 1p = memp_malloc(MEMP_PBUF_POOL); 数据包申请函数 数据包申请函数pbuf_alloc在系统中许多地方会用到，例如在网卡接收数据时会申请一个数据包，然后将网卡中的数据填入数据包中；发送数据包时，协议栈的某层中会申请一个pbuf，并将相应的数据装入到数据区域，同时协议相关的首部信息也会被填到pbuf的预留数据区域中。 数据包申请函数有两个重要的参数，一是想申请的数据包类型，这在上面已经有所介绍，而一个参数就是该数据包是在协议栈的哪一层被申请的，分配函数会根据层次的不同，在pbuf数据区域前为相关的协议预留出首部空间，也即offset。 LwIP定义了四个层次，当数据包申请时，所处的层次不同，会导致预留空间的offset值不同，层次的定义是通过一个枚举类型pbuf_layer来实现的： 12345678#define PBUF_TRANSPORT_HLEN 20 // TCP报文首部长度#define PBUF_IP_HLEN 20 // IP数据报首部长度typedef enum &#123; PBUF_TRANSPORT, // 传输层 PBUF_IP, // 网络层 PBUF_LINK, // 链路层 PBUF_RAW // 原始层，不预留任何空间&#125;pbuf_layer; pbuf_alloc函数的源码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859/* @layer: 指定该pbuf数据所处的层次，分配函数根据该值在pbuf数据区预留出首部空间 @length: 需要申请的数据区长度 @type: pbuf的类型*/struct pbuf* pbuf_alloc(pbuf_layer layer, u16_t length, pbuf_type type) &#123; struct pbuf *p, *q, *r; u16_t offset; // 预留首部空间的长度 s32_t rem_len; //还需要申请的数据空间长度 offset = 0; switch (layer) &#123; case PBUF_TRANSPORT: offset += PBUF_TRANSPORT_HLEN; // 若在传输层，则预留出TCP首部大小 case PBUF_IP: offset += PBUF_IP_HLEN; // 若在网络层或传输层，则还需留出IP首部大小 case PBUF_LINK: // 若在链路层或以上各层，则还需留出链路层首部 offset += PBUF_LINK_HLEN; // 以太网中，为以太网头部大小，即14字节 break; case PBUF_RAW: break; default: return NULL; &#125; switch (type) &#123; case PBUF_POOL: // 最麻烦，可能需要分配多个POOL p = memp_malloc(MEMP_PBUF_POOL); if (p == NULL) &#123; return NULL; &#125; p-&gt;type = type; p-&gt;next = NULL; p-&gt;payload = LWIP_MEM_ALIGN((void*)((u8_t*)p + (SIZEOF_STRUCT_PBUF + offset))); p-&gt;tot_len = length; p-&gt;len = LWIP_MIN(length, PBUF_POOL_BUFSIZE_ALIGNED - LWIP_MEM_ALIGN_SIZE(offset)); p-&gt;ref = 1; r = p; rem_len = length - p-&gt;len; while(rem_len &gt; 0) &#123; q = memp_alloc(MEMP_PBUF_POOL); if (q == NULL) &#123; pbuf_free(q); return NULL; &#125; q-&gt;type = type; q-&gt;flags = 0; q-&gt;next = NULL; r-&gt;next = q; q-&gt;tot_len = (u16_t)rem_len; q_len = LWIP_MIN((u16_t)rem_len, PBUF_POOL_BUFSIZE_ALIGNED); q-&gt;payload = (void*)((u8_t*)q + SIZEOF_STRUCT_PBUF); q-&gt;ref = 1; rem_len = q-&gt;len; r = q; &#125; break; case PBUF_RAM: p = (struct pbuf*)mem_alloc(LWIP_MEM_ALIGN_SIZE(SIZEOF_STRUCT_PBUF + offset) + LWIP_MEM_ALIGN_SIZE(length)); if (p == NULL) &#123; return NULL; &#125; ... &#125;&#125; ​","tags":[{"name":"数据包","slug":"数据包","permalink":"https://glemontree.github.io/tags/数据包/"}]},{"title":"[TCP/IP] 服务器程序示例","date":"2017-11-02T03:17:22.000Z","path":"2017/11/02/[TCPIP] 服务器程序示例/","text":"信号处理函数 signal函数每次设置的信号处理函数只能生效一次，每次在进程响应处理信号时，随即将信号处理函数恢复为默认处理方式，所以如果想多次相同方式处理某个信号，通常的做法是在响应函数开始时，再次调用signal设置 而对于sigaction函数，在信号处理程序调用时，系统建立的新信号屏蔽字会自动包括正被递送的信号，因此保证了在处理一个给定的信号时，如果这种信号再次发生，那么它会阻塞到对一个信号的处理结束为止；并且响应函数设置后会一直生效，不会重置 如果希望能用相同方式处理信号的多次出现，最好用sigaction，而如果信号只出现并处理一次，可以用signal TCP回射服务器程序：main函数123456789101112131415161718192021222324#include \"unp.h\"int main(int argc, char** argv) &#123; int listenfd, connfd; pid_t childpid; socklen_t clilen; struct sockaddr_in cliaddr, servaddr; listenfd = Socket(AF_INET, SOCK_STREAM, 0); bzero(&amp;servaddr, sizeof(servaddr)); servaddr.sin_family = AF_INET; servaddr.sin_addr.s_addr = htonl(INADDR_ANY); servaddr.sin_port = htons(SERV_PORT); Bind(listenfd, (SA*)&amp;servaddr, sizeof(servaddr)); Listen(listenfd, LISTENQ); for (; ;) &#123; clilen = sizeof(cliaddr); connfd = Accept(listenfd, (SA*)&amp;cliaddr, &amp;clilen); if ((childpid = Fork()) == 0) &#123; Close(listenfd); str_echo(connfd); exit(0); &#125; Close(connfd); &#125;&#125; 上述程序的流程如下： 创建套接字，在待捆绑到该TCP套接字的网际网套接字地址结构中填入通配地址（INADDR_ANY）和服务器的众所周知端口（SERV_PORT，9877），捆绑通配地址是告诉系统，要是系统是多宿主机，我们将接受目的地址为任何本地接口的连接 服务器阻塞于accept等待客户连接的完成 fork为每个客户派生一个处理它们的子进程，子进程关闭监听套接字，而父进程关闭连接套接字，子进程接着调用str_echo处理客户 TCP回射服务器程序：str_echo函数1234567891011121314#include \"unp.h\"void str_echo(int sockfd) &#123; ssize_t n; char buf[MAXLINE];again: while((n = read(sockfd, buf, MAXLINE)) &gt; 0) &#123; Writen(sockfd, buf, n); &#125; if (n &lt; 0 &amp;&amp; errno == EINTR) &#123; // EINTR：由于信号中断，没有读到任何数据 goto again; &#125; else if (n &lt; 0) &#123; err_sys(\"str_echo: read error\"); &#125;&#125; TCP回射客户程序：main函数12345678910111213141516#include \"unp.h\"int main(int argc, char** argv) &#123; int sockfd; struct sockaddr_in servaddr; if (argc != 2) &#123; err_quit(\"usage: tcpcli &lt;IPaddress&gt;\"); &#125; sockfd = Socket(AF_INET, SOCK_STREAM, 0); bzero(&amp;servaddr, sizeof(servaddr)); servaddr.sin_family = AF_INET; srevaddr.sin_port = htons(SERV_PORT); Inet_pton(AF_INET, argv[1], &amp;servaddr.sin_addr); Connect(sockfd, (SA*)&amp;servaddr, sizeof(servaddr)); str_cli(stdin, sockfd); exit(0);&#125; 上述程序的流程如下： 创建套接字，用服务器的IP地址和端口号装填一个网际网套接字地址结构 connect服务器，str_cli函数完成剩余部分的客户处理工作 TCP回射客户程序：str_cli函数1234567891011#include \" unp.h\"void str_cli(FILE* fp, int sockfd) &#123; char sendline[MAXLINE], recvline[MAXLINE]; while(Fgets(sendline, MAXLINE, fp) != NULL) &#123; Writen(sockfd, sendline, strlen(sendline)); if (Readline(sockfd, recvline, MAXLINE) == 0) &#123; err_quit(\"str_cli: server terminated prematurely\"); &#125; Fputs(recvline, stdout); &#125;&#125; 上述程序的流程如下： fgets读入一行文本，writen把该行发送给服务器 readline从服务器读入回射行，fputs把它写到标准输出 正常启动当使用ps命令检查进程的状态时，Linux在进程阻塞于accept或connect时，WCHAN列输出wait_for_connect，在进程阻塞于套接字输入或输出时，输出tcp_data_wait，在进程阻塞于终端I/O时，输出read_chan 正常终止 对于上面的客户端和服务器程序，当我们在客户端输入EOF字符时，fgets返回一个空指针，于是str_cli函数返回 当str_cli函数返回到客户的main函数时，main通过调用exit终止 进程终止处理的部分工作是关闭所有打开的描述符，因此客户打开的套接字由内核关闭，这导致客户TCP发送一个FIN给服务器，服务器TCP则以ACK响应，这就是TCP连接终止序列的前半部分，至此，服务器套接字处于CLOSE_WAIT状态，客户套接字处于FIN_WAIT_2状态 当服务器TCP收到FIN时，服务器子进程阻塞于readline调用，于是readline返回0，这导致str_echo函数返回服务器子进程的main函数 服务器子进程通过调用exit来终止 服务器子进程中打开的所有描述符随之关闭，由子进程来关闭已连接套接字会引发TCP连接终止序列的最后两个分节：一个从服务器到客户的FIN和一个从客户到服务器的ACK，至此，连接完全终止，客户套接字进入TIME_WAIT状态。 在服务器子进程终止时，给父进程发送一个SIGCHLD信号 POSIX信号处理信号可以由一个进程发给另一个进程，也可以由内核发给某个进程。我们可以同调用sigaction函数来设定一个信号的处置。 可以提供一个函数，只要在特定信号发生时它就被调用，这种行为成为捕获信号，有两个信号不能被捕获，分别是SIGKILL和SIGSTOP 可以把某个信号的处置设置为SIG_IGN来忽略它，SIGKILL和SIGSTOP两个信号不能被忽略 可以将某个信号的处置设置为SIG_DFL来启用它的默认设置 建立信号处理的POSIX方法是调用sigaction函数，可以像下面这样定义： 1234567891011121314151617181920#include \"unp.h\"Sigfunc* signal(int signo, Sigfunc* func) &#123; struct sigaction act, oact; act.sa_handler = func; sigemptyset(&amp;act.sa_mask); act.sa_flags = 0; if (signo == SIGALRM) &#123;#ifdef SA_INTERRUPT act.sa_flags |= SA_INTERRUPT;#endif &#125; else &#123;#ifdef SA_RESTART act.sa_flags |= SA_RESTART;#endif &#125; if (sigaction(signo, &amp;act, &amp;oact) &lt; 0) &#123; return (SIR_ERR); &#125; return oact.sa_handler;&#125; 用typedef 简化函数模型 函数signal的正常函数原型为: 1void (*signal(int signo, void (func)(int)))(int); 我们定义如下的Sigfunc函数，这样signal的函数原型变为： 12typedef void Sigfunc(int);Sigfunc* signal(int, Sigfunc* func); typedef定义函数类型和函数指针 typedef定义函数指针类型： 1typedef int (*fp_t)(char c); 需要注意的是函数名本身就是一个指针，所以函数名和fp_t之间可以相互赋值 typedef定义函数类型 1typedef int fp_t(char); 此时不能直接将函数名赋值给fp_t，而只能是赋值个fp_t*。 对于上面的程序段解释如下： 设置处理函数： sigaction结构的sa_handler成员被置为func参数。 设置处理函数的信号掩码： POSIX允许指定一组信号，它们在信号处理函数被调用时被阻塞，任何阻塞的信号都不能递交给进程，把sa_mask成员设置为空集，意味着在该信号处理函数运行期间，不阻塞额外的信号 SA_RESTART标志 SA_RESTART表示由此信号中断的系统调用会自动重启，而如果设置为SA_INTERRUPT，则表示由此信号中断的系统调用不会自动重启 处理SIGCHLD信号设置僵死状态的目的是维护子进程的信息，以便父进程在以后某个时候获取，这些信息包括子进程的进程ID、终止状态以及资源利用时间（CPU时间、内存使用量等）。如果一个进程终止，而该进程所有子进程处于僵死状态，那么它的所有僵死子进程的父进程ID被重置为1（init进程），继承这些子进程的init进程将清理它们（init进程将wait它们，从而去除它们的僵死状态）。 处理僵死进程 无论何时fork子进程都得wait它们，以防它们变成僵死进程，可以建立一个俘获SIGCHLD信号的信号处理函数，在函数体中调用wait。 1234567void sig_chld(int signo) &#123; pid_t pid; int stat; pid = wait(&amp;stat); printf(\"child %d terminated\\n\", pid); return;&#125; 处理被中断的系统调用 当阻塞于某个慢系统调用的一个进程捕获某个信号且相应信号处理函数返回时，该系统调用可能返回一个EINTR错误，有些内核自动重启某些被中断的系统调用。因此，为了便于移植，当我们编写捕获信号的程序时，我们必须对慢系统调用返回EINTR有所准备。 为了处理被中断的accept，可以将accept的调用放入for循环中： 12345678910for (; ;) &#123; clilen = sizeof(chiaddr); if ((connfd = accept(listenfd, (SA*)&amp;cliaddr, &amp;clilen)) &lt; 0) &#123; if (errno == EINTR) &#123; continue; &#125; else &#123; err_sys(\"accept error\"); &#125; &#125;&#125; 这段代码所做的事情就是自己重启被中断的系统调用，对于accept、read、write、select和open之类函数时合适的，不过有一个函数不能重启：connect。如果该函数返回EINTR，不能再次调用它，否则立即返回一个错误。当connect被一个捕获的信号中断而且不自动重启时，我们必须调用select来等待连接完成。 wait和waitpid这两个函数的原型如下; 123#include &lt;sys/wait.h&gt;pid_t wait(int* staloc);pid_t waitpid(pid_t pid, int* staloc, int options); 如果调用wait的进程没有已终止的子进程，不过有一个或多个子进程仍在执行，那么wait将阻塞到现有子进程第一个终止为止。 waitpid函数就等待哪个进程以及是否阻塞给了我们更多的控制，pid参数允许我们指定想等待的进程ID，值-1表示等待第一个终止的子进程；options参数允许我们制定附加选项，最常用的选项是WNOHANG，告知内核在没有已终止子进程时不要阻塞。","tags":[{"name":"服务器","slug":"服务器","permalink":"https://glemontree.github.io/tags/服务器/"}]},{"title":"[TCP/IP] 基本TCP套接字编程","date":"2017-11-02T03:15:22.000Z","path":"2017/11/02/[TCPIP] 基本TCP套接字编程/","text":"socket函数12#include &lt;sys/socket.h&gt;int socket(int family, int type, int protocol); socket函数在成功时返回一个小的非负整数值，称为套接字描述符，简称sockfd。 connect函数12#include &lt;sys/socket.h&gt;int connect(int sockfd, const struct sockaddr* servaddr, socklen_t addrlen); sockfd是socket函数返回的套接字描述符，第二个、第三个参数分别是一个指向套接字地址结构的指针和该结构的大小，套接字地址结构必须含有服务器的IP地址和端口号。 客户在调用函数connect前不必非得调用bind函数，如果需要的话内核会确定源IP地址，并选择一个临时端口作为源端口。 如果是TCP套接字，调用connect函数将会激发TCP的三路握手过程，connect出错返回可能有以下几种情况： 若TCP客户没有收到SYN分节的响应，则返回ETIMEDOUT错误，举例来说，调用connect函数时，内核发送一个SYN，若无响应则等待6S后再发送一个，若仍无响应则等待24S后再发送一个。若总共等了75S后仍未收到响应则返回本错误。 若对客户的SYN的响应是RST（表示复位），则表明服务器主机在我们指定的端口上没有进程在等待与之连接（例如服务器进程也许没在运行），客户一接收到RST就马上返回ECONNREFUSED错误。 RST是TCP在发生错误时发送的一种TCP分节，产生RST的三个条件是：目的地为某端口的SYN到达，然而该端口上没有正在监听的服务器；TCP想取消一个已有连接；TCP接收到一个根本不存在的连接上的分节。 若客户发出的SYN在中间的某个路由器上引发了一个”destination unreachable”的ICMP错误，则认为是一种软错误，客户主机内核保存该消息，并按第一种情况中所述的时间间隔继续发送SYN，若在某个规定的时间后仍未收到响应，则把保存的消息（ICMP消息）作为EHOSTUNREACH或ENETUNREACH错误返回给进程。 connect函数导致当前套接字从CLOSED状态（该套接字自从由socket函数创建以来一直所处的状态）转移到SYN_SENT状态，若成功则再转移到ESTABLISHED状态，若connect失败则该套接字不再可用，必须关闭，不能对这样的套接字再次调用connect函数。 bind函数bind函数是把一个本地协议地址赋予一个套接字，对于网际协议，协议地址是32位的IPV4地址或128位的IPV6地址与16位的TCP或UDP端口号的组合。 12#include &lt;sys/socket.h&gt;int bind(int sockfd, const struct sockaddr* myaddr, socklen_t addrlen); 第二个参数是一个指向特定于协议的地址结构的指针，第三个参数是该地址结构的长度，对于TCP， 调用bind函数可以指定一个端口号，或指定一个IP地址，也可以两者都指定，还可以都不指定。 服务器在启动时捆绑它们的众所周知端口，如果一个TCP客户或服务器未曾调用bind捆绑一个端口，当调用connect或listen时，内核就要为相应的套接字选择一个临时端口，让内核来选择临时端口对于TCP客户来说是正常的，除非应用需要一个预留端口；然而对于TCP服务器来说却极为罕见，因为服务器是通过它们的众所周知端口被大家认识的。 进程可以把一个特定的IP地址捆绑到它的套接字上，不过这个IP地址必须属于其所在主机的网络接口之一。对于TCP客户，这就为在该套接字上发送的IP数据报指派了源IP地址，而对于TCP服务器，这就限定了该套接字只接收那些目的地为这个IP地址的客户连接。 如果指定端口号为0，那么内核在bind被调用时选择一临时端口，然而如果指定IP地址为通配地址，那么内核将等到套接字已连接（TCP）或已在套接字上发出数据报（UDP）时才选择一个本地IP地址。 如果让内核来为套接字选择一个临时端口号，需要注意的是函数bind并不返回所选择的值，为了得到内核所选择的这个临时端口值，必须调用函数getsockname来返回协议地址。 listen函数listen函数仅有TCP服务器调用： 当socket函数创建一个套接字时，它被假设为一个主动套接字，也就是说，它是一个将调用connect发起连接的客服套接字，listen函数把一个未连接的套接字转换成一个被动套接字，指示内核应接受指向该套接字的连接请求，调用listen函数将导致套接字从CLOSED状态转换到LISTEN状态。 本函数的第二个参数规定了内核应该为相应套接字排队的最大连接个数： 12#include &lt;sys/socket.h&gt;int listen(int sockfd, int backlog); 本函数通常应该在调用socket和bind这两个函数之后，并在调用accept函数之前调用。 内核为任何一个给定的监听套接字维护两个队列： 未完成连接队列，每个这样的SYN分节对应其中一项：已有某个客户发出并到达服务器，而服务器正在等待完成相应的TCP三路握手过程。这些套接字处于SYN_RCVD状态 已完成连接队列，每个已完成TCP三路握手过程的客户对应其中一项，这些套接字处于ESTABLISHED状态。 每当在未完成连接队列中创建一项时，来自监听套接字的参数就复制到即将建立的连接中，连接的创建机制是完全自动的，无需服务器进程插手。 当来自客户的SYN到达时，TCP在未完成队列中创建了一个新项，然后响应以三路握手的第二个分节：服务器的SYN响应，其中捎带对客户SYN的ACK，这一项一直保存在未完成连接队列中，直到三路握手的第三个分节（客户对服务器SYN的ACK）到达或者该项超时为止。如果三路握手正常完成，该项就从未完成连接队列移到已完成连接队列的队尾。当进程调用accept时，已完成连接队列的队头项将返回给进程，或者如果该队列为空，那么进程将被投入睡眠，指导TCP在该队列中放入一项才唤醒它。 accept函数accept函数由TCP服务器调用，用于从已完成连接队列队头返回下一个已完成连接，如果已完成连接队列为空，那么进程被投入睡眠。 12#include &lt;sys/socket.h&gt;int accept(int sockfd, struct sockaddr* cliaddr, socklen_t* addrlen); 其中参数cliaddr和addrlen用来返回已连接的对端进程（客户）的协议地址。如果accept成功，那么其返回值是由内核自动生成的一个全新描述符，代表与所返回客户的TCP连接。 需要注意的是和accept函数的套接字描述符有两个，分别是监听套接字和已连接套接字，其中监听套接字由socket函数创建，随后用作bind和linten的第一个参数的描述符；另一个套接字为已连接套接字，为accept函数的返回值。 一个服务器通常仅仅创建一个监听套接字，它在该服务器的生命期内一直存在，内核为每个由服务器进程接受的客户连接创建一个已连接套接字，当服务器完成对某个给定客户的服务时，相应的已连接套接字就被关闭。 fork和exec函数12#include &lt;unistd.h&gt;pid_t fork(void); fork()函数调用一次，但是却返回两次，它在调用进程（父进程）中返回一次，返回值是新派生进程（子进程）的进程ID号，在子进程中又返回一次，返回值是0。 父进程中调用fork之前打开的所有描述符在fork返回之后由子进程共享。父进程调用accept之后调用fork，所接受的已连接套接字随后就在父进程和子进程之间共享。通常情况下，子进程接着读写这个已连接套接字，父进程则关闭这个已连接套接字。 关于文件描述符的继承 通过fork创建子进程时，子进程继承父进程环境和上下文的大部分内容的拷贝，其中就包括文件描述符表。 对于父进程在fork之前打开的文件来说，子进程都会继承，与父进程共享相同的文件偏移量。系统文件表位于系统空间中，不会被fork复制，但是系统文件表中的条目会保存指向它的文件描述符表的计数，fork时需要对这个计数进行维护，以体现子进程子进程对应的新的文件描述符表也指向它。程序关闭文件时，也就是将系统文件表条目内部的计数减一，当计数值减为0时，才将其删除。 并发服务器Unix中编写并发服务器程序最简单的办法就是fork一个子进程来服务每个客户。举个例子如下： 1234567891011121314pid_t pid;int listenfd, connfd;listenfd = Socket(...);Bind(listenfd, ...);for (; :) &#123; connfd = Accept(listenfd, ...); if ((pid = Fork()) == 0) &#123; Close(listenfd); // 子进程关闭监听socket doit(connfd); // 处理请求 Close(connfd); // 关闭连接socket exit(0); // 子进程退出 &#125; Close(connfd); // 父进程关闭连接socket&#125; 对于上面的程序，也许你会感到困惑，明明父进程中调用了close函数关闭了connfd，为什么在子进程中还可以使用connfd。通过前面的学习我们知道当对一个TCP套接字调用close函数后会导致发送一个FIN，随后是正常的TCP连接终止序列，那么为什么上面的程序中父进程对connfd调用close没有终止它与客户的连接呢？ 其实每个文件或套接字都有一个引用计数，引用计数在文件表项中维护，它是当前打开着的引用该文件或套接字的描述符的个数。在上面的程序中，socket返回后与listenfd关联的文件表项的引用计数值为1，accept返回后与connfd关联的文件表项的引用计数值也为1。然而fork返回后，这两个描述符就在父进程和子进程之间共享（被复制），因此与这两个套接字相关联的文件表项各自的访问计数值均为2，这么一来，当父进程关闭connfd后，它只是把响应的引用计数值从2减为1，该套接字真正的清理和资源释放要等到起引用计数值到达0时才发生。 close函数close函数用来关闭套接字，并终止TCP连接，其函数原型如下： 12#include &lt;unistd.h&gt;int close(int sockfd); close一个TCP套接字的默认行为是把该套接字标记为已关闭，然后立即返回到调用进程，该套接字描述符不能再由调用进程使用，然而TCP将尝试发送已排队等待发送到对端的任何数据，发送完毕后发生的是正常的TCP连接终止序列。 在前面我们说过，并发服务器中父进程关闭已连接套接字只是导致相应描述符的引用计数值减1，既然引用计数值仍大于0，这个close调用并不引发TCP的四分组连接终止序列。 getsockname和getpeername函数这两个函数或者返回与某个套接字关联的本地协议地址，或者返回与某个套接字关联的外地协议地址。 123#include &lt;sys/socket.h&gt;int getsockname(int sockfd, struct sockaddr* loacladdr, socklen_t* addrlen);int getpeername(int sockfd, struct sockaddr* peeraddr, socklen_t* addrlen); 在一个没有调用bind的TCP客户上，connect成功返回后，getsockname用于返回由内核赋予该链接的本地IP和本地端口号 在以端口号0调用bind后，getsockname用于返回由内核赋予的本地端口号 getsockname可用于获取某个套接字的地址族 在一个以通配IP地址调用bind的服务器上，与某个客户的连接一旦建立（accept成功返回），getsockname就可以用于返回由内核赋予该链接的本地IP地址，在这样的调用中，套接字描述符参数必须是已连接套接字的描述符，而不是监听套接字的描述符","tags":[{"name":"TCP","slug":"TCP","permalink":"https://glemontree.github.io/tags/TCP/"}]},{"title":"[Struts2] EL表达式","date":"2017-11-01T07:33:19.000Z","path":"2017/11/01/[Struts2] EL表达式/","text":"EL表达式语法结构 ${expression} EL存取变量 EL存取变量数据的方法很简单，例如：${username}，它的意思是取出某一范围中名称为username的变量。如果没有指定哪一个范围的username，那么它会依序从Page、Request、Seesion、Application范围进行查找。 假设途中找到username，则直接回传，不再继续查找下去，如果所有范围内均没有查到，则回传null。 属性范围在EL中的名称： | 属性名称 | 属性范围在EL中的名称 || ———– | —————- || Page | PageScope || Request | RequestScope || Session | SessionScope || Application | ApplicationScope | EL表达式用${}表示，可用在所有的HEML和JSP标签中，作用是代替JSP页面中复杂的JAVA代码 EL表达式可操作常亮、变量和隐式对象，最常用的隐式对象有${param}和${paramValues}，${param}表示返回请求参数中单个字符串的值，${paramValues}表示返回请求参数的一组值 pageScope表示页面范围的变量，requestScope表示请求对象的变量，sessionScope表示会话范围内的变量，applicationScope表示应用范围的变量 &lt;%@ page isELIgnored=&quot;true&quot;%&gt;表示是否禁用EL语言，TRUE表示禁止，FALSE表示不禁止，JSP2.0中默认启用EL语言 与范围有关的EL隐含对象包含以下四个：pageScope、requestScope、sessionScope和applicationScope，它们基本上就和JSP的pageContext、request、session以及application一样，在EL中，这四个隐含对象只能用来取得范围属性值，即getAttribute(String name)，却不能取得其他相关信息，例如：我们要取得session中存储的一个属性名为username的值，可以使用session.getAttribute(&quot;username&quot;)方法取得，在EL中则可以通过${sessionScope.username}取得。 与输入有关的隐含对象有两个：param和paramValues，它们是EL中比较特别的隐含对象，例如我们要取得用户的请求参数时，可以利用下面的办法： 12request.getParameter(String name);request.getParameterValues(String name); 在EL中可以使用param和paramValues两者来取得数据： 12$&#123;param.name&#125;$&#123;paramValues.name&#125; ​","tags":[{"name":"EL表达式","slug":"EL表达式","permalink":"https://glemontree.github.io/tags/EL表达式/"}]},{"title":"[html] html","date":"2017-11-01T07:28:37.000Z","path":"2017/11/01/[html] html/","text":"一、HTML简介HTML的全称为Hypertext Markup Language，中文意思是超文本标签语言，是一种用来制作超文本文档的简单标签语言，其主要应用就是对网页内容的排版。 二、HTML基本组成所谓超文本是因为其可以加入图片、声音、动画、影视等非单一文本内容。一个简单的HTML文档如下所示： 12345678&lt;HTML&gt; &lt;HEAD&gt; &lt;TITLE&gt;第一个HTML文档：Hello&lt;/TITLE&gt; &lt;/HEAD&gt; &lt;BODY&gt; 第一个HTML文档 &lt;/BODY&gt;&lt;/HTML&gt; &lt;HTML&gt;&lt;/HTML&gt; &lt;HTML&gt;标签用来标识HTML文档的开始，而&lt;/HTML&gt;标签用来标识HTML文档的结束。 &lt;HEAD&gt;&lt;/HEAD&gt; HTML文档开始后，首先遇到的就是该文档的开头部分，其用&lt;HEAD&gt;和&lt;/HEAD&gt;标签来标识。在该标签中可以使用&lt;title&gt;&lt;/title&gt;以及&lt;script&gt;&lt;/script&gt;等标签，用来描述HTML的相关信息。 &lt;BODY&gt;&lt;/BODY&gt; HTML文档的开头部分结束后，就进入文档的主体部分，用&lt;BODY&gt;和&lt;/BODY&gt;标签来标识，在此标签对之间可以使用&lt;p&gt;&lt;h1&gt;&lt;br&gt;等标签，用来描述浏览器中显示出来的内容，同时&lt;BODY&gt;标签还可以有以下属性： Bgcolor：设置背景颜色 Text：设置文本的颜色 Link：设置链接的颜色 Vlink：设置已使用的链接的颜色 Alink：设置被单击的链接的颜色 &lt;title&gt;&lt;/title&gt; 在使用&lt;HEAD&gt;和&lt;/HEAD&gt;标签时使用，用来修改浏览器窗口标题栏上的文本信息。 三、HTML基本标签 &lt;p&gt;&lt;/p&gt; &lt;p&gt;&lt;/p&gt;用来创建一个段落，在此标签之间添加的文本，将按照段落的格式显示在浏览器中，另外，该标签还可以使用align属性来说明对齐方式，属性值可以是left、center和right。 &lt;p&gt;标签标识段落的开始，&lt;/p&gt;标识段落的结束，是可以省略的。 &lt;br&gt; &lt;br&gt;没有结束标签，用来创建一个回车换行，若将&lt;br&gt;放在&lt;p&gt;&lt;/p&gt;外边，将创建一个大的回车换行，若放在&lt;p&gt;&lt;/p&gt;里则创建一个小的回车换行。 &lt;div&gt;&lt;/div&gt;、&lt;span&gt;&lt;/span&gt; &lt;div&gt;&lt;/div&gt;用于文档分节，也用于格式化表，此标签对的用法和&lt;p&gt;&lt;/p&gt;非常类似。 &lt;span&gt;&lt;/span&gt;标签用于在行内控制特定内容的显示，如果要为一行内容的某几个字设置特殊的格式，可以使用该标签将这几个字包围起来，然后设置格式。 &lt;a&gt;&lt;/a&gt; 该标签主要用于实现页面的联系和转换，即当用户点击超级链接时就会进入链接中指定的文档或文件（图形、音频、视频）。其格式如下： 1&lt;a href=链接目标的位置&gt;链接的名称&lt;/a&gt; 在上述定义中链接名称是指向链接目标的连接指针，可以是文字或图片，而链接的目标位置可以使用URL指定，如果连接目标的网页位于同一站点下，可以使用相对URL，如果链接目标的网页位于其他站点，需要使用绝对URL，单击链接的名称就会跳转到相应链接目标的网页。 &lt;img&gt; 使用img标签可以在网页中加入图像，其具有以下一些属性： src：指定图形文件的文件路径和文件名 alt：当鼠标移动到图像上时显示的文本，即在浏览器还没完全读入图像时，在图像位置上显示的备用文字 Height和width：决定图像的高度和宽度，以像素为单位 border：决定边框线的宽度，0表示无边框 在使用src属性时，如果图片pic.gif放在HTML文档的同一个目录下，则可以将代码写成&lt;img src=&quot;pic.gif&quot;&gt;；如果图片放在当前HTML文档所在目录的一个子目录（子目录名为images），则代码写成&lt;img src=&quot;images/pic.gif&quot;&gt;；如果图片pic.gif挡在当前HTML文档所在目录的上一级目录（根目录下只有一个文件夹名为Web），则代码写成&lt;img src=&quot;../Web/pic.gif&quot;&gt;。 &lt;table&gt;&lt;/table&gt; 用于创建表格，具有以下一些属性： bgcolor：设置表格的背景色 border：设置边框的宽度，其默认值为0 bordercolor：设置边框颜色 bordercolorlight：设置边框亮部分的颜色 bordercolordark：设置边框暗部分的颜色 cellspacing：设置表格格子之间空间的大小 cellpadding：设置表格格子边框与其内部内容之间空间的大小 width：设置表格的宽度 &lt;tr&gt;&lt;/tr&gt;&lt;td&gt;&lt;/td&gt;&lt;th&gt;&lt;/th&gt; &lt;tr&gt;&lt;/tr&gt;标签用于设置表格的一行，具有以下的属性： align：设置单元格中文字的水平方向的对齐方式 valign：设置单元格中文字的垂直方向的对齐方式 &lt;td&gt;&lt;/td&gt;标签用于设置表格中除了标题行中单元格的文字格式： clospan：可以设置跨多列的单元格 rowspan：可以设置跨多行的单元格 &lt;th&gt;&lt;/th&gt;标签用于设置表格标题行中单元格的文字格式，通常默认的格式是黑体居中。 框架标签 框架的标签为Frame，它可以用来向浏览器窗口中装载多个HTML文件，即每个HTML文件占据一个框架，多个框架可以同时显示在一个浏览器窗口中，它们组成了一个最大的框架，即一个包含多个HTML文档的HTML文件，常用的方法是在一个框架中放置目录，然后将HTML文件显示在另一个框架中。 见的比较少，就先不介绍了，等用到的时候再去学习。 表单标签 表单是用来输入信息的区域，它是使网页具有交互性能的关键，利用表单可以接收用户输入，以便向服务器传送，服务器端接收并处理这些信息，然后动态产生网页。 文本框：分为单行文本框和多行文本框，密码框可以认为是一种特殊的文本框 单行文本框：&lt;input type=text name=控件名称 value=传出值&gt; 密码文本框：&lt;input type=password name=控件名称 value=传出值&gt; 多行文本框：&lt;textarea row=行数 cols=列数 name=控件名称&gt;&lt;/textarea&gt; 按钮 按钮有三种类型，分别是提交按钮、重置按钮和普通按钮。 提交按钮：&lt;input type=submit name=控件名称 value=显示值&gt; 重置按钮：&lt;input type=reset name=控件名称 value=显示值&gt; 普通按钮：&lt;input type=button name=控件名称 value=显示值&gt; 单选按钮 一组单选按钮只能有一个单选按钮被选中，同一组内的多个单选按钮必须使用一个名称。 1&lt;input type=radio name=控件名称 value=传出值&gt; 复选框 可以有多项被选中，格式如下： &lt;input type=checkbox name=控件名称 value=传出值&gt; 下拉菜单 12345&lt;select name=控件名称 size=显示项数&gt; &lt;option&gt;选项1&lt;/option&gt; &lt;option&gt;选项2&lt;/option&gt; &lt;option&gt;选项3&lt;/option&gt;&lt;/select&gt; ​ ​ ​ ​","tags":[{"name":"html","slug":"html","permalink":"https://glemontree.github.io/tags/html/"}]},{"title":"[Struts2] CSS","date":"2017-11-01T06:53:35.000Z","path":"2017/11/01/[Struts2] CSS/","text":"CSS是Cascading Style Sheet（层叠样式化表单）的简称，是一种格式化网页的语言，它专门用于网页的样式设置，使网页内容和样式分开。 了解CSSCSS的基本语法格式如下： 1H3&#123;color:red&#125; 其格式分两部分，选择器（selector）和样式规则（rule），在上面这行代码中，H3为选择器，{}的内容为样式规则，样式规则用于设置样式内容，选择器用来指定哪些HTML元素采用样式规则，如上面的代码中，指定所有&lt;H3&gt;标签中的内容都显示为红色，如果有多个样式规则，中间用”;”隔开。 1H3&#123;font-family:Arial; text-align:center; color:red&#125; 为了增强可读性，可以将上面的代码分行显示： 12345H3 &#123; font-family:Arial; text-align:center; color:red&#125; 如果要为一个属性赋多个值，中间使用”,”分隔： 12345H3 &#123; font-family:Arial, scans-serif; text-align:center; color:red&#125; 上面的font-family属性提供了两个字体，浏览器会依次选择，直到遇见可识别的字体为止。 在Style属性中定义样式最简单的CSS使用方法就是直接设置HTML元素的style属性： 12345678910111213&lt;html&gt; &lt;head&gt; &lt;title&gt;css&lt;/title&gt; &lt;/head&gt; &lt;body style=\"background-color: '#0000FF'\"&gt; &lt;a href=\"www.baidu.com\" style=\"color: red; font-size: 40px\"&gt; www.baidu.com &lt;/a&gt; &lt;h3 style=\"font-size: 50px\"&gt; 1234 &lt;/h3&gt; &lt;/body&gt;&lt;/html&gt; 这种方式将HTML代码和CSS代码耦合在一起，不推荐。 在HTML中定义样式在HTML中通过&lt;style&gt;标签可以将HTML元素中的样式提炼出来，并且可以通过三种方式指定哪些HTML元素可以使用这些样式。 指定HTML元素的id 指定HTML元素的class属性 指定HTML元素的标签名 在选择器前面加“井号”（#）表示这个选择器就是一个id属性值，任何一个HTML元素，只要它的id属性值为选择器名，就会应用这个样式： 123#link &#123; color:red&#125; 如果一个&lt;a&gt;标签的id属性值为link，那么这个&lt;a&gt;标签就会应用link样式： 1&lt;a href=\"www.baidu.com\" id=\"link\"&gt;www.baidu.com&lt;/a&gt; 在选择器前面加实心点（.）表示这个选择器的名可以放在HTML元素的class属性中： 1.bg&#123;background-color: '#0000FF'&#125;; 当&lt;body&gt;标签的class属性值为bg时，会自动应用bg样式： 123&lt;body class=\"bg\"&gt; ...&lt;/body&gt; 当选择器名正好是一个HTML元素名的话，所有对应的HTML原色都会应用这个样式： 1h3&#123;font-size: 50px&#125; 12345678910111213141516&lt;html&gt; &lt;head&gt; &lt;title&gt;css&lt;/title&gt; &lt;style type=\"text/css\"&gt; .bg&#123;background-color: '#0000FF'&#125;; h3&#123;font-size: 50px&#125; #link&#123;color: red;font-size: 40px&#125; &lt;/style&gt; &lt;/head&gt; &lt;body class=\"bg\"&gt; &lt;a href=\"www.baidu.com\" id=\"link\"&gt;www.baidu.com&lt;/a&gt; &lt;h3&gt; 1234 &lt;/h3&gt; &lt;/body&gt;&lt;/html&gt; 在外部文件中定义样式CSS标准中允许将样式单独写在一个单独的css文件中，然后通过&lt;link&gt;标签引用这个文件，从而达到多个HTML页面共享样式的目的。 123456789101112&lt;html&gt; &lt;head&gt; &lt;title&gt;css&lt;/title&gt; &lt;link type=\"text/css\" rel=\"stylesheet\" href=\"style.css\"/&gt; &lt;/head&gt; &lt;body class=\"bg\"&gt; &lt;a href=\"www.baidu.com\" id=\"link\"&gt;www.baidu.com&lt;/a&gt; &lt;h3&gt; 1234 &lt;/h3&gt; &lt;/body&gt;&lt;/html&gt; 实现样式的继承所谓继承，就是如果HTML元素还未设置某些样式，但是其父元素中设置了，在子元素中就会继承父元素中的样式： 12345&lt;h3 style=\"font-size: 50px\"&gt; &lt;a href=\"www.baidu.com\" style=\"color: red\"&gt; www.baidu.com &lt;/a&gt;&lt;/h3&gt; 在上面的代码中，&lt;a&gt;标签未设置font-size样式，而其父元素&lt;h3&gt;设置了font-size样式，因此&lt;a&gt;也会应用font-size样式。","tags":[{"name":"CSS","slug":"CSS","permalink":"https://glemontree.github.io/tags/CSS/"}]},{"title":"[Android] Android的4种文件类型Java、class、dex、apk","date":"2017-11-01T06:51:02.000Z","path":"2017/11/01/[Android] Android的4种文件类型Java、class、dex、apk/","text":"Java文件：应用程序源文件 Android是采用Java进行开发的（当然，现在Google开发推荐使用kotlin来进行开发）。 class文件：Java编译后的目标文件 android平台上class文件不能直接在android上运行，由于Google使用了自己的自己的Dalvik来运行应用，所以这里的class肯定不能直接在Android Dalvik的java环境中运行，需要链接成dex文件后才能在dalvik上运行。 dex文件：android平台上的可执行文件 android虚拟机Dalvik支持的字节码文件格式，Google在新发布的Android平台上使用了自己的Dalvik虚拟机来定义，这种虚拟机执行的并非java字节码，而是另外一种字节码，即dex格式的字节码。在编译Java代码后，通过Android平台上的工具可以将Java字节码转换成Dex字节码。 apk：Android上的安装文件 apk是Android安装包的扩展名，Android安装包包含了与某个Android应用程序相关的所有文件，apk文件将AndroidManifest.xml文件、应用程序代码(.dex文件)、资源文件和其他文件打包成一个压缩包，一个工程只能打进一个.apk文件。","tags":[{"name":"Android","slug":"Android","permalink":"https://glemontree.github.io/tags/Android/"}]},{"title":"[Struts2] Ajax","date":"2017-11-01T06:41:18.000Z","path":"2017/11/01/[Struts2] Ajax/","text":"AJAX通过AJAX技术，可以实现以无刷新的方式更新HTML元素中的内容。AJAX并不是一种新的技术，其为4种技术的结合，分别是JavaScript、CSS、DOM和XMLHttpRequest，前三种技术都是客户端技术，它们和服务器一点关系都没有，而XMLHttpRequest和服务器有着密不可分的关系。 XMLHttpRequest的原理就是一个发送HTTP请求的客户端组件，开发人员可以根据不同的情况选择以同步或者异步的方式来发送HTTP请求，并获得服务器的响应信息。 使用XMLHttpRequest获得Web资源XMLHttpRequest组件是以COM组件形式发布的，因此在客户端需要使用以下的代码创建一个XMLHttpRequest对象： 12var myRequest;myRequest = new ActiveXObject(\"Microsoft.XMLHTTP\"); 在XMLHttpRequest对象中有一个open方法，负责向服务器发送HTTP请求信息，这个方法有三个参数，第一个参数是HTTP请求方法（GET、POST），第二个参数是服务端的URL，第三个参数指定了XMLHttpRequest对象是以同步还是以异步的方式发送请求信息，如果为true，则以异步的方式发送，如果为false，则以同步的方式发送。 XMLHttpRequest的send方法负责向服务端发送数据。 同步方式 123456var myRequest = getXMLHTTPRequest();if (myRequest) &#123; myRequest.open(\"POST\", \"url\", false); // 同步发送HTTP请求信息 myRequest.send(null); // 向服务端发送空数据 alert(myRequest.reponseText); // 获得并显示HTTP响应消息&#125; 异步方式 123456789101112var myRequest = getXMLHTTPRequest();if (myRequest) &#123; // 建立一个用于接收异步响应消息的方法 myRequest.onreadystatechange = function() &#123; // 状态为4表示响应消息成功返回 if (myRequest.readyState == 4) &#123; alert(myRequest.reponseText); &#125; &#125;; myRequest.open(\"POST\", \"/webdemo/servlet/AjaxEncode\", true); myRequest.send(null);&#125; 小知识 跨域访问：A上的页面获取B上的资源，浏览器会检查服务器B的HTTP头（HEAD请求），如果Access-Control-Allow-Origin中有A，或者是通配符*，浏览器就会允许跨域。","tags":[{"name":"Ajax","slug":"Ajax","permalink":"https://glemontree.github.io/tags/Ajax/"}]},{"title":"[Struts2] Cookie","date":"2017-11-01T06:27:23.000Z","path":"2017/11/01/[Struts2] Cookie/","text":"什么是CookieCookie是在浏览器访问某个Web资源时，由Web服务器在HTTP响应消息头中通过Set-Cookie字段发送给浏览器的一组消息。 浏览器会根据Set-Cookie字段中的Cookie数据决定是否保存这些Cookie，当浏览器下次访问这个资源时，会自动读取这些被保存的Cookie，并加到HTTP请求消息头的Cookie字段，Web服务器会根据Cookie字段中的内容作出相应的处理。 一个Cookie只能表示一个key-value对，这个key-value对由Cookie名和Cookie值组成，Web服务器可以给一个Web浏览器发送多个Cookie，但每个Cookie的大小一般被限制为4KB。 操作Cookie在Servlet API中使用java.servlet.http.Cookie类来封装一个Cookie消息，在HttpServletResponse接口中定义了一个addCookie方法来向浏览器发送Cookie消息，在HttpServletResquest接口中定义了一个getCookies方法来读取浏览器传递过来的Cookie消息，Cookie类只有一个构造方法： 1public Cookie(String name, String value); 其中name表示Cookie名（在name参数值中不能包含任何空格字符、逗号、分号，并且不能以$字符开头），Value表示Cookie的值。 Cookie类中有以下一些常用的方法： getName()：返回Cookie的名称 setValue()和getValue()：设置和返回Cookie的值 setMaxAge()和getMaxAge()：设置和返回Cookie在客户机上的有效时间，也就是Cookie在客户机上的有效秒数，如果为0，表示当Cookie消息发送到客户端后被浏览器立即删除，如果设置为负数，表示浏览器并不会把这个Cookie保存在硬盘上，这种Cookie称为临时Cookie（保存在硬盘上的Cookie称为永久Cookie），它们只存在于当前浏览器的进程中，当浏览器关闭后，Cookie自动失效。 setPath()：设置客户端访问什么路径传递Cookie对象，如果在创建某个Cookie时未设置它的path属性，那么该Cookie只对当前访问的Servlet所在的Web路径及其子路径有效，如果要想使Cookie对整个Web站点中的所有可访问的路径都有效，需要将path属性值设置为”/“。 举例 通过Cookie技术读写客户端信息 SaveCookie.java 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667package com.glemotree.servlet;import java.io.IOException;import java.io.PrintWriter;import javax.servlet.RequestDispatcher;import javax.servlet.ServletException;import javax.servlet.http.Cookie;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;/*** Servlet implementation class SaveCookie*/public class SaveCookie extends HttpServlet &#123; private static final long serialVersionUID = 1L; /** * @see HttpServlet#HttpServlet() */ public SaveCookie() &#123; super(); // TODO Auto-generated constructor stub &#125; /** * @see HttpServlet#doGet(HttpServletRequest request, HttpServletResponse response) */ protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; // TODO Auto-generated method stub &#125; /** * @see HttpServlet#doPost(HttpServletRequest request, HttpServletResponse response) */ protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; // TODO Auto-generated method stub &#125; @Override protected void service(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; response.setContentType(\"text/heml;charset=UTF-8\"); PrintWriter out = response.getWriter(); // 设置临时Cookie，临时Cookie不需要设置MaxAge属性 Cookie tempCookie = new Cookie(\"temp\", \"87654321\"); // 添加临时Cookie response.addCookie(tempCookie); Cookie cookie = new Cookie(\"cookie\", \"6666\"); cookie.setMaxAge(0); response.addCookie(cookie); String user = request.getParameter(\"user\"); if (user != null) &#123; Cookie userCookie = new Cookie(\"user\", user); userCookie.setMaxAge(60 * 60 * 24); // userCookie.setPath(\"/\"); response.addCookie(userCookie); &#125; // 转发到ReadCookie，并读出已经保存的Cookie RequestDispatcher readCookie = getServletContext().getRequestDispatcher(\"/servlet/ReadCookie\"); // 开始转发 readCookie.include(request, response); &#125;&#125; ReadCookie.java 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263package com.glemotree.servlet;import java.io.IOException;import java.io.PrintWriter;import javax.servlet.ServletException;import javax.servlet.http.Cookie;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;/*** Servlet implementation class ReadCookie*/public class ReadCookie extends HttpServlet &#123; private static final long serialVersionUID = 1L; /** * @see HttpServlet#HttpServlet() */ public ReadCookie() &#123; super(); // TODO Auto-generated constructor stub &#125; protected Cookie getCookieValue(Cookie[] cookies, String name) &#123; if (cookies != null) &#123; for (Cookie cookie : cookies) &#123; if (cookie.getName().equals(name)) &#123; return cookie; &#125; &#125; &#125; return null; &#125; /** * @see HttpServlet#service(HttpServletRequest request, HttpServletResponse response) */ protected void service(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; // TODO Auto-generated method stub response.setContentType(\"text/html;charset=UTF-8\"); PrintWriter out = response.getWriter(); Cookie tempCookie = getCookieValue(request.getCookies(), \"temp\"); if (tempCookie != null) &#123; out.println(\"临时Cookie值： \" + tempCookie.getValue() + \"&lt;br&gt;\"); &#125; else &#123; out.println(\"临时Cookie未设置!&lt;br&gt;\"); &#125; Cookie cookie = getCookieValue(request.getCookies(), \"cookie\"); if (cookie != null) &#123; out.println(\"cookie： \" + cookie.getValue() + \"&lt;br&gt;\"); &#125; else &#123; out.println(\"cookie已经被删除!&lt;br&gt;\"); &#125; Cookie userCookie = getCookieValue(request.getCookies(), \"user\"); if (userCookie != null) &#123; out.println(\"user： \" + userCookie.getValue() + \"&lt;br&gt;\"); &#125; else &#123; out.println(\"user未设置!&lt;br&gt;\"); &#125; &#125;&#125; 对上面的代码我进行一下简要的解释： 设置临时Cookie是不需要设置maxAge属性的 添加一个Cookie可以调用response的addCookie方法进行添加 setMaxAge(0)表示Cookie到达浏览器后会被立即删除 转发的过程是服务器端自己的过程，是不经过浏览器的，此时URL地址也是不变的 临时Cookie只要不关闭浏览器仍然是可以读取到的，一旦关闭浏览器重新访问，cookie就不存在了","tags":[{"name":"Cookie","slug":"Cookie","permalink":"https://glemontree.github.io/tags/Cookie/"}]},{"title":"[C++] C++中实现回调","date":"2017-11-01T06:24:25.000Z","path":"2017/11/01/[C++] C++中实现回调/","text":"一、 使用全局函数作为回调在C++中可以使用类似于C语言方式的回调函数，也就是将全局函数定义为回调函数： 12345678910typedef void(*pCalledFun)(int*);void GetCallBack(pCalledFun parafun) &#123; /* do something */&#125;void funCallback(int* iNum) &#123; /* do something */&#125;void main() &#123; GetCallBack(funCallback);&#125; 二、使用类的静态成员函数作为回调静态成员函数和全局函数很类似，函数调用时不会使用this指针，可以像使用全局函数一样使用静态函数。 1234567891011121314151617#include &lt;iostream&gt;using namespace std;typedef void (*pFun)(void);class CCallBack&#123;public: static void TextPrint(void) &#123; cout &lt;&lt; \"Static Callback Function of a Class\" &lt;&lt; endl; &#125;&#125;;void ForText(pFun pFun1) &#123; pFun1();&#125;void main() &#123; ForText(CCallBack::TextPrint);&#125; 三、使用类的非静态成员函数作为回调要注意的是非静态的成员函数必须通过对象来访问，我们可以这样使用，即给Caller多传个对象进去： 12345678910111213141516class CCallback &#123;public: void Func(int a) &#123; cout &lt;&lt; \"member function callback called with para= \" &lt;&lt; a &lt;&lt; endl; &#125;&#125;;typedef void (CCallback::*pMmeberFunc)(int);void Caller(CCallback* pObj, pMemberFunc p) &#123; (pObj-&gt;*p)(1);&#125;int main(int argc, char** argv) &#123; CCallback obj; Caller(&amp;obj, &amp;CCallback::Func);&#125;","tags":[{"name":"C++ 回调","slug":"C-回调","permalink":"https://glemontree.github.io/tags/C-回调/"}]},{"title":"[C++] C++泛型","date":"2017-11-01T06:12:17.000Z","path":"2017/11/01/[C++] C++泛型/","text":"函数模板的定义： 1template&lt;TYPE_LIST, ARG_LIST&gt;Function_Definition 其中，Function_Definition为函数定义：TYPE_LIST被称为类型参数表，是由一系列代表类型的标识符组成的，其间用逗号分隔，这些标识符的风格通常是由大写字母组成，ARG_LIST称为变量表，其中含有由逗号分隔开的多个变量声明，相当于一般函数定义中的形式参数。 对于类模板，当在类外定义类中的成员函数时，需在每个成员函数的定义前面加上template说明。 函数模板与类模板的区别 我们在使用函数模板时不一定必须指明T的类型，函数模板的实例化可以由编译程序在处理函数调用时自动完成，例如当调用max(1, 2)时自动生成实例max&lt;int&gt;，而调用max(1.1f, 2.2f)时自动生成实例max&lt;float, float&gt;，当然也可以显式指定T的类型； 而对于类模板来说，其实例化必须被显式的指定，比如Point_T&lt;int, int&gt;、Point_T&lt;float, float&gt;。 在设计模板的时候应当注意将C++模板中与参数无关的代码分离出来，避免代码膨胀 模板类的实例个数是由类型参数的种类决定的 函数模板的特化：函数模板需要对某种类型进行特别处理，例如： 1234567bool IsEqual(T t1, T t2) &#123; return t1 == t2;&#125;template&lt;&gt;bool IsEqual(char* t1, char* t2) &#123; // 函数模板特化 return strcmp(t1, t2) == 0;&#125; 这样，当IsEqual函数的参数类型为char*时，就会调用IsEqual特化的版本，而不会再用函数模板实例化。 类模板的特化：当类模板内需要对某些类型进行特别处理时，使用类模板的特化，例如 123456789101112131415template &lt;class T&gt; class compare &#123;public: bool IsEqual(T t1, T t2) &#123; return t1 == t2; &#125;&#125;;template&lt;&gt;class compare&lt;char*&gt; //特化(char*) &#123;public: bool IsEqual(char* t1, char* t2) &#123; return strcmp(t1, t2) == 0; &#125;&#125; 需要注意的是进行类模板的特化时，需要特化所有的成员变量和成员函数 部分模板特例化和全部模板特例化 全部模板特例化就是模板中的模板参数全被指定为确定的类型，也就是定义了一个全新的类型，全部模板特例化的类中的函数可以与模板类不一样，例如： 1234template &lt;class A, class B, class C&gt;class X &#123;&#125;;template&lt;&gt;class X&lt;int, float, string&gt; &#123;&#125;; 部分模板特例化是指模板中的模板参数没有被全部确定，需要编译器在编译时进行确定，它通常有两种情况： 对部分模板参数进行特例化 12template &lt;class B, class C&gt;class X &lt;int, B, C&gt; &#123;&#125;; 当编译器遇到X&lt;int, float, string&gt;的模板实例化请求时，使用这个特例化的版本，而当编译器遇到X&lt;int, doule, char&gt;时，也是使用这个特例化版本，也就是说，只要X&lt;&gt;实例化时， 第一个模板实参是int，就是用特例化版本。 使用具有某一特征的类型，对模板参数进行特例化： 1234template &lt;class T&gt;class Y &#123;&#125;; // (d)template &lt;class T&gt;class Y&lt;T*&gt; &#123;&#125;; // (e) 当编译器遇到Y&lt;int*&gt;时，使用特例化模板(e)，当编译器遇到T&lt;float*&gt;时，也使用特例化模板(e)，而其他类型的实例化时，如Y&lt;int&gt;，使用基本模板(d)，也就是说，当模板实参符合特例化版本所需的特征时（在上面例子中时某个类型的指针），则使用特例化版本。","tags":[{"name":"C++ 泛型","slug":"C-泛型","permalink":"https://glemontree.github.io/tags/C-泛型/"}]},{"title":"[Spring] AOP","date":"2017-11-01T05:42:47.000Z","path":"2017/11/01/[Spring] AOP/","text":"动态代理代理设计模式的原理使用一个代理对象包装起来，然后用该代理对象取代原始对象，任何对原始对象的调用都要通过代理，代理对象决定是否以及何时将方法调用转到原始对象上。 动态代理的实现 ArithmeticCalculator.java 12345678package com.glemontree.spring.aop.helloworld;public interface ArithmeticCalculator &#123; int add(int i, int j); int sub(int i, int j); int mul(int i, int j); int div(int i, int j);&#125; ArithmeticCalculatorImpl.java 123456789101112131415161718192021222324package com.glemontree.spring.aop.helloworld;public class ArithmeticCalculatorImpl implements ArithmeticCalculator&#123; public int add(int i, int j) &#123; int result = i + j; return result; &#125; public int sub(int i, int j) &#123; int result = i - j; return result; &#125; public int mul(int i, int j) &#123; int result = i * j; return result; &#125; public int div(int i, int j) &#123; int result = i / j; return result; &#125;&#125; ArithmeticCalculatorImpl是ArithmeticCalculator的一个实现类，其并没有加上日志功能。 ArithmeticCalculatorLoggingProxy.java 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647package com.glemontree.spring.aop.helloworld;import java.lang.reflect.InvocationHandler;import java.lang.reflect.Method;import java.lang.reflect.Proxy;import java.util.Arrays;public class ArithmeticCalculatorLoggingProxy &#123; private ArithmeticCalculator target; public ArithmeticCalculatorLoggingProxy(ArithmeticCalculator target) &#123; this.target = target; &#125; public ArithmeticCalculator getLoggingProxy() &#123; ArithmeticCalculator proxy = null; // 代理对象由哪一个类加载器进行加载 ClassLoader loader = target.getClass().getClassLoader(); // 代理对象的类型，即其中有哪些方法 Class[] interfaces = new Class[]&#123;ArithmeticCalculator.class&#125;; // 当调用代理对象其中的方法时，该执行的代码 InvocationHandler h = new InvocationHandler() &#123; /** * proxy: 正在返回的代理对象，一般情况下在invoke方法中都不使用该对象 * method：正在被调用的方法 * args：调用方法时传入的参数 * */ public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; String methodName = method.getName(); // 日志 System.out.println(\"The method \" + methodName + \" begins with \" + Arrays.asList(args)); // 执行方法 Object result = method.invoke(target, args); // 日志 System.out.println(\"The method \" + methodName + \" ends with \" + result); return result; &#125; &#125;; proxy = (ArithmeticCalculator) Proxy.newProxyInstance(loader, interfaces, h); return proxy; &#125;&#125; ArithmeticCalculatorLoggingProxy是ArithmeticCalculatorImpl的代理类，其含有一个ArithmeticCalculator类型的对象，且需要在构造函数中进行初始化。 ArithmeticCalculatorLoggingProxy类中通过getLoggingProxy()方法返回代理对象，代理对象的创建通过Proxy.newProxyInstance()方法进行创建，代理对象的创建不同于普通对象的创建，普通对象一般都是通过new进行创建，代理对象必须通过Proxy.newProxyInstance()方法进行创建。 Proxy.newProxyInstance()方法需要三个参数，分别是： loader interfaces h loader顾名思义表示加载器，也就是代理对象由哪一个类加载器进行加载，这里loader是这样创建的： 1ClassLoader loader = target.getClass().getClassLoader(); interfaces表示代理对象的类型，即其中有哪些方法，interfaces是这样创建的： 1Class[] interfaces = new Class[]&#123;ArithmeticCalculator.class&#125;; h表示当调用代理对象其中的方法时，该执行的代码，这里是这样创建的： 1234567891011121314151617181920InvocationHandler h = new InvocationHandler() &#123; /** * proxy: 正在返回的代理对象，一般情况下在invoke方法中都不使用该对象 * method：正在被调用的方法 * args：调用方法时传入的参数 * */ public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; String methodName = method.getName(); // 日志 System.out.println(\"The method \" + methodName + \" begins with \" + Arrays.asList(args)); // 执行方法 Object result = method.invoke(target, args); // 日志 System.out.println(\"The method \" + methodName + \" ends with \" + result); return result; &#125;&#125;; h的类型为InvocationHandler类型，在创建h时需要实现其public Object invoke(Object proxy, Method method, Object[] args)方法，该方法有三个参数： proxy：正在返回的代理对象，一般情况下在invoke方法中都不使用该对象 method：正在被调用的方法 args：调用方法时传入的参数 当使用代理对象调用方法时，会转而调用该方法，在该方法中可以加上自己需要的日志信息或其他信息，当然在该方法中还需要调用真正的需要调用的方法，这是通过下面这行代码实现的：Object result = method.invoke(target, args);，最后将result返回即可。 Main.java 12345678910111213141516171819package com.glemontree.spring.aop.helloworld;public class Main &#123; public static void main(String[] args) &#123; /*ArithmeticCalculator arithmeticCalculator = null; arithmeticCalculator = new ArithmeticCalculatorLoggingImpl(); int result = arithmeticCalculator.add(1, 2); System.out.println(\"--&gt;\" + result); result = arithmeticCalculator.div(4, 2); System.out.println(\"--&gt;\" + result);*/ ArithmeticCalculator target = new ArithmeticCalculatorImpl(); ArithmeticCalculator proxy = new ArithmeticCalculatorLoggingProxy(target).getLoggingProxy(); int result = proxy.add(1, 2); System.out.println(\"--&gt;\" + result); result = proxy.div(4, 2); System.out.println(\"--&gt;\" + result); &#125;&#125; AOP简介AOP(Aspect-Oriented Programming，面向切面编程)是一种新的方法论，是对传统OOP的补充！ AOP的好处： 每个事物逻辑位于一个位置，代码不分散，便于维护和升级 业务模块更简洁，只包含核心业务代码 AOP图解 切面：横切关注点（跨越应用程序多个模块的功能），被模块化的特殊对象 通知：切面必须要完成的工作 目标：被通知的对象 代理：向目标对象应用通知之后创建的对象 连接点：程序执行的某个特定位置，如类中某个方法调用前、调用后、方法抛出异常后等，连接点由两个信息确定，方法表示的程序执行点，相对点表示的方位 切点：每个类都拥有多个连接点，例如ArithmethicCalculator的所有方法都是连接点，即连接点是程序类中客观存在的事务，AOP通过切点定位到特定的连接点，类比：连接点相当于数据库中的记录，切点相当于查询条件，切点和连接点不是一对一的关系，一个切点匹配多个连接点，切点通过org.springframework.aop.Pointcut接口进行描述，它使用类和方法作为连接点的查询条件。 Spring AOP前置通知 AspectJ：java社区里最完整最流行的AOP框架 可以使用基于AspectJ注解或基于XML配置的AOP 使用Spring AOP 加入jar包： com.springsource.net.sf.cglib-2.2.0.jar com.springsource.org.aopalliance-1.0.0.jar com.springsource.org.aspectj.weaver-1.6.8.RELEASE.jar commons-logging-1.1.1.jar spring-aop-4.0.0.RELEASE.jar spring-aspects-4.0.0.RELEASE.jar spring-beans-4.0.0.RELEASE.jar spring-context-4.0.0.RELEASE.jar spring-core-4.0.0.RELEASE.jar spring-expression-4.0.0.RELEASE.jar 在配置文件中加入aop的命名空间： xmlns:aop=”http://www.springframework.org/schema/aop“ 基于注解的方式： 在配置文件中加入如下配置： 1&lt;aop:aspectj-autoproxy&gt;&lt;/aop:aspectj-autoproxy&gt; 这个注解的作用是使Aspect注解起作用：自动为匹配的类生成代理对象 把横切关注点的代码抽象到切面的类中 切面的类首先是一个IOC容器中bean，并加入@Component注解 切面还需要加入@Aspect注解 在类中声明各种通知 常见的有5种通知，分别是： @Before：前置通知，在方法执行之前执行 @After：后置通知，在方法执行之后执行 @AfterRunning：返回通知，在方法返回结果之后执行 @AfterThrowing：异常通知，在方法抛出异常之后 @Around：环绕通知，围绕着方法执行 声明通知其实就是声明方法： 声明一个方法 在方法前加入@Before注解 可以在声明方法中声明一个类型为JointPoint类型的参数，然后就能访问链接细节，如方法名称和参数值 1234567891011121314151617181920212223package com.glemontree.spring.aop.impl;import java.util.ArrayList;import java.util.Arrays;import java.util.List;import org.aspectj.lang.JoinPoint;import org.aspectj.lang.annotation.Aspect;import org.aspectj.lang.annotation.Before;import org.springframework.stereotype.Component;// 把这个类声明为一个切面：需要把该类放入到IOC容器中，再声明为一个切面@Aspect@Componentpublic class LoggingAspect &#123; //声明该方法为一个前置通知：在目标方法开始执行之前执行 @Before(\"execution(* com.glemontree.spring.aop.impl.*.*(int, int))\") public void beforeMethod(JoinPoint joinPoint) &#123; String methodName = joinPoint.getSignature().getName(); List&lt;Object&gt; args = Arrays.asList(joinPoint.getArgs()); System.out.println(\"The method \" + methodName + \" begins with \" + args); &#125;&#125; 后置通知和前置通知很类似，后置通知使用@After注解： 12345@After(\"execution(* com.glemontree.spring.aop.impl.*.*(int, int))\")public void afterMethod(JoinPoint joinPoint) &#123; String methodName = joinPoint.getSignature().getName(); System.out.println(\"The method \" + methodName + \" ends\");&#125; 需要注意的是后置通知是在目标方法执行之后执行，其不管是否会发生异常都会执行。另外需要注意后置通知中不能访问目标方法执行的结果。 返回通知123456// 在方法正常执行后执行的代码，返回通知是可以访问到方法的返回值的@AfterReturning(value=\"execution(* com.glemontree.spring.aop.impl.*.*(int, int))\", returning=\"result\")public void afterReturning(JoinPoint joinPoint, Object result) &#123; String methodName = joinPoint.getSignature().getName(); System.out.println(\"The method \" + methodName + \" ends with \" + result);&#125; 异常通知12345678/** * 在目标方法出现异常时会执行的代码，可以访问到异常对象且可以指定在出现特定异常时再执行通知代码 */@AfterThrowing(value=\"execution(* com.glemontree.spring.aop.impl.*.*(int, int))\", throwing=\"ex\")public void afterThrowing(JoinPoint joinPoint, NullPointerException ex) &#123; String methodName = joinPoint.getSignature().getName(); System.out.println(\"The method \" + methodName + \" occurs exception: \" + ex);&#125; 环绕通知环绕通知类似于动态代理，虽然功能很强大，但是用的不多，这里不加以介绍！ 切面的优先级可以通过@Order注解指定切面的优先级，值越小优先级越高。 12345678910111213141516171819package com.glemontree.spring.aop.impl;import java.util.Arrays;import org.aspectj.lang.JoinPoint;import org.aspectj.lang.annotation.Aspect;import org.aspectj.lang.annotation.Before;import org.springframework.core.annotation.Order;import org.springframework.stereotype.Component;@Order(1)@Component@Aspectpublic class ValidationAspect &#123; @Before(\"execution(* com.glemontree.spring.aop.impl.*.*(int, int))\") public void validateArgs(JoinPoint joinPoint) &#123; System.out.println(\"validate: \" + Arrays.asList(joinPoint.getArgs())); &#125;&#125; 重用切点表达式123456789101112// 定义一个方法，用于声明切入点表达式，一般的，该方法中不需要填入其他的代码@Pointcut(\"execution(* com.glemontree.spring.aop.impl.*.*(int, int))\")public void declareJointPointExpression() &#123;&#125;//声明该方法为一个前置通知：在目标方法开始执行之前执行@Before(\"declareJointPointExpression()\")public void beforeMethod(JoinPoint joinPoint) &#123; String methodName = joinPoint.getSignature().getName(); List&lt;Object&gt; args = Arrays.asList(joinPoint.getArgs()); System.out.println(\"The method \" + methodName + \" begins with \" + args);&#125; 对于同一个包下的另一个切面，可以使用下面的方式： 12345678910111213141516171819package com.glemontree.spring.aop.impl;import java.util.Arrays;import org.aspectj.lang.JoinPoint;import org.aspectj.lang.annotation.Aspect;import org.aspectj.lang.annotation.Before;import org.springframework.core.annotation.Order;import org.springframework.stereotype.Component;@Order(1)@Component@Aspectpublic class ValidationAspect &#123; @Before(\"LoggingAspect.declareJointPointExpression()\") public void validateArgs(JoinPoint joinPoint) &#123; System.out.println(\"validate: \" + Arrays.asList(joinPoint.getArgs())); &#125;&#125; 当然，对于不同包下的切面，可能还需要使用包名。","tags":[{"name":"Spring, AOP","slug":"Spring-AOP","permalink":"https://glemontree.github.io/tags/Spring-AOP/"}]},{"title":"[Java] 分布式和集群的区别","date":"2017-10-31T05:22:40.000Z","path":"2017/10/31/[Java] 分布式和集群的区别/","text":"对于集群，不是n个服务器做同一个任务，而是与n个任务分布在n台机器上同时处理，比如，你前台页面有n个用户，分别发送一个请求，那么如果不是集群的话，那这n个请求需要并行在一台机器上处理，如果每个请求都是1秒钟，那么就会有1个人等待n秒钟，有一个人等待n-1秒钟，以此类推。那么现在在集群环境下，n个任务并行发到n台机器上同时运行，那么每个人等待的时间还是1秒钟。","tags":[{"name":"Java, 分布式, 集群","slug":"Java-分布式-集群","permalink":"https://glemontree.github.io/tags/Java-分布式-集群/"}]},{"title":"[C++] C++面试","date":"2017-10-28T05:08:43.000Z","path":"2017/10/28/[C++] C++面试/","text":"智能指针- shared_ptr ref_count 自旋锁 enable_share_from_this 是什么意思，请举一个场景说明 需求：在类的内部需要自身的shared_ptr而不是this裸指针 场景：在类中发起一个异步操作，callback回来要保证发起操作的对象仍然有效 使用boost库时，经常会看到这样的类： 1class A : public enable_share_from_this&lt;A&gt; 在什么情况下要使A继承enable_share_from_this？ 使用场合： 当类A被shared_ptr管理，且在类A的成员函数里需要把当前类对象作为参数传给其他函数时，就需要传递一个自身的shared_ptr，我们就使类A继承enable_share_from_this，然后通过其成员函数share_from_this返回指向自身的shared_ptr。 以上有两个疑惑： 把当前类对象作为参数传给其他函数时，为什么要传递shared_ptr，直接传递this指针不行吗？ 一个裸指针传递给调用者，谁也不知道调用者会干什么，加入调用者delete了该对象，而shared_ptr此时还指向该对象 直接传递shared_ptr可以吗？shared_ptr&lt;this&gt; 这样会造成两个非共享的shared_ptr指向一个对象，最后造成两次析构该对象。 本部分转载自C++ boost库—-share_from_this类的作用和实现原理。 侵入式与非侵入式智能指针 非侵入式智能指针的实现完全放在智能指针模板里，模板类有一个用于保存资源类对象的指针变量，和一个用于记录资源对象使用计数的指针变量，这两个东西是所有的智能指针对象共享的，所以通过指针保存。 侵入式的实现则分散在智能指针模板和使用智能指针模板的类中，模板类只有一个用于保存对象的指针变量，对象的计数则放在了资源类中。 非侵入式智能指针的引用计数变量为了保证所有对象共享，需要用堆里的内存，所以需要用new。 侵入式智能指针的引用计数变量保存在对象里，因为对象是唯一的，所以引用计数也是唯一的。 侵入式智能指针的好处是： 一个资源对象无论被多少个侵入式智能指针包含，从始至终只有一个引用计数变量，不需要在每一个使用智能指针对象的地方都new一个计数对象，这样效率比较高，使用内存也比较少，也比较安全 因为引用计数变量存储在对象本身，所以在函数调用的时候可以直接传递资源对象地址，而不用担心引用计数值丢失（非侵入式智能指针对象的拷贝，必须带着智能指针模板，否则就会出现对象引用计数丢失） 弱指针 对于引用计数法实现的计数，总是避免不了循环引用的问题： 123456789101112131415161718192021222324252627282930#include &lt;iostream&gt;#include &lt;memory&gt;#include &lt;vector&gt;using namespace std;class ClassB;class ClassA&#123;public: ClassA() &#123; cout &lt;&lt; \"ClassA Constructor...\" &lt;&lt; endl; &#125; ~ClassA() &#123; cout &lt;&lt; \"ClassA Destructor...\" &lt;&lt; endl; &#125; shared_ptr&lt;ClassB&gt; pb; // 在A中引用B&#125;;class ClassB&#123;public: ClassB() &#123; cout &lt;&lt; \"ClassB Constructor...\" &lt;&lt; endl; &#125; ~ClassB() &#123; cout &lt;&lt; \"ClassB Destructor...\" &lt;&lt; endl; &#125; shared_ptr&lt;ClassA&gt; pa; // 在B中引用A&#125;;int main() &#123; shared_ptr&lt;ClassA&gt; spa = make_shared&lt;ClassA&gt;(); shared_ptr&lt;ClassB&gt; spb = make_shared&lt;ClassB&gt;(); spa-&gt;pb = spb; spb-&gt;pa = spa; // 函数结束，思考一下：spa和spb会释放资源么？&#125; 上面代码的输出为： 123ClassA Constructor...ClassB Constructor...Program ended with exit code: 0 从上面代码中可以看出，Class A和Class B之间存在着循环引用，当main函数运行结束后，spa和spb管理的动态资源并没有得到释放，产生了内存泄漏！ 为了解决类似的问题，C++11引入了weak_ptr，来打破这种循环引用。 weak_ptr是为了配合shared_ptr而引入的一种智能指针，它指向一个由shared_ptr管理的对象而不影响所指对象的生命周期，也就是将一个weak_ptr绑定到一个shared_ptr不会改变shared_ptr的引用计数。不论是否有weak_ptr指向，一旦最后一个指向对象的shared_ptr被销毁，对象就会被释放。从这个角度看，weak_ptr更像是shared_ptr的一个助手而不是智能指针。 当我们创建一个weak_ptr时，需要用一个shared_ptr实例来初始化weak_ptr，由于是弱共享，weak_ptr的创建并不会影响shared_ptr的引用计数值。 1234567int main() &#123; shared_ptr&lt;int&gt; sp(new int(5)); cout &lt;&lt; \"创建前sp的引用计数：\" &lt;&lt; sp.use_count() &lt;&lt; endl; // use_count = 1 weak_ptr&lt;int&gt; wp(sp); cout &lt;&lt; \"创建后sp的引用计数：\" &lt;&lt; sp.use_count() &lt;&lt; endl; // use_count = 1&#125; 既然weak_ptr并不改变其所共享的shared_ptr实例的引用计数，那就可能存在weak_ptr指向的对象被释放掉这种情况。这时，我们就不能使用weak_ptr直接访问对象。那么我们如何判断weak_ptr指向对象是否存在呢？C++中提供了lock函数来实现该功能。如果对象存在，lock()函数返回一个指向共享对象的shared_ptr，否则返回一个空shared_ptr。 1234567891011121314151617181920212223class A&#123;public: A() : a(3) &#123; cout &lt;&lt; \"A Constructor...\" &lt;&lt; endl; &#125; ~A() &#123; cout &lt;&lt; \"A Destructor...\" &lt;&lt; endl; &#125; int a;&#125;;int main() &#123; shared_ptr&lt;A&gt; sp(new A()); weak_ptr&lt;A&gt; wp(sp); //sp.reset(); if (shared_ptr&lt;A&gt; pa = wp.lock()) &#123; cout &lt;&lt; pa-&gt;a &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; \"wp指向对象为空\" &lt;&lt; endl; &#125;&#125; weak_ptr并没有重载operator-&gt;和operator *操作符，因此不可直接通过weak_ptr使用对象，典型的用法是调用其lock函数来获得shared_ptr示例，进而访问原始对象。 最后，我们来看看如何使用weak_ptr来改造最前面的代码，打破循环引用问题。 12345678910111213141516171819202122232425class ClassB;class ClassA&#123;public: ClassA() &#123; cout &lt;&lt; \"ClassA Constructor...\" &lt;&lt; endl; &#125; ~ClassA() &#123; cout &lt;&lt; \"ClassA Destructor...\" &lt;&lt; endl; &#125; weak_ptr&lt;ClassB&gt; pb; // 在A中引用B&#125;;class ClassB&#123;public: ClassB() &#123; cout &lt;&lt; \"ClassB Constructor...\" &lt;&lt; endl; &#125; ~ClassB() &#123; cout &lt;&lt; \"ClassB Destructor...\" &lt;&lt; endl; &#125; weak_ptr&lt;ClassA&gt; pa; // 在B中引用A&#125;;int main() &#123; shared_ptr&lt;ClassA&gt; spa = make_shared&lt;ClassA&gt;(); // 只进行一次内存申请 shared_ptr&lt;ClassB&gt; spb = make_shared&lt;ClassB&gt;(); spa-&gt;pb = spb; spb-&gt;pa = spa; // 函数结束，思考一下：spa和spb会释放资源么？&#125; 输出结果如下： 12345ClassA Constructor...ClassB Constructor...ClassA Destructor...ClassB Destructor...Program ended with exit code: 0 从运行结果可以看到spa和spb指向的对象都得到释放！ 本小节转载自文章【C++11新特性】 C++11智能指针之weak_ptr。 vector的扩容倍数 class作为map/unordered_map的key分别需要实现什么？前者是&lt;后者是==和hash C++程序如何和其他语言交互 vector的插入异常安全是怎么实现的？ deque如何实现O(1)下标查找 shared_ptr shared_ptr是引用计数型智能指针，采用的是在堆上放个计数值的方法。 空的shared_ptr 1shared_ptr&lt;T&gt; ptr; 使用new创建 1shared_ptr&lt;T&gt; ptr(new T()); 使用复制构造函数后者重载=构造 12shared_ptr&lt;T&gt; ptr1(new T());shared_ptr&lt;T&gt; ptr2(ptr1); 123shared_ptr&lt;T&gt; ptr1(new T());shared_ptr&lt;T&gt; ptr2;ptr2 = ptr1; 当表达式中存在有符号数和无符号数所有的操作数都要转换为无符号数，所以从这个意义上讲，无符号数的运算优先级要高于有符号数。 有符号数转换为无符号数，负数转换为大的正数，相当于在原值上加上2的n次方，而正数保持不变。 无符号数转换为有符号数，对于小的数将保持原值，对于大的数将转换为负数，相当于原值减去2的n次方。 用const修饰的符号常量的区别： const位于*的左边，表示被指物是常量，const位于*的右边，表示指针自身是常量（常量指针）。 在C++中只使用const常量而不使用宏常量。 用运算符sizeof可以计算出数组的容量（字节数），sizeof(p)，p为指针，得到的是一个指针变量的字节数，而不是p所指的内存容量，C/C++语言没有办法知道指针所指的内存容量，除非在申请内存时记住它。 为了节省内存，C/C++语言将常量字符串放到单独的一个内存区域，当几个指针赋值给相同的常量字符串时，它们实际上会指向相同的内存地址，但用常量内存初始化数组时，情况有些不同： 1234char str1[] = \"helloworld\";char str2[] = \"helloworld\";char* str3 = \"helloworld\";char* str4 = \"helloworld\" 其中，str1和str2会为它们分配两个长度相同的空间，并把”helloworld”的内容复制到数组中去，这是两个初始地址不同的数组（在栈中分配内存）。 str3和str4是两个指针，我们无需为它们分配内存以存储字符串的内容，而只需要将它们指向”helloworld”在内存中的地址即可，由于”helloworld”是常量字符串，它在内存中只有一个拷贝，因此str3和str4指向的是同一个地址。 sizeof是C语言的一个单目操作符，它并不是函数，操作数可以是一个表达式或类型名，数据类型必须用括号括住：sizeof(int)，变量名可以不用括号括住。 123456int a[50]; // sizeof(a) = 200;int* a = new int[50]; // sizeof(a) = 4;class Test &#123;int a; static double c&#125;; // sizeof(Test) = 4;Test* s; // sizeof(s) = 4;class Test &#123;&#125;; // sizeof(Test) = 1;int func(char s[5]); // sizeof(s) = 4; 数组类型：其结果是数组的总字节数 指向数组的指针：其结果是该指针的字节数 函数中的数组形参或函数类型的形参：其结果是指针的字节数 类中的静态成员不会结果产生影响，因为静态变量的存储位置与结构或者类的实例地址无关 没有成员变量的类的大小为1，因为必须保证类的每一个实例在内存中都有一个唯一的地址 有虚函数的类都会建立一张虚函数表，表中存放的是虚函数的函数指针，这个表的地址存放在类中，所以不管有几个虚函数，都只占据一个指针大小。 在32位系统中： 12345char arr[] = &#123;4, 3, 9, 2, 0, 1, 5&#125;;char* str = arr;sizeof(arr) = 8;sizeof(str) = 4;strlen(str) = 5; sizeof(arr)：arr是一个数组，sizeof(arr)表示数组所占用的字节数 sizeof(str)：str为一个指针，sizeof(str)表示指针所占用的字节数 strlen(str)：strlen函数求取字符串长度以ASCII值为0为止 dynamic_cast：主要用于执行安全向下转型，也就是用来决定某对象是否归属继承体系中的某个类型，主要用于多态类之间的转换。 安全的基类和子类之间进行转换 必须要有虚函数 相同基类不同子类之间的交叉转换，但结果是NULL 12345678910111213141516171819class Base &#123;public: int m_iNum; virtual void fun() &#123;&#125;; // 基类必须有虚函数，保持多态性才能使用dynamic_cast&#125;;class Derive: public Base &#123;public:char*m_szName[100];void bar()&#123;&#125;;&#125;;Base* pb =new Derive();Derive *pd1 = static_cast&lt;Derive *&gt;(pb); //子类-&gt;父类，静态类型转换，正确但不推荐Derive *pd2 = dynamic_cast&lt;Derive *&gt;(pb); //子类-&gt;父类，动态类型转换，正确Base* pb2 =new Base();Derive *pd21 = static_cast&lt;Derive *&gt;(pb2); //父类-&gt;子类，静态类型转换，危险！访问子类m_szName成员越界Derive *pd22 = dynamic_cast&lt;Derive *&gt;(pb2); //父类-&gt;子类，动态类型转换，安全的。结果是NULL const_cast：能够改变表达式的常量属性： 1234const char c = 'a';const char* pc = &amp;c;char* cp = const_cast&lt;char*&gt;(pc);*cp = 'c'; reinterpret_cast：常用于函数指针之间的转换： 12345int doSomething() &#123;return 0;&#125;typedef void(*FuncPtr)();FuncPtr funcPtrArray[10];funcPtrArray[0] = &amp;doSomething; //编译错误，类型不匹配funcPtrArray[0] = reinterpret_cast&lt;FuncPtr&gt;(&amp;doSomething); // 不同函数指针类型之间进行转换 static_cast：任何具有明确定义的类型转换，只要不包含底层const，都可以使用static_cast 静态成员函数不能为虚函数，静态成员函数是以类为单位的函数，与具体对象无关，虚函数是与对象动态绑定的 内联函数不能成为虚函数，内联函数需要在编译阶段展开，而虚函数是在运行时动态绑定的，编译时无法展开 虚拟继承是多重继承中特有的概念，虚拟继承是为解决多重继承而出现的，如类D继承自类B1、B2，而类B1、B2都继承自类A，因此在类D中两次出现类A中的变量和函数，为了节省内存空间，可以将B1和B2对A的继承定义为虚拟继承，而A就成了虚拟基类。 Linux进程地址空间布局： 代码段（.text）：用来存放可执行文件的机器指令，存放在只读区域，以防止被修改 只读数据段（.rodata）：用来存放常量，存放在只读区域，如字符串常量、全局const常量 可读写数据段（.data）：用来存放可执行文件中已初始化全局变量，即静态分配的变量和全局变量 BSS段（.bss）：未初始化的全局变量和局部静态变量一般放在.bss段里，以节省内存空间 堆：用来容纳应用程序动态分配的内存区域。当程序使用malloc或new分配内存时，得到的内存来自堆。堆通常位于栈的下方。 用于维护函数调用的上下文。栈通常分配在用户空间的最高地址处分配。 动态链接库映射区：如果程序调用了动态链接库，则会有这一部分。该区域是用于映射装载的动态链接库。 保留区：内存中受到保护而禁止访问的内存区域。 栈：栈是向低地址扩展的数据结构，是一块连续的内存区域，栈顶的地址和栈的最大容量是系统预先规定好的，栈的大小为1M，如果申请的空间超过栈的剩余空间时，将提示overflow 堆：堆是向高地址扩展的数据结构，是不连续的内存区域 智能指针的设计思想是将基本类型指针封装为类对象指针（这个类肯定是个模板，以适应不同基本类型的需求），并在析构函数里编写delete语句删除指针指向的内存空间 shared_ptr采用引用计数的智能指针，主要用于将一个指针分配给多个所有者的情况，其大小为两个指针：一个用于对象，另一个用于包含引用计数的共享控制块。 在C++对象模型中，非静态数据成员被配置于每一个类的对象之中，静态数据成员则被存放在所有的类对象之外，静态及非静态成员函数也被放在类对象之外。","tags":[{"name":"C++ 面试","slug":"C-面试","permalink":"https://glemontree.github.io/tags/C-面试/"}]},{"title":"[C++] 迭代器失效","date":"2017-10-24T13:56:42.000Z","path":"2017/10/24/[C++] 迭代器失效/","text":"迭代器失效当使用一个容器的insert或者erase函数通过迭代器插入或删除元素可能会导致迭代器失效，因此很多建议都是让我们获取insert或者erase返回的迭代器，以便用重新获取新的有效的迭代器进行正确的操作。 12iter = vec.insert(iter);iter = vec.erase(iter); 迭代器失效的原因以vector为例，当我们插入一个元素时它的预分配空间不够时，它会重新分配一段新空间，将原空间上的元素复制到新空间上，然后再把新加入的元素放到新空间的尾部，以满足vector元素要求连续存储的目的。而后原空间会被系统撤销或者征作他用，于是指向原空间的迭代器类似于“悬垂指针”一样的东西，指向了一片非法区域。 迭代器失效分类 vector vector的push_back操作可能没事，但是一旦引发内存重分配，所有迭代器都会失效 vector的insert操作插入点之后的所有迭代器失效，但一旦发生内存重分配，所有迭代器都会失效 vector的erase操作插入点之后的所有迭代器失效 vector的reserve操作所有迭代器失效（导致内存重分配） list/map 插入不会使得任何迭代器失效，删除运算使指向删除位置的迭代器失效，但是不会失效其他迭代器 deque insert操作会使所有迭代器失效 erase操作会使所有迭代器失效 对于关联容器（map、set、multimap、multiset），删除当前的iterator，仅仅会使当前的iterator失效，只要在erase时，递增当前iterator即可。这是因为map之类的容器使用了红黑树来实现，插入、删除一个结点不会对其他结点产生影响。erase迭代器只是被删元素的迭代器失效，但是因为erase()函数返回为void类型，所以要采用erase(iter++)的方式删除迭代器： 12345678for (iter = cont.begin(); it != cont.end();)&#123; (*iter)-&gt;doSomething(); if (shouldDelete(*iter)) cont.erase(iter++); else ++iter;&#125; 对于序列式容器（vector、deque），删除当前的iterator会使后面所有元素的iterator失效，这是因为vector、deque使用了连续分配的内存，删除一个元素会导致后面所有元素向前移动一个位置，所以不能使用erase(iter++)的方式，不过erase()方法返回了下一个有效的iterator 12345678for (iter = cont.begin(); iter != cont.end();)&#123; (*it)-&gt;doSomething(); if (shouldDelete(*iter)) iter = cont.erase(iter); else ++iter;&#125; 对于list来说，它使用了不连续分配的内存，并且它的erase方法也会返回下一个有效的iterator，因此上面两种方法都可以使用。 说明本文转载自文章 失效迭代器（Invalidating Iterators）。","tags":[{"name":"C++11, 迭代器","slug":"C-11-迭代器","permalink":"https://glemontree.github.io/tags/C-11-迭代器/"}]},{"title":"[C++] C++中的new、operator new和placement new","date":"2017-10-23T14:38:12.000Z","path":"2017/10/23/[C++] C++中的new、operator new和placement new/","text":"new/delete和operator new/operator deletenew operator/delete operator就是new和delete操作符，而operator new/operator delete是函数。 new operator： 调用operator new分配足够的空间，并调用相关对象的构造函数 不可以被重载 operator new： 只分配所要求的空间，不调用相关对象的构造函数，当无法满足所要求分配的空间时，则 如果有new_handler，则调用new_handler，否则 如果没要求不抛出异常，则执行bad_alloc异常，否则 返回0 可以被重载 重载时，返回类型必须声明为void* 重载时，第一个参数类型必须为表达要求分配空间的大小（字节），类型为size_t 重载时，可以带其他参数 1234567891011121314151617181920212223242526272829#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;class X&#123;public: X() &#123; cout &lt;&lt; \"constructor of X\" &lt;&lt; endl; &#125; ~X() &#123; cout &lt;&lt; \"destructor of X\" &lt;&lt; endl; &#125; void* operator new(size_t size, string str) &#123; cout &lt;&lt; \"operator new size \" &lt;&lt; size &lt;&lt; \" with string \" &lt;&lt; str &lt;&lt; endl; return ::operator new(size); &#125; void operator delete(void* pointee) &#123; cout&lt;&lt;\"operator delete\"&lt;&lt;endl; ::operator delete(pointee); &#125; private: int num;&#125;;int main() &#123; X *px = new(\"A new class\") X; delete px; return 0;&#125; X* px = new X; //该行代码中的new为new operator，它将调用类X中的operator new，为该类的对象分配空间，然后调用当前实例的构造函数。delete px; //该行代码中的delete为delete operator，它将调用该实例的析构函数，然后调用类X中的operator delete，以释放该实例占用的空间。 new operator与delete operator的行为是不能够也不应该被改变，这是C++标准作出的承诺。而operator new与operator delete和C语言中的malloc与free对应，只负责分配及释放空间。但使用operator new分配的空间必须使用operator delete来释放，而不能使用free，因为它们对内存使用的登记方式不同。反过来亦是一样。你可以重载operator new和operator delete以实现对内存管理的不同要求，但你不能重载new operator或delete operator以改变它们的行为。 为什么有必要写自己的operator new和operator delete？答案通常是：为了效率。缺省的operator new和operator delete具有非常好的通用性，它的这种灵活性也使得在某些特定的场合下，可以进一步改善它的性能。尤其在那些需要动态分配大量的但很小的对象的应用程序里，情况更是如此。具体可参考《Effective C++》中的第二章内存管理。 placement newplacement new 是重载operator new 的一个标准、全局的版本，它不能够被自定义的版本代替（不像普通版本的operator new和operator delete能够被替换）。 void operator new( size_t, void p ) throw() { return p; } placement new的执行忽略了size_t参数，只返还第二个参数。其结果是允许用户把一个对象放到一个特定的地方，达到调用构造函数的效果。和其他普通的new不同的是，它在括号里多了另外一个参数。比如： Widget * ptr = new Widget; //ordinary new pi = new (ptr) int; pi = new (ptr) int; //placement new 括号里的参数ptr是一个指针，它指向一个内存缓冲器，placement new将在这个缓冲器上分配一个对象。Placement new的返回值是这个被构造对象的地址(比如括号中的传递参数)。placement new主要适用于：在对时间要求非常高的应用程序中，因为这些程序分配的时间是确定的；长时间运行而不被打断的程序；以及执行一个垃圾收集器 (garbage collector)。 new 、operator new 和 placement new 区别 new ：不能被重载，其行为总是一致的。它先调用operator new分配内存，然后调用构造函数初始化那段内存。 new 操作符的执行过程： 调用operator new分配内存 ； 调用构造函数生成类对象； 返回相应指针。 operator new：要实现不同的内存分配行为，应该重载operator new，而不是new。 operator new就像operator + 一样，是可以重载的。如果类中没有重载operator new，那么调用的就是全局的::operator new来完成堆的分配。同理，operator new[]、operator delete、operator delete[]也是可以重载的。 placement new：只是operator new重载的一个版本。它并不分配内存，只是返回指向已经分配好的某段内存的一个指针。因此不能删除它，但需要调用对象的析构函数。 如果你想在已经分配的内存中创建一个对象，使用new时行不通的。也就是说placement new允许你在一个已经分配好的内存中（栈或者堆中）构造一个新的对象。原型中void* p实际上就是指向一个已经分配好的内存缓冲区的的首地址。 placement new 存在的理由 用placement new 解决buffer的问题 问题描述：用new分配的数组缓冲时，由于调用了默认构造函数，因此执行效率上不佳。若没有默认构造函数则会发生编译时错误。如果你想在预分配的内存上创建对象，用缺省的new操作符是行不通的。要解决这个问题，你可以用placement new构造。它允许你构造一个新对象到预分配的内存上。 增大时空效率的问题 使用new操作符分配内存需要在堆中查找足够大的剩余空间，显然这个操作速度是很慢的，而且有可能出现无法分配内存的异常（空间不够）。placement new就可以解决这个问题。我们构造对象都是在一个预先准备好了的内存缓冲区中进行，不需要查找内存，内存分配的时间是常数；而且不会出现在程序运行中途出现内存不足的异常。所以，placement new非常适合那些对时间要求比较高，长时间运行不希望被打断的应用程序。 placement new使用步骤 缓存提前分配 有三种方式： 为了保证通过placement new使用的缓存区的memory alignment(内存队列)正确准备，使用普通的new来分配它：在堆上进行分配 12class Task ;char * buff = new [sizeof(Task)]; //分配内存 （请注意auto或者static内存并非都正确地为每一个对象类型排列，所以，你将不能以placement new使用它们。） 在栈上进行分配 12class Task ;char buf[N*sizeof(Task)]; //分配内存 还有一种方式，就是直接通过地址来使用。(必须是有意义的地址) 1void* buf = reinterpret_cast&lt;void*&gt; (0xF00F); 对象的分配 在刚才已分配的缓存区调用placement new来构造一个对象。 1Task *ptask = new (buf) Task 使用 按照普通方式使用分配的对象： 12345ptask-&gt;memberfunction();ptask-&gt; member;//... 对象的析构 一旦你使用完这个对象，你必须调用它的析构函数来毁灭它。按照下面的方式调用析构函数： 1ptask-&gt;~Task(); //调用外在的析构函数 释放 你可以反复利用缓存并给它分配一个新的对象（重复步骤2，3，4）如果你不打算再次使用这个缓存，你可以象这样释放它： 1delete [] buf; 12345678910111213141516171819202122232425262728293031323334#include &lt;iostream&gt;using namespace std;class X&#123;public: X() &#123; cout&lt;&lt;\"constructor of X\"&lt;&lt;endl; &#125; ~X() &#123; cout&lt;&lt;\"destructor of X\"&lt;&lt;endl;&#125; void SetNum(int n) &#123; num = n; &#125; int GetNum() &#123; return num; &#125;private: int num;&#125;;int main()&#123; char* buf = new char[sizeof(X)]; X *px = new(buf) X; px-&gt;SetNum(10); cout&lt;&lt;px-&gt;GetNum()&lt;&lt;endl; px-&gt;~X(); delete []buf; return 0;&#125; 说明本文转载自文章C++中的new、operator new与placement new。","tags":[{"name":"C++, new, operator new, placement new","slug":"C-new-operator-new-placement-new","permalink":"https://glemontree.github.io/tags/C-new-operator-new-placement-new/"}]},{"title":"[C++] allocator原理","date":"2017-10-23T11:57:49.000Z","path":"2017/10/23/[C++] allocator原理/","text":"allocator原理介绍考虑到小型区域可能造成内存破碎问题，SGI STL设计了双层级配置器，第一层配置器直接使用malloc()和free()，第二层配置器则视情况采用不同的策略：当配置区块超过128bytes时，调用第一层级配置器，当配置区块小于128bytes时，采用复杂的memory pool方式。 第一级配置器__malloc_alloc_template1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677//以下是第第一级配置器template &lt;int inst&gt;class __malloc_alloc_template &#123;private://以下函数用来处理内存不足的情况static void *oom_malloc(size_t);static void *oom_realloc(void *, size_t);static void (* __malloc_alloc_oom_handler)();public:static void * allocate(size_t n)&#123; void *result = malloc(n); //第一级配置器，直接使用malloc() //如果内存不足，则调用内存不足处理函数oom_alloc()来申请内存 if (0 == result) result = oom_malloc(n); return result;&#125;static void deallocate(void *p, size_t /* n */)&#123; free(p); //第一级配置器直接使用 free()&#125;static void * reallocate(void *p, size_t /* old_sz */, size_t new_sz)&#123; void * result = realloc(p, new_sz); //第一级配置器直接使用realloc() //当内存不足时，则调用内存不足处理函数oom_realloc()来申请内存 if (0 == result) result = oom_realloc(p, new_sz); return result;&#125;//设置自定义的out-of-memory handle就像set_new_handle()函数static void (* set_malloc_handler(void (*f)()))()&#123; void (* old)() = __malloc_alloc_oom_handler; __malloc_alloc_oom_handler = f; return(old);&#125;&#125;;template &lt;int inst&gt; void (* __malloc_alloc_template&lt;inst&gt;::__malloc_alloc_oom_handler)() = 0; //内存处理函数指针为空，等待客户端赋值template &lt;int inst&gt;void * __malloc_alloc_template&lt;inst&gt;::oom_malloc(size_t n)&#123; void (* my_malloc_handler)(); void *result; for (;;) &#123; //死循环 my_malloc_handler = __malloc_alloc_oom_handler; //设定自己的oom(out of memory)处理函数 if (0 == my_malloc_handler) &#123; __THROW_BAD_ALLOC; &#125; //如果没有设定自己的oom处理函数，毫不客气的抛出异常 (*my_malloc_handler)(); //设定了就调用oom处理函数 result = malloc(n); //再次尝试申请 if (result) return(result); &#125;&#125;template &lt;int inst&gt;void * __malloc_alloc_template&lt;inst&gt;::oom_realloc(void *p, size_t n)&#123; void (* my_malloc_handler)(); void *result; for (;;) &#123; my_malloc_handler = __malloc_alloc_oom_handler; if (0 == my_malloc_handler) &#123; __THROW_BAD_ALLOC; &#125; //如果自己没有定义oom处理函数，则编译器毫不客气的抛出异常 (*my_malloc_handler)(); //执行自定义的oom处理函数 result = realloc(p, n); //重新分配空间 if (result) return(result); //如果分配到了，返回指向内存的指针 &#125;&#125; 上面代码看起来复杂，其实流程是这样的： 通过allocate()申请内存，通过deallocate()来释放内存，通过reallocate()重新分配内存 当allocate()或reallocate()分配内存不足时会调用oom_malloc()或oom_remalloc()来处理 当oom_malloc() 或 oom_remalloc()还是没能分配到申请的内存时，会转如下两步中的一步： 调用用户自定义的内存分配不足处理函数(这个函数通过set_malloc_handler() 来设定)，然后继续申请内存 如果用户未定义内存分配不足处理函数，程序就会抛出bad_alloc异常或利用exit(1)终止程序 第二级配置器__default_alloc_template当申请的内存大于 128 bytes时就调用第一层配置器。当申请的内存小于 128bytes时才会调用第二层配置器。第二层配置器如何维护128bytes以下内存的配置呢？ SGI 第二层配置器定义了一个 free-lists，这个free-list是一个数组，如下图： 这个数组的元素都是指针，用来指向16个链表的表头，这16个链表上面挂的都是可以用的内存块。只是不同链表中元素的内存块大小不一样，16个链表上分别挂着大小为8、16、24、32、40、48、56、64、72、80、88、96、104、112、120、128 bytes的小额区块，图如下： 下面我们看下allocate()代码： 1234567891011121314151617181920static void * allocate(size_t n)&#123; obj * __VOLATILE * my_free_list; obj * __RESTRICT result; //要申请的空间大于128bytes就调用第一级配置 if (n &gt; (size_t) __MAX_BYTES) &#123; return(malloc_alloc::allocate(n)); &#125; //寻找 16 个free lists中恰当的一个 my_free_list = free_list + FREELIST_INDEX(n); result = *my_free_list; if (result == 0) &#123; //没找到可用的free list，准备新填充free list void *r = refill(ROUND_UP(n)); return r; &#125; *my_free_list = result -&gt; free_list_link; return (result);&#125;; 其中有两个函数我来提一下，一个是ROUND_UP()，这个是将要申请的内存字节数上调为8的倍数。因为我们free-lists中挂的内存块大小都是8的倍数嘛，这样才知道应该去找哪一个链表。另一个就是refill()。这个是在没找到可用的free list的时候调用，准备填充free lists。意思是：参考上图，假设我现在要申请大小为 56bytes 的内存空间，那么就会到free lists 的第 7 个元素所指的链表上去找。如果此时 #7元素所指的链表为空怎么办？这个时候就要调用refill()函数向内存池申请N（一般为20个）个大小为56bytes的内存区块，然后挂到 #7 所指的链表上。这样，申请者就可以得到内存块了。当然，这里为了避免复杂，误导读者我就不讨论refill()函数了。allocate()过程图如下： 下面再看下deallocate()的代码： 12345678910111213141516static void deallocate(void *p, size_t n)&#123; obj *q = (obj *)p; obj * __VOLATILE * my_free_list; //如果要释放的字节数大于128，则调第一级配置器 if (n &gt; (size_t) __MAX_BYTES) &#123; malloc_alloc::deallocate(p, n); return; &#125; //寻找对应的位置 my_free_list = free_list + FREELIST_INDEX(n); //以下两步将待释放的块加到链表上 q -&gt; free_list_link = *my_free_list; *my_free_list = q;&#125; 说明本文转载自文章浅析STL allocator。","tags":[{"name":"C++, allocator","slug":"C-allocator","permalink":"https://glemontree.github.io/tags/C-allocator/"}]},{"title":"[C++] C++中的模板","date":"2017-10-23T10:07:40.000Z","path":"2017/10/23/[C++] C++中的模板/","text":"非类型模板参数非类型模板参数可以使用整型类型、指针或引用。绑定非类型整型形参的实参必须是常量表达式，不能把普通的局部变量或者动态对象绑定指针或引用的非类型，可以使用全局类型进行绑定。 123456template &lt;const char* C&gt;void pointerT(const char* str) &#123; std::cout &lt;&lt; C &lt;&lt; \" \" &lt;&lt; str &lt;&lt; std::endl;&#125;char ca[] = \"test\";pointerT&lt;ca&gt;(\"hello\");","tags":[{"name":"C++, 模板","slug":"C-模板","permalink":"https://glemontree.github.io/tags/C-模板/"}]},{"title":"[C++] static void (* __set_malloc_handler(void (*__f)()))()","date":"2017-10-23T09:49:12.000Z","path":"2017/10/23/[C++] static void ( __set_malloc_handler(void (__f)()))()/","text":"1static void (* __set_malloc_handler(void (*__f)()))() 拆开一层一层的分析，最内部的__f是一个函数指针，其参数为void，返回值为void。 对于__set_malloc_handler，首先它是一个函数，其参数为形如__f的函数指针，其返回值也是一个指针，这个指针的类型是void(*)()。 用法如下： 123void (*foo)();void (*bar)();foo = __set_malloc_handler(bar); 下面再来看下static void (* set_malloc_handler(void (*f)()))()的完整定义： 123456static void (* set_malloc_handler(void (*f)()))()&#123; void (* old)() = __malloc_alloc_oom_handler; __malloc_alloc_oom_handler = f; return(old);&#125; 相信你应该能看懂了！！！","tags":[{"name":"C++","slug":"C","permalink":"https://glemontree.github.io/tags/C/"}]},{"title":"[Linux] Linux中的伙伴系统和slab机制","date":"2017-10-23T08:34:00.000Z","path":"2017/10/23/[Linux] Linux中的伙伴系统和slab机制/","text":"伙伴系统Linux中采用4KB大小的页框作为标准的内存分配单元，在实际应用中，经常需要分配一组连续的页框，而频繁的申请和释放不同大小的连续页框，必然导致在已分配页框的内存块中分散了许多小块的空闲页框，这样，即使这些页框是空闲的，其他需要分配连续页框的应用也很难得到满足。 Linux内核引入了伙伴系统算法来避免这种情况。其把所有的空闲页框分组为11个块链表，每个块链表分别包含大小为1、2、4、8、16、32、64、128、256、512和1024个连续页框的页框块。最大可以申请1024个连续页框，也即4MB大小的连续空间。 假设要申请一个256个页框的块，先从256个页框的链表中查找空闲块，如果没有，就去512个页框的链表中找，找到了即将页框分为两个256个页框的块，一个分配给应用，另外一个移到256个页框的链表中。如果512个页框的链表中仍没有空闲块，继续向1024个页框的链表查找，如果仍然没有，则返回错误。 页框块在释放时，会主动将两个连续的页框块合并成一个较大的页框块。 伙伴算法具有以下一些缺点： 一个很小的块往往会阻碍一个大块的合并，一个系统中，对内存块的分配，大小是随机的，一片内存中仅一个小的内存块没有释放，旁边两个大的就不能合并。 算法中有一定的浪费现象，伙伴算法是按2的幂次方大小进行分配内存块，当然这样做是有原因的，即为了避免把大的内存块拆的太碎，更重要的是使分配和释放过程迅速。但是他也带来了不利的一面，如果所需内存大小不是2的幂次方，就会有部分页面浪费。有时还很严重。比如原来是1024个块，申请了16个块，再申请600个块就申请不到了，因为已经被分割了。 另外拆分和合并涉及到 较多的链表和位图操作，开销还是比较大的。 Buddy算法的分配原理： 假如系统需要4个页面大小的内存块，该算法就到free_area[2]中查找，如果链表中有空闲块，就直接从中摘下并分配出去。如果没有，算法将顺着数组向上查找free_area[3],如果free_area[3]中有空闲块，则将其从链表中摘下，分成等大小的两部分，前四个页面作为一个块插入free_area[2]，后4个页面分配出去，free_area[3]中也没有，就再向上查找，如果free_area[4]中有，就将这16个页面等分成两份，前一半挂入free_area[3]的链表头部，后一半的8个页等分成两等分，前一半挂free_area[2]的链表中，后一半分配出去。假如free_area[4]也没有，则重复上面的过程，知道到达free_area数组的最后，如果还没有则放弃分配。 Buddy算法的释放原理： 内存的释放是分配的逆过程，也可以看作是伙伴的合并过程。当释放一个块时，先在其对应的链表中考查是否有伙伴存在，如果没有伙伴块，就直接把要释放的块挂入链表头；如果有，则从链表中摘下伙伴，合并成一个大块，然后继续考察合并后的块在更大一级链表中是否有伙伴存在，直到不能合并或者已经合并到了最大的块。 Buddy算法对伙伴的定义如下： 两个块大小相同； 两个块地址连续； 两个块必须是同一个大块中分离出来的； slab机制slab是Linux系统的一种内存分配机制，其工作是针对一些经常分配并释放的对象，如进程描述符等，这些对象的大小一般比较小，如果直接采用伙伴系统来进行分配和释放，不仅会造成大量的内存碎片，而且处理速度也太慢。而slab分配器是基于对象进行管理的，相同类型的对象归为一类（如进程描述符是一类），每次当要申请这样一个对象，slab分配器就从一个slab列表中分配一个这样大小的单元出去，而当要释放时，将其重新保存到该列表中，而不是直接返回给伙伴系统，从而避免这些内存碎片。slab分配器并不丢弃已分配的对象，而是释放并把它们保存在内存中。当以后又要请求新的对象时，就可以从内存直接获取而不用重复初始化。 说明本文转载自文章伙伴系统和slab机制。","tags":[{"name":"Linux, 内存管理, 伙伴系统, slab机制","slug":"Linux-内存管理-伙伴系统-slab机制","permalink":"https://glemontree.github.io/tags/Linux-内存管理-伙伴系统-slab机制/"}]},{"title":"[Java] Java并发编程之volatile关键字","date":"2017-10-22T02:10:59.000Z","path":"2017/10/22/[Java] Java并发编程之volatile关键字/","text":"说在前面本文转载自文章Java并发编程：volatile关键字解析，作者对volatile关键字的使用以及原理进行了详细的解析，我觉得写的非常好，所以转载下来做个记录，感谢作者。 内存模型的相关概念计算机在执行程序的时候每条指令都是在CPU中执行的，而执行指令的过程中势必涉及到数据的读取和写入。由于程序运行过程中的临时数据都是存放在主存（物理内存）当中的，这时就存在一个问题，由于CPU执行速度很快，而从内存读取数据和向内存写入数据的过程和CPU执行指令的速度相比要慢得多，因此如果任何时候对数据的操作都要通过内存的交互来进行，会大大降低指令执行的速度，因此CPU里面就有了高速缓存。 也就是，当程序运行过程中会将运算需要的数据从主存复制一份到CPU的高速缓存当中，那么CPU在进行计算时就可以直接从它的高速缓存中读取数据和向其中写入数据，当运算结束后，再将高速缓存中的数据刷新到主存中，举个简单的例子： 1i = i + 1; 当线程执行这个语句时，会先从主存中读取i的值，然后复制一份到高速缓存中，然后CPU执行指令对i进行加1操作，然后将数据写入高速缓存，最后将高速缓存中i最新的值刷新到主存当中。 这个代码在单线程中运行是没有任何问题的，但是在多线程中运行就会有问题了，在多核CPU中，每条线程可能运行于不同的CPU，因此每个线程运行时有自己的高速缓存，本文以多核CPU为例。 比如同时有2个线程执行这段代码，假设初始时的i的值为0，那么我们希望两个线程执行完之后i的值变为2，但是事实会是这样吗？ 可能存在下面这种情况：初始时，两个线程分别读取i的值存入各自所在的CPU高速缓存中，然后线程1进行加1操作，然后把i的最新值写入到内存，此时线程2的高速缓存当中i的值还是0，进行加1操作之后，i的值为1，然后线程2把i的值写入内存。 最终结果i的值为1，而不是2，这就是著名的缓存一致性问题，通常称这种被多个线程访问的变量为共享变量。 也就是说，如果一个变量在多个CPU中都存在缓存（一般在多线程编程时才会出现），那么就可能存在缓存不一致的问题。 为了解决缓存不一致的问题，通常来说有以下两种解决方法： 通过在总线加LOCK#锁的方式 通过缓存一致性协议 这两种方式都是硬件层面上提供的方式。 在早期的CPU当中，是通过在总线上加LOCK#锁的形式来解决缓存不一致的问题，因此CPU和其他部件进行通信都是通过总线来进行的，如果对总线加LOCK#锁的话，也就是说阻塞其他CPU对其他部件访问（如内存），从而使得只能有一个CPU能使用这个变量的内存，比如上面的例子中，如果一个线程在执行i=i+1，如果在执行这段代码的过程中在总线上发出了LOCK#锁的信号，那么只能等待这段代码执行完成之后其他CPU才能从变量i所在的内存中读取变量，然后进行相应的操作，这样就解决了缓存不一致的问题。 但是上面的方式存在一个问题，由于在锁住总线的过程中其他CPU无法访问内存，导致效率低下。 所以就出现了缓存一致性协议。最出名的就是Intel 的MESI协议，MESI协议保证了每个缓存中使用的共享变量的副本是一致的。它核心的思想是：当CPU写数据时，如果发现操作的变量是共享变量，即在其他CPU中也存在该变量的副本，会发出信号通知其他CPU将该变量的缓存行置为无效状态，因此当其他CPU需要读取这个变量时，发现自己缓存中缓存该变量的缓存行是无效的，那么它就会从内存重新读取。 并发编程中的三个概念在并发编程中，通常会遇到下面三个问题：原子性问题、可见性问题以及有序性问题。 原子性原子性：即一个操作或者多个操作要么全部执行并且执行的过程不会被任何因素打断，要么就全部不执行。举个最简单的例子，大家想一下假如一个32位的变量赋值过程不具备原子性的话，会发生什么后果？ 1i = 9; 假若一个线程执行到这个语句时，我暂且假设为一个32位的变量赋值包含两个过程：为低16位赋值和为高16位赋值。 那么就可能发生一种情况：当将低16位数值写入之后，突然被中断，而此时又有一个线程去读取i的值，那么读取到的值就是错误的数据。 可见性可见性就是指当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值，举个例子： 123456// 线程1执行的代码int i = 0;i = 10;// 线程2执行的代码j = i; 假若执行线程1的是CPU1，执行线程2的是CPU2，由上面的分析可知，当线程1执行i=10这句时，会先把i的初始值加载到CPU1的高速缓存中，然后赋值为10，那么在CPU1的高速缓存中i的值变为10了，却没有立即写入到主存中去。 此时线程2执行j=i，它会先去主存读取i的值并加载到CPU2的缓存当中，注意此时内存当中i的值还是0，那么就会使得j的值为0，而不是10。 这就是可见性问题，线程1对变量i修改了之后，线程2没有立即看到线程1修改的值。 有序性有序性：即程序执行的顺序按照代码的先后顺序执行。 1234int i = 0;boolean flag = false;i = 1; // 语句1flag = true; // 语句2 上面的代码定义了一个int型变量，定义了一个boolean类型变量，然后分别对这两个变量进行赋值操作，从代码顺序上看，语句1是在语句2的前面，那么JVM在真正执行这段代码的时候会保证语句1一定会在语句2前面执行吗？不一定，为什么？这里可能会发生指令重排序。 一般来说，处理器为了提高运行效率，可能会对输入代码进行优化，它不保证程序中各个语句的执行先后顺序同代码中的顺序一致，但是它会保证程序最终运行结果和代码顺序执行的结果是一致的。 比如上面的代码，语句1和语句2谁先执行对最终的程序结果并没有影响，那么就有可能在执行过程中，语句2先执行而语句1后执行。 但是要注意，虽然处理器会对指令进行重排序，但是它会保证程序最终结果会和代码顺序执行效果相同，那么它靠什么来保证呢？再看下面这个例子： 1234int a = 10; // 语句1int r = 2; // 语句2a = a + 3; // 语句3r = a * a; // 语句4 这段代码有4个语句，那么可能的一个执行顺序是： 那么可不可能是这个执行顺序呢： 语句2 语句1 语句4 语句3 不可能，因为处理器在进行重排序时是会考虑指令之间的数据依赖性，如果一个指令Instruction2 必须用到Instruction1的结果，那么处理器会保证Instruction1会在Instruction2 之前执行。 虽然重排序不会影响单个线程内程序执行的结果，但是多线程呢？ 123456789// 线程1context = loadContext(); // 语句1inited = true; // 语句2// 线程2while (!inited) &#123; sleep();&#125;doSomethingwithconfig(context); 上面代码中，由于语句1和语句2没有数据依赖性，因此可能会被重排序，假如发生了重排序，在线程1执行过程中先执行语句2，而此时线程2会以为初始化工作已经完成，那么就会跳出while循环，去执行doSomethingwithconfig(context)方法，而此时context没有被初始化，就会导致程序出错。 从上面可以看出，指令重排序不会影响单个线程的执行，但是会影响到线程并发执行的正确性。 也就是说，要想并发程序正确的执行，必须保证原子性、可见性以及有序性。只要有一个没有被保证，就有可能导致程序运行不正确。 Java内存模型Java内存模型规定所有的变量都是存在主存当中（类似于前面说的物理内存），每个线程都有自己的工作内存（类似于前面的高速缓存），线程对变量的所有操作都必须在工作内存中进行，而不能直接对主存进行操作，并且每个线程不能访问其他线程的工作内存。 举个简单的例子，在Java中，执行下面的语句： 1i = 10; 执行线程必须先在自己的工作线程中对变量i所在的缓存进行赋值操作，然后再写入主存当中，而不是直接将数值10写入主存当中。 那么Java语言本身对原子性、可见性以及有序性提供了哪些保证呢？ 原子性在Java中，对基本数据类型的变量的读取和赋值操作是原子性操作，即这些操作是不可被中断的，要么执行，要么不执行。 1234x = 10; // 语句1y = x; // 语句2x++; // 语句3x = x + 1; // 语句4 上面的语句只有语句1是原子性操作，其他3个语句都不是原子性操作。语句1是直接将数值10赋值给x，也就是说线程执行这个语句的会直接将数值10写入到工作内存中。 语句2实际上包含2个操作，它先去读取x的值，再将x的值写入工作内存，虽然读取x的值以及将x的值写入工作内存这2个操作都是原子性操作，但是合起来就不是原子性操作了。 同样地，x++和x = x + 1包含3个操作：读取x的值，进行加1操作，写入新的值。 也就是说，只有简单的读取、赋值（而且必须是将数字赋值给某个变量，变量之间的赋值不是原子操作）才是原子操作。 可见性对于可见性，Java提供了volatile关键字来保证可见性。 当一个共享变量被volatile修饰时，它会保证修改的值立即被更新到主存，当有其他线程需要读取时，它会去内存中读取新值。 而普通的共享变量不能保证可见性，因为普通共享变量被修改之后，什么时候被写入主存是不确定的，当其他线程去读取时，此时内存中可能还是原来的旧值，因此无法保证可见性。 另外，通过synchronized和Lock也能够保证可见性，synchronized和Lock能保证同一时刻只有一个线程获取锁然后执行同步代码，并且在释放锁之前会对变量的修改刷新到主存中，因此可以保证可见性。 有序性在Java内存模型中，允许编译器和处理器会指令进行重排序，但是重排序过程不会影响到单线程程序的执行，却会影响到多线程并发执行的正确性。 在Java里面，可以通过volatile关键字来保证一定的有序性，另外可以通过synchronized和Lock来保证有序性，很显然，synchronized和Lock保证每个时刻是有一个线程执行同步代码，相当于是让线程顺序执行同步代码，自然保证了有序性。 另外，Java内存模型具备一些先天的有序性，即不需要通过任何手段就能够保证的有序性，这个通常也称为happens-before原则，如果两个操作的执行次序无法从happens-before原则推倒出来，那么它们就不能保证它们的有序性，虚拟机可以随意的对它们进行重排序。 深入剖析volatile关键字volatile关键字的两层语义一旦一个共享变量（类的成员变量、类的静态成员变量）被volatile修饰之后，那么就具备了两层语义： 保证了不同线程对这个变量进行操作时的可见性，即一个线程修改了某个变量的值，这新值对其他线程来说是立即可见的 禁止进行指令重排序 先看一段代码，加入线程1先执行，线程2后执行： 12345678// 线程1boolean stop = false;while (!stop) &#123; doSomething();&#125;// 线程2stop = true; 这段代码是很典型的一段代码，很多人在中断线程时可能都会采用这种标记办法。但是事实上，这段代码会完全运行正确么？即一定会将线程中断么？不一定，也许在大多数时候，这个代码能够把线程中断，但是也有可能会导致无法中断线程（虽然这个可能性很小，但是只要一旦发生这种情况就会造成死循环了）。 下面解释一下这段代码为何有可能导致无法中断线程。在前面已经解释过，每个线程在运行过程中都有自己的工作内存，那么线程1在运行的时候，会将stop变量的值拷贝一份放在自己的工作内存当中。 那么当线程2更改了stop变量的值之后，但是还没来得及写入主存当中，线程2转去做其他事情了，那么线程1由于不知道线程2对stop变量的更改，因此还会一直循环下去。 但是用volatile修饰之后就变得不一样了： 第一：使用volatile关键字会强制将修改的值立即写入主存； 第二：使用volatile关键字的话，当线程2进行修改时，会导致线程1的工作内存中缓存变量stop的缓存行无效（反映到硬件层的话，就是CPU的L1或者L2缓存中对应的缓存行无效）； 第三：由于线程1的工作内存中缓存变量stop的缓存行无效，所以线程1再次读取变量stop的值时会去主存读取。 那么在线程2修改stop值时（当然这里包括2个操作，修改线程2工作内存中的值，然后将修改后的值写入内存），会使得线程1的工作内存中缓存变量stop的缓存行无效，然后线程1读取时，发现自己的缓存行无效，它会等待缓存行对应的主存地址被更新之后，然后去对应的主存读取最新的值。 那么线程1读取到的就是最新的正确的值。 volatile保证原子性吗？不能，volatile关键字能保证可见性没有错，但是并不能保证原子性，可见性只能保证每次读取的是最新的值，但是volatile没办法保证对变量的操作的原子性。 volatile能保证有序性吗？volatile能在一定程度上保证有序性，volatile关键字禁止指令重排序有两层意思： 当程序执行到volatile变量的读操作或者写操作时，在其前面的操作的更改肯定全部已经执行，其结果已经对后面的操作可见，在其后面的操作肯定还没有执行； 在进行指令优化时，不能将在对volatile变量访问的语句放在其后面执行，也不能把volatile变量后面的语句放在其前面执行 看下面这个例子： 1234567//x、y为非volatile变量//flag为volatile变量x = 2; //语句1y = 0; //语句2flag = true; //语句3x = 4; //语句4y = -1; //语句5 由于flag变量为volatile变量，那么在进行指令重排序的过程的时候，不会将语句3放到语句1、语句2前面，也不会将语句3放到语句4和语句5的后面，但是要注意语句1和语句2的顺序、语句4和语句5的顺序是不作任何保证的。 并且voloatile关键字能保证执行到语句3的时候，语句1和语句2必定是执行完毕的，且语句1和语句2的执行结果对语句3、语句4、语句5是可见的。 那么我们回到前面的一个例子： 123456789//线程1:context = loadContext(); //语句1inited = true; //语句2 //线程2:while(!inited )&#123; sleep()&#125;doSomethingwithconfig(context); 前面举这个例子的时候，提到有可能语句2会在语句1之前执行，那么就可能导致context还没被初始化，而线程2中就使用未初始化的context去进行操作，导致程序出错。 这里如果用volatile关键字对inited变量进行修饰，就不会出现这种问题了，因为当执行到语句2时，必定能保证context已经初始化完毕。 volatile的原理和实现机制“观察加入volatile关键字和没有加入volatile关键字时所生成的汇编代码发现，加入volatile关键字时，会多出一个lock前缀指令” lock前缀指令实际上相当于一个内存屏障（也成内存栅栏），内存屏障会提供3个功能： 它确保指令重排序时不会把其后面的指令排到内存屏障之前的位置，也不会把前面的指令排到内存屏障的后面；即在执行到内存屏障这句指令时，在它前面的操作已经全部完成； 它会强制将对缓存的修改操作立即写入主存； 如果是写操作，它会导致其他CPU中对应的缓存行无效。 使用volatile关键字的场景通常来说，使用volatile必须具备以下两个条件： 对变量的写操作不依赖于当前值 该变量没有包含在具有其他变量的不变式中 实际上这些条件表明可以被写入volatile变量的这些有效值独立于任何程序的状态，包括变量的当前状态。 事实上，上面的这两个条件需要保证操作是原子性操作，才能保证使用volatile关键字的程序在并发时能够正确执行。 状态标记量 123456789volatile boolean flag = false; while(!flag)&#123; doSomething();&#125; public void setFlag() &#123; flag = true;&#125; 12345678910volatile boolean inited = false;//线程1:context = loadContext(); inited = true; //线程2:while(!inited )&#123;sleep()&#125;doSomethingwithconfig(context); double check 1234567891011121314151617class Singleton&#123; private volatile static Singleton instance = null; private Singleton() &#123; &#125; public static Singleton getInstance() &#123; if(instance==null) &#123; synchronized (Singleton.class) &#123; if(instance==null) instance = new Singleton(); &#125; &#125; return instance; &#125;&#125; ​","tags":[{"name":"Java 并发 volatile","slug":"Java-并发-volatile","permalink":"https://glemontree.github.io/tags/Java-并发-volatile/"}]},{"title":"[Java] Java面试题","date":"2017-10-20T09:54:39.000Z","path":"2017/10/20/[Java] Java面试题/","text":"String类为什么是final的？ 从设计安全上讲，确保不会在子类中改变语义，String类是final类，这意味着不允许任何人定义String的子类，也就是说，如果有一个String的引用，它引用的一定是String对象，而不可能是其他类的对象 从效率上讲，设计成final，JVM才不用对相关方法在虚函数表中查询，而直接定位到String类的相关方法上，提高了执行效率 HashMap和Hashtable的区别 两者最主要的区别是Hashtable是线程安全的，而HashMap是非线程安全的 Hashtable的实现方法里都添加了synchronized关键字来确保线程同步，因此相对而言HashMap性能会高一些，平时使用时若无特殊需求建议使用HashMap，在多线程环境下若使用HashMap需要使用Collections.synchronizedMap()方法来获取一个线程安全的集合 HashMap可以使用null作为key，而Hashtable则不允许使用null作为key HashMap的初始容量是16，Hashtable的初始容量是11，两者的填充因子默认是0.75，HashMap扩容时是当前容量翻倍即capacity*2，而Hashtable扩容时是容量翻倍+1即capacity*2 + 1 HashMap和Hashtable的实现原理 HashMap和Hashtable的底层实现都是数组+链表结构实现的，添加、删除、获取元素时都是先计算hash，根据hash和table.length计算index也就是table数组的下标，然后进行相应操作 class.forName()和classLoader的区别 class.forName()除了将类的.class文件加载到jvm中之外，还会对类就行解释，执行类中的static块，而classLoader只干一件事情，就是将.class文件加载到jvm中，不会指定static中的内容，只有在newInstance才会去执行static块 Session和Cookie的区别和联系 Cookie实际上是一小段的文本信息，客户端请求服务器，如果服务器需要记录该用户状态，就使用response向客户端浏览器颁发一个Cookie，客户端会把Cookie保存起来。 当浏览器再次请求该网站时，浏览器把请求的网址连同该Cookie一同提交给服务器，服务器检查该Cookie，以此来辨认用户状态，服务器还可以根据需要修改Cookie的内容。 Session是另一种记录客户状态的机制，不同的是Cookie保存在客户端浏览器上，而Session保存在服务器上，客户端浏览器访问服务器的时候，服务器把客户信息以某种形式记录在服务器上，这就是Session，客户端浏览器再次访问时只需要从该Session中查找该客户的状态即可。每个用户访问服务器都会建立一个Session，用户和服务器建立连接的同时，服务器会自动会其分配一个SessionId。 什么东西可以让你每次请求都把SessionId自动带到服务器呢？显然是Cookie。当程序需要为某个客户端的请求创建一个Session时，服务器会首先检查这个客户端的请求中是否已经包含了sessionId，如果已包含则说明以前已经为此客户端创建过session，服务器就按照sessionId把这个session检索出来使用（检索不到，会新建一个），如果客户端请求不包含sessionId，则为此客户端创建一个session并且生成一个与此session相关联的sessionId，这个sessionId将被在本次响应中返回给客户端保存。 如果客户端禁用了cookie，通常有两种方法实现session而不依赖cookie： URL重写，就是把sessionId直接附加到URL路径的后面 表单隐藏字段，就是服务器会自动修改表单，添加一个隐藏字段，以便在表单提交时能够把sessionId床底回服务器。 Session的生命周期 Session存储在服务端，一般放置在服务器的内存中（为了高速存取），Session在用户第一次访问服务器时创建，需要注意的是只有访问JSP、Servlet等程序时才会创建Session，只访问HTML、IMAGE等静态资源并不会创建Session。 服务器会把长时间没有活动的Session从服务器内存中移除，此时Session失效，Tomcat中Session的默认失效时间是20分钟，当然你也可以调用Session的invalidate方法。 Session对浏览器的要求 虽然Session保存在服务端，对客户端是透明的，它的正常运行仍然需要客户端浏览器的支持，这是因为Session需要时会用Cookie作为识别标志。Http协议是无状态的，Session不能依据HTTP连接来判断是否为同一客户，因此服务器向客户端浏览器发送一个名为JSESSIONID的Cookie，它的值为该Session的Id，Session一看该Cookie来识别是否为同一用户。 该Cookie是服务器自动生成的，它的maxAge属性为-1，表示仅当前浏览器内有效，并且各浏览器窗口间不共享，关闭浏览器会失效，因此同一机器的两个浏览器窗口访问服务器时会生成两个不同的Session，但是由浏览器窗口内的链接、脚本打开的新窗口（也就是说不是双击桌面浏览器图标等打开的窗口）除外，这类子窗口会共享父窗口的Cookie，因此会共享一个Session。 新开的浏览器窗口会生成新的Session，但子窗口除外，子窗口会共用父窗口的Session，例如，在链接上右击，在弹出的快捷菜单上选择在“新窗口中打开”时，子窗口便可以访问父窗口的Session。 Struts2和SpringMVC Struts2是类级别的拦截，一个类对应一个request上下文，SpringMVC是方法级别的拦截，一个方法对应一个request上下文 SpringMVC的方法之间基本上是独立的，独享request response数据，请求数据通过参数获取，处理结果通过ModelMap交回给框架，方法之间不共享变量 SpringMVC的入口是Servlet，而Struts2是filter Struts2需要定义属性来获取请求中参数的数据，而属性在一个类的方法间是共享的（方法间不能独享request、response数据），而SpringMVC中请求参数与Controller中方法的形参自动配对，方法间可以独享request、response数据 SpringMVC集成了Ajax，使用非常方便，只需一个注解@ResponseBody就可以实现，然后直接返回响应文本即可，而Struts2拦截器集成了Ajax，在Action中处理一般需要安装插件或者自己写代码集成进去。 Spring中BeanFactory和ApplicationContext的区别 BeanFactory采用的是延迟加载的方式来注入Bean的，而ApplicationContext是在容器启动时一次性创建所有的Bean BeanFactory和ApplicationContext都支持BeanPostProcessor、BeanFactoryPostProcessor的使用，但两者的区别是BeanFactory需要手动注册，而ApplicationContext则是自动注册 BeanFactory是Spring中比较原始的Factory，如XMLBeanFactory就是一种典型的BeanFactory，原始的BeanFactory无法支持Spring的许多插件，如AOP功能、WEB应用等 ApplicationContext接口由BeanFactory接口派生而来，因而提供BeanFactory所有的功能 Spring循环注入 构造器循环依赖 表示通过构造器注入构成的循环依赖，此依赖是无法解决的，只能抛出BeanCurrentlyInCreationException异常表示循环依赖。 Spring容器将每一个正在创建的Bean标识符放在一个“当前创建bean池”中，bean标识符在创建过程中将一直保持在这个池中，因此如果在创建bean过程中发现自己已经在“当前创建bean池”里时，将抛出BeanCurrentlyInCreationException异常表示循环依赖，而对于创建完毕的bean将从“当前创建bean池”中清除掉。 setter循环依赖 表示通过setter注入方式构成的循环依赖，对于setter注入造成的依赖是通过Spring容器提前暴露刚完成构造器注入但未完成其他步骤（如setter注入）的bean来完成的，而且只能解决单例作用域的bean循环依赖 prototype范围的依赖处理 对于prototype作用域bean，Spring容器无法完成循环依赖注入，因为Spring容器不进行缓存prototype作用域的bean，因此无法提前暴露一个创建中的bean Spring事务管理 Spring并不直接管理事务，而是提供了多种事务管理器，他们将事务管理的职责委托给Hibernate或者JTA等持久化机制所提供的相关平台框架的事务来实现。 Spring事务管理器的接口是org.springframework.transaction.PlatformTransactionManager，通过这个接口Spring为各个平台如JDBC、Hibernate等都提供了对应的事务管理器，但是具体的实现就是各个平台自己的事情了： 12345678Public interface PlatformTransactionManager()...&#123; /* 由TransactionDefinition得到TransactionStatus对象 */ TransactionStatus getTransaction(TransactionDefinition definition) throws TransactionException; /* 提交 */ Void commit(TransactionStatus status) throws TransactionException; /* 回滚 */ Void rollback(TransactionStatus status) throws TransactionException; &#125; JDBC事务 如果应用程序中直接使用JDBC来进行持久化，DataSourceTransactionManager会为你处理事务边界，为了使用DataSourceTransactionManager，你需要使用如下的XML将其装配到应用程序的上下文定义中： 123&lt;bean id=\"transactionManager\" class=\"org.springframework.jdbc.datasource.DataSourceTransactionManager\"&gt; &lt;property name=\"dataSource\" ref=\"dataSource\" /&gt;&lt;/bean&gt; Hibernate事务 如果应用程序的持久化是通过Hibernate实现的，那么你需要使用HibernateTransactionManager，对于Hibernate3，需要在Spring上下文定义中添加如下的声明： 123&lt;bean id=\"transactionManager\" class=\"org.springframework.orm.hibernate3.HibernateTransactionManager\"&gt; &lt;property name=\"sessionFactory\" ref=\"sessionFactory\" /&gt;&lt;/bean&gt; Java持久化API事务（JPA） 如果你需要使用JpaTransactionManager来处理事务，你需要在Spring中这样配置： 123&lt;bean id=\"transactionManager\" class=\"org.springframework.orm.jpa.JpaTransactionManager\"&gt; &lt;property name=\"sessionFactory\" ref=\"sessionFactory\" /&gt;&lt;/bean&gt; Java原生API事务 如果你没有使用以上所述的事务管理，或者是跨越了多个事务管理源（比如两个或者是多个不同的数据源），你就需要使用JtaTransactionManager： 123&lt;bean id=\"transactionManager\" class=\"org.springframework.transaction.jta.JtaTransactionManager\"&gt; &lt;property name=\"transactionManagerName\" value=\"java:/TransactionManager\" /&gt;&lt;/bean&gt; Java创建线程之后，直接调用start()方法和run()的区别 start与run方法的主要区别在于当程序调用start方法一个新线程将会被创建，并且在run方法中的代码将会在线程上执行，然而如果你直接调用run方法，程序并不会创建新线程，run方法内部的代码将在当前线程上运行 Java中的线程池 new Thread的弊端 每次new Thread新建对象性能差 线程缺少统一管理，可能无限制创建线程，相互之间竞争 缺乏更多功能，如定时执行、定期执行、线程中断 使用线程池的好处 重用存在的线程，减少对象的创建、消亡的开销，性能佳 可有效控制最大并发线程数，提高系统资源的使用率 提供定时执行、定期执行、单线程、并发数控制等功能 Java通过Executors提供四种线程池： newCachedThreadPool创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，如无可回收，则新建线程 newFixedThreadPool创建一个定长线程池，可控制线程最大并发数，超出的线程会在队列中等待 newScheduledThreadPool创建一个定长线程池，支持定时及周期性任务执行 newSingleThreadExecutor创建一个单线程化的线程池，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序（FIFO、LIFO、优先级）执行。 Spring中controller默认是单例！ Spring的controller为什么默认是单例呢？原因有二： 为了性能 不需要多例 单例不需要每次都new，自然性能要高，对于第二个原因，如果你给controller中定义了很多的属性，那么单例肯定会出现竞争访问，因此，只要在controller中不定义属性，那么单例就是安全的 synchronized和Lock synchronized 需要对一个方法进行同步，那么只需在方法的签名添加一个synchronized关键字： 123public synchronized void test() &#123; &#125; synchronized也可以用在一个代码块上： 12345public void test() &#123; synchronized(obj) &#123; ... &#125;&#125; synchronized用在方法和代码块上有什么区别呢？ synchronized用在方法签名上，当某个线程调用此方法时，会获取该实例的对象锁，方法未结束之前，其他线程只能去等待，当这个方法执行完后，才会释放对象锁，其他线程才有机会去抢占这把锁，但是发生这一切的基础应当是所有线程使用的同一个对象实例，才能实现互斥的现象。 但是如果该方法为类方法，即其修饰符为static，那么synchronized意味着某个调用此方法的线程当前会拥有该类的锁，只要该线程持续在当前方法内运行，其他线程依然无法获取方法的使用权。 而当synchronized用在代码块上时，就会拥有obj对象的对象锁，如果多个线程共享同一个Object对象，那么此时就会产生互斥，特别的，当obj == this时，表示当前调用该方法的实例对象，即： 123456public void test() &#123; ... synchronized(this) &#123; ... &#125;&#125; 此时，其效果等同于： 123public synchronized void test() &#123; ...&#125; 使用synchronized代码块，可以只对需要同步的代码进行同步，这样可以大大提高效率。 ReentrantLock ReentrantLock 与synchronized有相同的并发性和内存语义，还包含了中断锁等候和定时锁等候，意味着线程A如果先获得了对象obj的锁，那么线程B可以在等待指定时间内依然无法获取锁，那么就会自动放弃该锁。 但是由于synchronized是在JVM层面实现的，因此系统可以监控锁的释放与否，而ReentrantLock使用代码实现的，系统无法自动释放锁，需要在代码中finally子句中显式释放锁lock.unlock()； 使用建议 在并发量比较小的情况下使用synchronized是个不错的选择，但是在并发量比较高的情况下其性能下降很严重，此时ReentrantLock是个不错的选择。 wait()与notify()、notifyAll() 这三个方法都是Object的方法，并不是线程的方法。 wait()：释放占用的对象锁，线程进入等待池，释放CPU，而其他正在等待的线程即可抢占此锁，获得锁的线程即可运行程序。而sleep()不同的是线程调用此方法后会休眠一段时间，休眠期间会暂时释放CPU，但不释放对象锁，也就是说，在休眠期间，其他线程依然无法进入此代码内部，休眠结束，线程重新获得CPU，执行代码。wait()和sleep()最大的不同在于wait()会释放对象锁，而sleep()不会。 notify()：该方法会唤醒因为调用对象的wait()而等待的线程，其实就是对对象锁的唤醒，从而使得wait()的线程可以有机会获取对象锁。调用notify()后，并不会立即释放锁，而是继续执行当前代码，直到synchronized中的代码执行完毕，才会释放对象锁，JVM会在等待的线程中调用一个线程去获取对象锁，执行代码，需要注意的是，wait()和notify()必须在synchronized代码块中调用。 如何通过反射来创建对象？ 通过类对象调用newInstance()方法，适用于无参构造方法，例如： 1String.class.newInstance(); 1234567891011121314151617public class Solution &#123; public static void main(String[] args) throws Exception &#123; Solution solution = Solution.class.newInstance(); Solution solution2 = solution.getClass().newInstance(); Class solutionClass = Class.forName(\"Solution\"); Solution solution3 = (Solution) solutionClass.newInstance(); System.out.println(solution instanceof Solution); //true System.out.println(solution2 instanceof Solution); //true System.out.println(solution3 instanceof Solution); //true &#125; &#125; 通过类对象的getConstructor()或getDeclaredConstructor()方法获得构造器对象并调用其newInstance()方法来创建对象，适用于无参和有参的构造方法。 123456789101112131415161718192021222324252627282930313233343536public class Solution &#123; private String str; private int num; public Solution() &#123; &#125; public Solution(String str, int num) &#123; this.str = str; this.num = num; &#125; public Solution(String str) &#123; this.str = str; &#125; public static void main(String[] args) throws Exception &#123; Class[] classes = new Class[] &#123; String.class, int.class &#125;; Solution solution = Solution.class.getConstructor(classes).newInstance(\"hello1\", 10); /* hello1 */ System.out.println(solution.str); Solution solution2 = solution.getClass().getDeclaredConstructor(String.class).newInstance(\"hello2\"); /* hello2 */ System.out.println(solution2.str); /* 无参也可用getConstructor() */ Solution solution3 = (Solution) Class.forName(\"Solution\").getConstructor().newInstance(); /* true */ System.out.println(solution3 instanceof Solution); &#125;&#125; getConstructor()和getDeclaredConstructor()区别： getDeclaredConstructor(Class&lt;?&gt;… parameterTypes)这个方法会返回制定参数类型的所有构造器，包括public的和非public的，当然也包括private的。getDeclaredConstructors()的返回结果就没有参数类型的过滤了。 再来看getConstructor(Class&lt;?&gt;… parameterTypes)这个方法返回的是上面那个方法返回结果的子集，只返回制定参数类型访问权限是public的构造器。getConstructors()的返回结果同样也没有参数类型的过滤。 CountDownLatch 现有一个任务A，它要等待其他4个任务执行完毕后才能执行，此时就可以使用CountDownLatch来实现： 1234public CountDonwLatch(int count); // 构造方法public void await() throws InterruptedException; // 调用await()方法的线程将会被挂起，它会等到直到count值为0才继续执行public boolean await(long timeout, TimeUnit unit) throws InterruptedException; // 和await()相似，但是只不过等待一定的时间后count值还没变0的话会继续执行public void countDown(); // 将count值减1 例子如下： 12345678910111213141516171819202122232425262728293031323334353637383940public class Test &#123; public static void main(String[] args) &#123; final CountDownLatch latch = new CountDownLatch(2); new Thread()&#123; public void run() &#123; try &#123; System.out.println(\"子线程\"+Thread.currentThread().getName()+\"正在执行\"); Thread.sleep(3000); System.out.println(\"子线程\"+Thread.currentThread().getName()+\"执行完毕\"); latch.countDown(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;; &#125;.start(); new Thread()&#123; public void run() &#123; try &#123; System.out.println(\"子线程\"+Thread.currentThread().getName()+\"正在执行\"); Thread.sleep(3000); System.out.println(\"子线程\"+Thread.currentThread().getName()+\"执行完毕\"); latch.countDown(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;; &#125;.start(); try &#123; System.out.println(\"等待2个子线程执行完毕...\"); latch.await(); System.out.println(\"2个子线程已经执行完毕\"); System.out.println(\"继续执行主线程\"); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 执行结果如下： 1234567线程Thread-0正在执行线程Thread-1正在执行等待2个子线程执行完毕...线程Thread-0执行完毕线程Thread-1执行完毕2个子线程已经执行完毕继续执行主线程 各大公司Java后端开发面试题总结 String、StringBuffer和StringBuilder的区别 String String为字符串常量，字符串长度不可变 StringBuffer 字符串变量，其为线程安全的，如果要频繁对字符串内容进行修改，出于效率考虑最好使用StringBuffer，如果要转成String类型，可以调用StringBuffer的toString()方法 StringBuilder 字符串变量，非线程安全 因此，如果要操作少量的数据，用String，单线程操作大量数据，用StringBuilder，多线程操作大量数据，用StringBuffer。 TreeMap的内部实现原理 TreeMap的结构是红黑树， SpringMVC的controller是单例吗？ 尽量不要在Controller里面去定义属性，如果在特殊情况下需要定义属性的话，那么就在类上面加上注解@Scope(&quot;prototype&quot;)改为多例的模式，以前Struts2是基于类的属性进行开发的，定义属性可以整个类通用，所以默认是多例，不然多线程访问肯定是不安全的。但是SpringMVC是基于方法的开发，都是用形参接收值，一个方法结束参数就销毁了，多线程访问都会有一些内存空间产生，里面的参数是不会共有的，所以SpringMVC默认使用了单例所以controller里面不适合在类里面定义属性，只要controller中不定义属性，那么单例完全是安全的。springmvc这样设计主要的原因也是为了提高程序的性能和以后程序的维护只针对业务的维护就行，要是struts的属性定义多了，都不知道哪个方法用了这个属性，对以后程序的维护还是很麻烦的。 classpath JDK安装完后如果没有设置环境变量CLASSPATH，则系统默认的类路径包括java系统类路径和当前目录。比如你的当前工作目录是E:\\，在此目录下有class1.class，你可以直接使用”java class1”运行这个类。但是如果切换到别的目录，再使用”java class1”会出现NoClassDefFoundError，此时需要指定运行参数classpath。使用”java -classpath E:\\ class1”运行class1.class。 如果class1引用了其他的类，那么被引用的类也需要在E:\\目录下，否则应该在classpath参数中指定被引用类所在的目录，比如class1引用了class2.class，class2.class位于F:\\目录下，使用”java -classpath E:\\;F:\\ class1”来运行class1。 如果被引用的是一个jar文件，那么在classpath中需要指明具体的jar文件，而不能只包括jar文件所在的目录。比如，class1引用了jar1.jar，这个jar文件位于C:\\目录下，则使用”java -classpath E:\\;C:\\jar1.jar class1”来运行class1。 在非class1.class所在的目录下运行class时，classpath参数需要指明class1以及class1所引用的类的路径，如果在class1.class所在目录运行该类，同样需要在classpath中包括当前目录，因为使用-classpath时不再会默认当前目录为类路径。比如在E:\\下要使用”java -classpath .;F:\\ class1”来运行class1。 “java -classpath e:\\ class1”不能写成”java class1 -classpath e:\\”。 使用javac编译java文件时，可以使用-classpath指定class1.class所引用的类文件所在的目录。在D:\\目录下编译class1.java使用”javac E:\\class1.java -classpath F:\\”如果引用的是jar文件，同样需要指明jar文件。”javac E:\\class1.java -classpath C:\\jar1.jar”。 javac -classpath F:\\ E:\\class1.java可以写成javac E:\\class1.java -classpath F:\\。 类的实例化顺序 执行父类的静态变量赋值和静态代码块 执行子类的静态变量赋值和静态代码块 执行父类的成员变量赋值语句 执行父类构造方法 执行子类的成员变量赋值语句 执行子类构造方法 索引失效的情况 如果条件中有or，即使其中有条件带索引也不会使用，要想使用or，又想让索引生效，只能将or条件中的每个列都加上索引 对于多列索引，不是使用的第一部分，则不会使用索引 like查询是以%开头 如果列类型是字符串，那一定要在条件中将数据使用引号引用起来，否则不使用索引 如果mysql估计使用全表扫描比使用索引快，则不使用索引 受检异常和运行时异常 运行时异常是运行时才会发生的异常，而受检异常是编译时异常。 除了runtimeException以外的异常都属于checkedException，Java编译器要求程序必须捕获或声明受检异常。 Session Session的典型应用是存放用户的Login信息，如用户名、密码、权限角色等信息。 Session对象在浏览器中的有效范围 Session对象只在建立Session对象的窗口中有效 在建立Session对象的窗口中新开链接的窗口也有效 Cookie是在服务器给客户端一个命令后在客户端产生并保存的，它可以存放用户信息，存在客户端硬盘上 Session和Cookie是不同的，但它们却是相关的，当打开浏览器登入后，会向服务器发出一个命令请求SESSIONID以及页面内容，服务器会返回页面内容和一个没有被使用的SESSIONID让此浏览器使用，当时浏览器就会对返回的SESSIONID进行存储，而当此浏览器再访问任何这个站点的JSP的时候都会给服务器这个SESSIONID，来确认客户端的身份。 Linux中查看某个端口是否被占用 lsof 使用命令lsof -i:端口号可以查看某个端口是否被占用 netstat 使用命令netstat -anp | grep 端口号 Spring的事务隔离级别 ISOLATION_DEFAULT（一般情况下使用这种配置即可） ISOLATION_READ_UNCOMMITTED 这是事务最低的隔离级别，它允许另外一个事务可以看到这个事务未提交的数据，这种隔离级别会产生脏读、不可重复读以及幻象读 ISOLATION_READ_COMMITTED 保证一个事务修改的数据提交后才能被另外一个事务读取，另外一个事务不能读取该事务未提交的数据，这种事务隔离级别可以避免脏读出现，但是可能会出现不可重复读和幻象读 ISOLATION_REPEATABLE_READ 这种事务隔离级别可以防止脏读、不可重复读，但是可能出现幻象读。 什么是不可重复读？（修改引起） 例如：在事务A中，读取到张三的工资为5000，操作没有完成，事务还没提交。与此同时，事务B把张三的工资改为8000，并提交了事务。随后，在事务A中，再次读取张三的工资，此时工资变为8000。在一个事务中前后两次读取的结果并不致，导致了不可重复读。(大部分数据库缺省的事物隔离级别都不会出现这种状况) 。 ISOLATION_SERIALIZABLE 这是花费最高代价但是最可靠的事务隔离级别，事务被处理为顺序执行，除了防止脏读、不可重复读外，还避免了幻读。 什么是幻读？（添加新纪录引起） 例如:A目前工资为5000的员工有10人，事务A读取所有工资为5000的人数为10人。此时，事务B插入一条工资也为5000的记录。这是，事务A再次读取工资为5000的员工，记录为11人。此时产生了幻读。大部分数据库缺省的事物隔离级别都会出现这种状况，此种事物隔离级别将带来表级锁) Iterator遍历Collection时，是fail-fast机制的，即当某一个线程A通过iterator去遍历某集合的过程中，若该集合的内容被其他线程改变了，那么线程A访问集合时，就会抛出ConcurrentModificationException异常，产生fail-fast事件。 ArrayList的操作不是线程安全的，所以，建议在单线程中使用ArrayList，而在多线程中可以选择Vector或者CopyOnWriteArrayList。 ArrayList实际上是通过一个数组去保存数据的，当我们构造ArrayList时，若使用默认构造函数，则ArrayList的默认容量大小是10；当ArrayList容量不足时，ArrayList会重新设置容量：新的容量=（原始容量×3）/2 + 1；ArrayList的克隆函数，即是将全部元素克隆到一个数组中；ArrayList实现java.io.Serializable的方式即是当写入到输出流时，先写入容量，再依次写入每一个元素，当读出输入流时，先读取容量，再依次读取每一个元素 遍历ArrayList时，使用随机访问（通过索引号访问）效率最高，其次是for循环遍历，使用迭代器的效率最低 组合索引 组合索引即为由多个列构成的索引，创建组合索引create index idx_detp on detp(col1, col2, col3, ...)，则我们称idx_detp索引为组合索引。 在组合索引中有一个重要的概念就是引导列， 在上面的例子中col1即为引导列，当我们进行查询时where限制条件必须有引导列。 使用组合索引的情况（where条件中有引导列） where col1 = where col1 = and col2 = where col2 = and col1 = 不会使用索引（where条件中没有引导列） where col2 = ，这种查询因为没有引导列所以不会使用组合索引。 普通索引 其sql格式是： 1CREATE INDEX IndexName ON `TableName`(`字段名(length)`) 或者 1ALTER TABLE TableName ADD INDEX IndexName(`字段名(length)`) 唯一索引 与普通索引类似，但是不同的是唯一索引要求所有的类的值是唯一的，这一点和主键索引一样，但是它允许有空值，其sql语句格式是： 1CREATE UNIQUE INDEX IndexName ON `TableName`(`字段名(length)`) 主键索引 不允许有空值（在B+TREE的InnoDB引擎中，主键索引起到了至关重要的地位）。主键索引的建立规则是int优于varchar，一般在建表的时候创建，最好是与表的其他字段不相关的列或者是业务不相关的列，一般会设为int，而且是AUTO_INCREMENT自增类型的。 Struts2中action默认是非线程安全的，每次请求在heap中new新的action实例，所以在Struts2中action可以用实例成员变量。 ThreadLocal ThreadLocal为变量在每个线程中创建了一个副本，那么每个线程都可以访问自己内部的副本变量。 ThreadLocal具有以下一些方法： 1234public T get() &#123;&#125;public void set(T value) &#123;&#125;public void remove() &#123;&#125;protected T initialValue() &#123;&#125; get()方法用来获取ThreadLocal在当前线程中保存的变量副本，set()方法用来设置当前线程中变量的副本，remove()用来移除当前线程中变量的副本。 String是最基本的数据类型吗？ 不是，Java中的基本数据类型有：byte、short、int、long、float、double、char、boolean，其他都是引用类型。 int和Integer的区别 Java为每一个基本数据类型都引入了对应的包装类型，int的包装类型就是Integer，从Java5开始引入了自动装箱/拆箱机制，使得两者可以相互转换。 1234567class AutoUnboxingTest &#123; Integer a = new Integer(3); Integer b = 3; // 将3自动装箱成Integer类型 int c = 3; System.out.println(a == b); // false 两个引用没有引用同一对象 System.out.println(a == c); // true a自动拆箱成int类型再和c比较&#125; 再看下面这个例子： 1234567public class Test03 &#123; public void main(String[] args) &#123; Integer f1 = 100, f2 = 100, f3 = 150, f4 = 150; System.out.println(f1 == f2); System.out.println(f3 == f4); &#125;&#125; 首先需要注意的是f1、f2、f3、f4四个变量都是Integer对象引用，所以下面的==运算比较的不是值而是引用。装箱的本质是什么呢？当我们给一个Integer对象赋一个int值的时候，会调用Integer类的静态方法valueOf，如果看看valueOf的源代码就知道发生了什么。 12345public static Integer valueOf(int i) &#123; if (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high) return IntegerCache.cache[i + (-IntegerCache.low)]; return new Integer(i);&#125; IntegerCache是Integer的内部类，其代码如下所示： 123456789101112131415161718192021222324252627282930313233private static class IntegerCache &#123; static final int low = -128; static final int high; static final Integer cache[]; static &#123; // high value may be configured by property int h = 127; String integerCacheHighPropValue = sun.misc.VM.getSavedProperty(\"java.lang.Integer.IntegerCache.high\"); if (integerCacheHighPropValue != null) &#123; try &#123; int i = parseInt(integerCacheHighPropValue); i = Math.max(i, 127); // Maximum array size is Integer.MAX_VALUE h = Math.min(i, Integer.MAX_VALUE - (-low) -1); &#125; catch( NumberFormatException nfe) &#123; // If the property cannot be parsed into an int, ignore it. &#125; &#125; high = h; cache = new Integer[(high - low) + 1]; int j = low; for(int k = 0; k &lt; cache.length; k++) cache[k] = new Integer(j++); // range [-128, 127] must be interned (JLS7 5.1.7) assert IntegerCache.high &gt;= 127; &#125; private IntegerCache() &#123;&#125;&#125; 简单的说，如果整型字面量的值在-128到127之间，那么不会new新的Integer对象，而是直接引用常量池中的Integer对象，所以上面的面试题中f1==f2的结果是true，而f3==f4的结果是false。 方法区和堆是各个线程共享的内存区域，用于存储已经被JVM加载的类信息，常量，静态变量，JIT编译器编译后的代码等数据。程序中的字面量和常量都是放在常量池中的，常量池是方法区的一部分。 Collection是一个接口，它是Set、List等容器的父接口，Collections是一个工具类，提供了一系列的静态方法来辅助容器操作，这些方法包括对容器的搜索、排序、线程安全化等等。 List、Set、Map是否继承自Collection接口？ List、Set是，Map不是，Map是键值对映射容器，与List和Set有明显的区别，而Set存储的是零散的元素且不允许有重复的元素。 怎样将GB2312编码的字符串转换为ISO-8859-1编码的字符串？ 12String s1 = \"你好\"!;String s2 = new String(s1.getBytes(\"GB2312\"), \"ISO-8859-1\"); 如何将字符串类型转换为基本数据类型？ 调用基本数据类型对应的包装类中的方法parseXXX(String)或valueOf(String)即可返回相应基本类型 如何将基本数据类型转换为字符串？ 将基本数据类型和空字符串（””）连接（+）即可 调用String类中的valueOf方法返回相应字符串 接口可以继承接口，而且支持多重继承 抽象方法是否可同时是静态的、是否可同时是本地方法、是否可同时被synchronized修饰？ 都不能，抽象方法需要子类去重写，而静态的方法是属于类的，因此不能被重写，所以抽象方法不能是静态的；本地方法是由本地代码（C代码）实现的方法，而抽象方法是没有实现的，所以也不行；synchronized和方法的实现细节有关，抽象方法不涉及实现细节，因此也是不行的！ Java IO流 字符流（读取和存储纯文本文件） Java API提供了FileWriter和FileReader类来进行字符流的读写： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253package org.example.io;import java.io.File;import java.io.FileNotFoundException;import java.io.FileReader;import java.io.FileWriter;import java.io.IOException;public class TestFileWriter &#123; public static void main(String[] args) throws Exception &#123; writeToFile(); readFromFile(); &#125; /** * DOC 从文件里读取数据. * * @throws FileNotFoundException * @throws IOException */ private static void readFromFile() throws FileNotFoundException, IOException &#123; File file = new File(\"E:\\\\helloworld.txt\");// 指定要读取的文件 FileReader reader = new FileReader(file);// 获取该文件的输入流 char[] bb = new char[1024];// 用来保存每次读取到的字符 String str = \"\";// 用来将每次读取到的字符拼接，当然使用StringBuffer类更好 int n;// 每次读取到的字符长度 while ((n = reader.read(bb)) != -1) &#123; str += new String(bb, 0, n); &#125; reader.close();// 关闭输入流，释放连接 System.out.println(str); &#125; /** * DOC 往文件里写入数据. * * @throws IOException */ private static void writeToFile() throws IOException &#123; String writerContent = \"hello world,你好世界\";// 要写入的文本 File file = new File(\"E:\\\\helloworld.txt\");// 要写入的文本文件 if (!file.exists()) &#123;// 如果文件不存在，则创建该文件 file.createNewFile(); &#125; FileWriter writer = new FileWriter(file);// 获取该文件的输出流 writer.write(writerContent);// 写内容 writer.flush();// 清空缓冲区，立即将输出流里的内容写到文件里 writer.close();// 关闭输出流，施放资源 &#125;&#125; 字节流（读取和存储图片） Java API提供了FileInputStream和FileOutputStream来完成字节流的读写： 1234567891011121314151617181920212223242526272829303132package org.example.io;import java.io.File;import java.io.FileInputStream;import java.io.FileOutputStream;public class TestIOStream &#123; /** * * DOC 将F盘下的test.jpg文件，读取后，再存到E盘下面. * * @param args * @throws Exception */ public static void main(String[] args) throws Exception &#123; FileInputStream in = new FileInputStream(new File(\"F:\\\\test.jpg\"));// 指定要读取的图片 File file = new File(\"E:\\\\test.jpg\"); if (!file.exists()) &#123;// 如果文件不存在，则创建该文件 file.createNewFile(); &#125; FileOutputStream out = new FileOutputStream(new File(\"E:\\\\test.jpg\"));// 指定要写入的图片 int n = 0;// 每次读取的字节长度 byte[] bb = new byte[1024];// 存储每次读取的内容 while ((n = in.read(bb)) != -1) &#123; out.write(bb, 0, n);// 将读取的内容，写入到输出流当中 &#125; out.close();// 关闭输入输出流 in.close(); &#125;&#125; 字节流和字符流 首先明确字节和字符的大小： 1byte = 8bit 1char = 2byte = 16bit（Java默认UTF-16编码） 下面让看下具体看下字节流和字符流： 字节流 Java中的字节流处理的最基本单位是单个字节，它通常用来处理二进制数据，Java中最基本的两个字节流是InputStream和OutputStream，它们分别代表了最基本的输入字节流和输出字节流。InputStream和OutputStream均为抽象类。 InputStream类中定义了一个基本的用于从字节流中读取字节的方法read，这个方法的定义如下： 1public abstract int read() throws IOException; 这是一个抽象方法，其功能是从字节流中读取一个字节，若到了末尾则返回-1，否则返回读入的字节。 字符流 Java中字符流处理的最基本的单元是Unicode码元（大小2字节），它通常用来处理文本数据。所谓Unicode码元，也就是一个Unicode代码单元，范围是0x0000~0xFFFF，在以上范围内的每个数字都与一个字符相对应，Java的String类型默认就把字符以Unicode规则编码而后保存在内存中，然而与存储在内存中不同，存储在硬盘上的数据通常有着各种各样的编码方式，使用不同的编码方式，相同的字符会有不同的二进制表示，实际上字符流是这样工作的： 输出字符流：把要写入文件的字符序列（实际上是Unicode码元序列）转为指定编码方式下的字节序列，然后再写入到文件中 输入字符流：把要读取的字节序列按指定编码方式解码为相应字符序列从而可以存在内存中 编码问题 ASCII 原本对于西方世界来说，1个字节足矣，因为1个字节最多256个符号编码，而英文26个字母再加几个常用符号、标点，256个符号编码足够了，这就是ASCII编码 ISO 8859-1 ISO 8859-1是国际标准化组织定义的法语、芬兰语所用的西欧字符集，也是每个字母或者符号用1个字节表示 中文编码 如果说一个汉字表示一个字符，那么收到的每一个字节不能简单的解码成一个字母了，而是需要好几个字节组成一个汉字，我国的汉字编码现行标准是GB18030，每个字可以由1个、2个或4个字节组成，编码空间161万个字符 Unicode 在出现Unicode之前，几乎每一种文字都有一套自己的编码方式，同一段字节流，在美国是”hello world”，到了国内可能就变成”烫烫烫”了，Unicode的理论就是全世界每个不同语言的不同字符都统一编码，全球通行。最初每个字符占用2个字节，总共65536个字符空间，从第四版开始加入的“扩展字符集”开始使用4个字节编码。 UTF-16 Unicode只是一套符号的编码，但计算机具体怎么读取这套编码呢？比如既然Unicode常规字符集占用2个字节，系统可以每次老老实实的读取两个字节，然后用一个特殊符号告诉系统某个字符属于附加字符集，需要再往后读2个字节，比如说Java系统默认的UTF-16就是这样编码解码的 UTF-8 UTF-16存在的问题就是所有英语字符也被迫使用2个字节来编码，那么就得使用可变长编码UTF-8，其用几位冗余信息告诉系统，当前字符有没有结束，是不是还需要继续往下读下一个字节。 如果一个字节是以“0”开头的，说明是一个ASCII字符，只占用一个字节，如果是“11”开头的，说明这个字符占用多个字节，后续每个“10”打头的字节都是这个字符的一部分。 本小节摘录自Java 中字节流与字符流的区别?。 Java中char默认采用Unicode编码，所以Java中char占2个字节 Java文件的编码可能有多种多样，但Java编译器会自动将这些编码按照Java文件的编码格式正确读取后产生class文件，这里的class文件编码是Unicode编码（具体来说是UTF-16编码）。 因此，在Java代码中定义了一个字符串： String s = “汉字” 不管在编译前java文件使用何种编码，在编译成class后，它们都是一样的，即Unicode编码表示。 JVM加载class文件读取时候使用Unicode编码方式正确读取class文件，那么原来定义的String s = “汉字”在内存中的表现形式是Unicode编码。 利用序列化实现深复制 把对象写到流里的过程是序列化过程，而把对象从流中读取出来的过程则叫做反序列化过程。 需要注意的是：写在流里的是对象的一个拷贝，而原对象仍然在JVM中。 在Java中深复制一个对象，常常可以先使对象实现Serializable接口，然后把对象（对象的一个拷贝）写到一个流里，再从流里读出来，便可以重建对象。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124import java.io.ByteArrayInputStream;import java.io.ByteArrayOutputStream;import java.io.ObjectInputStream;import java.io.ObjectOutputStream;import java.io.Serializable;public class CloneTest3&#123; public static void main(String[] args) throws Exception &#123; Teacher3 t = new Teacher3(); t.setName(\"Teacher Wang\"); t.setAge(50); Student3 s1 = new Student3(); s1.setAge(20); s1.setName(\"ZhangSan\"); s1.setTeacher(t); Student3 s2 = (Student3) s1.deepClone(); System.out.println(\"拷贝得到的信息:\"); System.out.println(s2.getName()); System.out.println(s2.getAge()); System.out.println(s2.getTeacher().getName()); System.out.println(s2.getTeacher().getAge()); System.out.println(\"---------------------------\"); // 将复制后的对象的老师信息修改一下： s2.getTeacher().setName(\"New Teacher Wang\"); s2.getTeacher().setAge(28); System.out.println(\"修改了拷贝对象的教师后：\"); System.out.println(\"拷贝对象的教师：\"); System.out.println(s2.getTeacher().getName()); System.out.println(s2.getTeacher().getAge()); System.out.println(\"原来对象的教师：\"); System.out.println(s1.getTeacher().getName()); System.out.println(s1.getTeacher().getAge()); // 由此证明序列化的方式实现了对象的深拷贝 &#125;&#125;class Teacher3 implements Serializable&#123; private String name; private int age; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125;&#125;class Student3 implements Serializable&#123; private String name; private int age; private Teacher3 teacher; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; public Teacher3 getTeacher() &#123; return teacher; &#125; public void setTeacher(Teacher3 teacher) &#123; this.teacher = teacher; &#125; public Object deepClone() throws Exception &#123; // 序列化 ByteArrayOutputStream bos = new ByteArrayOutputStream(); ObjectOutputStream oos = new ObjectOutputStream(bos); oos.writeObject(this); // 反序列化 ByteArrayInputStream bis = new ByteArrayInputStream(bos.toByteArray()); ObjectInputStream ois = new ObjectInputStream(bis); return ois.readObject(); &#125;&#125; Java中非静态内部类对象的创建要依赖外部类对象，对于静态方法，静态方法中没有this，也就是说没有外部类对象，因此无法创建内部类对象。 Spring声明式事务管理默认对运行时异常进行事务管理，而对检查型异常不进行回滚操作，如果异常被try{}catch{}了，事务就不回滚了，如果想让事务回滚必须再往外抛try{}catch{throw Exception} 如果在函数体内用throw抛出了某种异常，最好要在函数名中加throws抛异常声明，然后交给调用它的上层函数进行处理 如果SELECT后面若要UPDATE同一个表单，最好使用SELECT…UPDATE，举个例子： 假设商品表单products 内有一个存放商品数量的quantity ，在订单成立之前必须先确定quantity 商品数量是否足够(quantity&gt;0) ，然后才把数量更新为1。代码如下: 1SELECT quantity FROM products WHERE id=3; UPDATE products SET quantity = 1 WHERE id=3; 为什么不安全呢?少量的状况下或许不会有问题，但是大量的数据存取「铁定」会出问题。如果我们需要在quantity&gt;0 的情况下才能扣库存，假设程序在第一行SELECT 读到的quantity 是2 ，看起来数字没有错，但是当MySQL 正准备要UPDATE 的时候，可能已经有人把库存扣成0 了，但是程序却浑然不知，将错就错的UPDATE 下去了。因此必须透过的事务机制来确保读取及提交的数据都是正确的。 FOR UPDATE仅适用于InnoDB，且必须在事务区块（BEGIN/COMMIT）中才能生效： 123BEGINSELECT * FROM `table_name` WHERE xxx FOR UPDATECOMMIT 使用SELECT… FOR UPDATE会把数据给锁住，但是需要注意的是，MySQL InnoDB默认为Row-Level Lock，所以只有明确的指定主键，MySQL才会执行Row Lock（只锁住被选取的数据），否则MySQL将会执行Table Lock（将整个数据表单给锁住）。 本小节内容摘录自mysql select for update。 向枚举中添加新方法 如果打算自定义自己的方法，那么必须在enum实例序列的最后添加一个分号，而且Java要求必须先定义enum实例。 123456789101112131415161718192021222324252627282930313233public enum Color &#123; RED(\"红色\", 1), GREEN(\"绿色\", 2), BLANK(\"白色\", 3), YELLO(\"黄色\", 4); // enum实例序列 private String name; private int index; private Color(String name, int index) &#123; this.name = name; this.index = index; &#125; public static String getName(int index) &#123; for (Color c : Color.values()) &#123; if (c.getIndex() == index) &#123; return c.name; &#125; &#125; return null; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getIndex() &#123; return index; &#125; public void setIndex(int index) &#123; this.index = index; &#125;&#125; QPS：每秒查询率（Query Per Second） MySQL中delimiter的作用： 其实就是告诉MySQL解释器，该段命令是否已经结束了，MySQL数据库是否可以执行了，默认情况下delimiter是分号，在命令行客户端中，如果有一行命令以分号结束，那么回车后，MySQL将会执行该命令。 在为可能输入较多的语句，且语句中包含有分号时，默认情况下，不可能等到用户把语句全部输入完成之后再执行整段语句，因为MySQL一遇到分号，它就要自动执行，这种情况下，就需要事先把delimiter换成其他符号，如//或$$。 MySQL命令行中可以使用system clear;命令进行清屏 计算网络延迟： 光在真空中的传播速度是30万公里每秒，光在玻璃中的传播速度是真空的2/3，假如往返举例为X，那么网络延迟即为： 1X/(300000 * 2 / 3) 使用存储过程可以使得整个事务在MySQL端完成，从而减少SQL语句在Java端执行所带来的网络延迟和GC干扰 RPC（Remote Procedure Call）：远程过程调用，允许程序调用另一个地址空间的过程或函数，而不用程序员显式编码这个远程调用的细节； Map是Java中的一个接口，Map.Entry是Map的一个内部接口，Map提供了一些常用方法，如keySet()、entrySet()等方法，keySet()方法返回值是Map中key值的集合，entrySet()方法的返回值也是一个Set集合，此集合的类型为Map.Entry。 Map.Entry是Map声明的一个内部接口，此接口为泛型，定义为Entry&lt;K,V&gt;，它表示Map中的一个实体（一个key-value对），接口中有getKey()、getValue()方法。 12345678910Set entries = map.entrySet( );if(entries != null) &#123; Iterator iterator = entries.iterator( ); while(iterator.hasNext( )) &#123; Map.Entry entry =iterator.next( ); Object key = entry.getKey( ); Object value = entry.getValue(); ;.... &#125;&#125; 自动装箱和自动拆箱 自动装箱 把基本类型用它们对应的引用类型包装起来，使它们具有对象的性质，比如： 1Integer a = 3; // 自动装箱 其实编译器调用的是static Integer valueOf(int i)这个方法，valueOf(int i)返回一个表示指定int值的Integer对象。 自动拆箱 将Integer这样的引用类型的对象重新简化为基本类型的数据。比如： 1int i = new Integer(2); 编译器内部会调用int intValue()返回该Integer对象的int值。 &lt;a&gt;标签的href和onclick属性 链接的onclick事件先执行，其次是href属性下的动作（页面跳转或javascript伪链接） 假设链接中同时存在href和onclick，如果想让href属性下的动作不执行，onclick必须得到一个false的返回值 在创建非静态内部类对象时，一定要先创建相应的外部类对象，这是因为非静态内部类对象有着指向其外部类对象的引用，Java编译器在创建内部类对象时，隐式的把其外部类对象的引用也传进去并一直保存着。 内部类也可以是静态的，但是静态内部类没有了指向外部类的引用，静态内部类中不能访问外部类的非静态成员。 在任何非静态内部类中，都不能有静态数据、静态方法。 Spring之FactoryBean BeanFactory：工厂类，用于管理Bean的工厂 FactoryBean：一个Bean，不同于普通的Bean的是，它实现了FactoryBean&lt;T&gt;接口，根据该Bean的id从BeanFactory中获取的实际上是FactoryBean的getObject()返回的对象。 在使用Arrays.asList()方法需要注意以下两点： 避免使用基本数据类型数组转换为列表 asList()方法接收的参数是一个泛型的变长参数，但是基本数据类型是无法泛型化的，此时会将基本数据类型的数组当做其参数，而在Java中数组是一个对象，它是可以泛型化的。 asList()方法产生的列表不可操作，不要试图去改变asList()返回的列表 详细请参看博客Java提高篇（三六）—–java集合细节（二）：asList的缺陷。 ReentrantLock拥有Synchronized相同的并发性和内存语义，此时还多了锁投票、定时锁等候和中断锁等候，线程A和B都要获取对象O的锁定，假设A获取了对象O的锁，B将等待A释放对O的锁定，如果使用Synchronized，如果A不释放，B将一直等待下去，不能被中断；如果使用ReentrantLock，如果A不释放，可以使B在等待了足够长的时候后，中断等待，而干别的事情。 Synchronized是在JVM层面上实现的，不但可以通过一些监控工具监控Synchronized的锁定，而且在代码出现异常时，JVM会自动释放锁，但是使用Lock则不行，Lock是通过代码实现的，要保证锁定一定会释放，就必须将unLock()放到finally{}中。 在资源竞争不是很激烈的情况下，Synchronized的性能要高于ReentrantLock，但是在资源竞争激烈的情况下，Synchronized的性能会下降几十倍，但是ReentrantLock的性能能维持常态。 分布式Session Web应用在单机部署的情况下，Session是被单个应用服务器存储并管理的，由于只有一个应用服务器，用户的所有请求都是通过它进行响应处理的，所以能够很容易实现会话跟踪和保持。随着业务量的增加，系统架构需要作出调整以适应发展的需要，所以会将应用系统部署到多台引用服务器上，用户的请求也会通过负载均衡转发到某个具体的应用服务器上执行，可能会出现在A1系统登录后创建并保存Session，再次发起请求，请求被转发到A2系统上显示未登录的情况，此时单机部署模式下的Session机制已不能满足需求。 所以，在分布式架构或微服务架构下，必须保证一个应用服务器上保存Session后，其他应用服务器可以同步或共享这个Session。 分布式Session管理有以下几种实现方式： Session复制 在支持Session复制的Web服务器上，通过修改Web服务器的配置，可以实现将Session同步到其他Web服务器上，达到每个Web服务器上都保存一致的Session。 优点：代码上不需要修改 缺点：需要依赖支持的Web服务器，一旦更改成不支持的Web服务器就不能使用了，在数据量很大的情况下不仅占用网络资源，而且会导致延迟。 适用场景：只适用于Web服务器比较少且Session数据量少的情况 可用方案：开源方案tomcat-redis-session-manager，暂不支持Tomcat8。 Session粘带 将用户的每次请求都通过某种方法强制分发到某一个Web服务器上，只要这个Web服务器上存储了对应的Session数据，就可以实现会话跟踪。 Session集中管理 在单独的服务器或者服务器集群上使用缓存技术，如Redis存储Session数据，集中管理所有的Session，所有的Web服务器都从这个存储介质中存取对应的Session，实现Session共享。 优点：可靠性高，减少Web服务器的资源开销 缺点：实现上有些复杂，配置较多 适用场景：Web服务器较多，要求高可用性的情况 可用方案：开源方案Spring Session 基于Cookie管理 这种方式每次发起请求的时候都需要将Session数据放到Cookie中传递给服务端。 优点：不需要依赖额外外部存储，不需要额外配置 缺点：不安全，易被盗取或篡改，Cookie数量和长度有限制，需要消耗更多网络带宽 这四种方式，Session集中管理更加可靠，使用也是最多的。 本小节转自细说分布式Session管理。 MySQL索引 索引的本质 在数据之外，数据库系统还维护着满足特定查找算法的数据结构，这些数据结构以某种方式引用（指向）数据，这样就可以在这些数据结构上实现高效查找算法，这种数据结构就是索引。 看下面这个例子： 左边是数据表，一共有两列七条记录，最左边的是数据记录的物理地址（注意逻辑上相邻的记录在磁盘上并不一定是物理相邻的）。为了加快Col2的查找，可以维护一个右边所示的二叉查找树，每个节点包含索引键值和一个指向对应数据记录物理地址的指针，这样就可以运用二叉查找在O(log2n)的复杂度内获取到相应数据。 实际的数据库系统几乎没有使用二叉查找树或红黑树实现的。 目前大部分数据库系统及文件系统使用B-树或其变种B+树作为索引结构。 MyISAM引擎使用B+树作为索引结构，叶节点的data域存放的是数据记录的地址： 从上图可以看出，MyISAM的索引文件仅仅保存数据记录的地址，在MyISAM中，主索引和辅助索引（Secondary Key）在结构上没有任何区别，只是主索引要求key是唯一的，而辅助索引的key可以是重复的。 InnoDB也是使用B+树作为索引结构，但是InnoDB的数据文件本身就是索引文件，从上文可知，MyISAM索引文件和数据文件是分离的，索引文件仅保存数据记录的地址，而在InnoDB中，表数据文件本身就是按照B+树组织的一个索引结构，这棵树的叶节点data域保存了完整的数据记录，这个索引的key是数据表的主键，因此InnoDB表数据文件本身就是主索引。 从上图可以看出，叶节点包含了完整的数据记录，这种索引叫做聚集索引，因为InnoDB的数据文件本身就是按主键索引，所以InnoDB要求表必须有主键（MyISAM可以没有），如果没有显式指定，则MySQL系统会自动选择一个可以唯一标识数据记录的列作为主键，如果不存在这种列，则MySQL自动为InnoDB表生成一个隐含字段作为主键，这个字段长度为6个字节，类型为长整形。 InnoDB引擎与MyISAM引擎另一个不同点在于InnoDB的辅助索引data域存储相应记录主键的值而不是地址，也就是说，InnoDB的所有辅助索引都引用主键作为data域： 上图中叶子结点的data域存放的都是主键值。这里以英文字符的ASCII码作为比较准则。聚集索引这种实现方式使得按主键的搜索十分高效，但是辅助索引搜索需要检索两遍索引：首先检索辅助索引获得主键，然后用主键到主索引中检索获得记录。 了解不同存储引擎的索引实现方式对于正确使用和优化索引都非常有帮助，例如知道了InnoDB的索引实现后，就很容易明白为什么不建议使用过长的字段作为主键，因为所有辅助索引都引用主索引，过长的主索引会令辅助索引变得过大。再例如，用非单调的字段作为主键在InnoDB中不是个好主意，因为InnoDB数据文件本身是一颗B+Tree，非单调的主键会造成在插入新记录时数据文件为了维持B+Tree的特性而频繁的分裂调整，十分低效，而使用自增字段作为主键则是一个很好的选择。 使用SHOW INDEX FROM TABLE_NAME命令可以查看表上建立了哪些索引。 MySQL的查询优化器会自动调整where字句的条件顺序以使用适合的索引。 使用SELECT DISTINCT(col_name) FROM table_name可以查看col_name列共有几种不同的取值 在使用InnoDB存储引擎时，如果没有特别的必要，请永远使用一个与业务无关的自增字段作为主键。 本小结转自MySQL索引背后的数据结构及算法原理。 数据库三大范式： 强调的是列的原子性，即列不能再分成其他几列 一个表必须有一个主键，并且没有包含在主键中的列必须完全依赖于主键，而不能只依赖于主键的一部分 不能存在非主键列A依赖于非主键列B，非主键列B依赖于主键的情况，即非主键列必须直接依赖于主键，不能存在传递依赖 ArrayList初始化的默认长度是10 JDK和CGLIB JDK动态代理只能针对实现了接口的类生成代理（实例化一个类），此时代理对象和目标对象实现了相同的接口，目标对象作为代理对象的一个属性，具体接口实现中，可以在调用目标对象相应方法前后加上其他业务处理逻辑 CGLIB是针对类实现代理，主要是对指定的类生成一个子类（没有实例化一个类），覆盖其中的方法 新生代由Eden区和Survivor区（S0、S1）组成，大小通过-Xmn参数指定，Eden与Survivor区的内存大小比例默认是8:1，可以通过-XX:SurvivorRatio参数指定 大多数情况下，对象在Eden中分配，当Eden没有足够空间时，会触发一次Minor GC，虚拟机提供了-XX:PintGCDetails参数，告诉虚拟机在发生垃圾回收时打印内存回收日志。 Survivor区是新生代和老年代之间的缓冲区域，当新生代发生Minor GC时，会将存活的对象移动到S0内存区域，并清空Eden区，当再次发生Minor GC时，将Eden和S0中存活的对象移动到S1内存区域。 存活对象会反复在S0和S1之间移动，当对象从Eden移动到Survivor或者在Survivior之间移动时，对象的GC年龄会自动累加，当GC年龄超过默认阈值15时，会将该对象移动到老年代，可以通过-XX:MaxTenuringThreshold对GC年龄的阈值进行设置。 老年代的空间大小即-Xmx和-Xmn两个参数之差，用于存放经过几次Minor GC之后依旧存活的对象。当老年代的空间不足时，将会触发Major GC，速度一般比Minor GC慢10倍以上。 类的元数据、方法信息（字节码、栈和变量大小）、运行时常量池、已确定的符号引用和虚方法表等被保存在永久代中，32位默认永久代的大小为64M，64位默认为85M，可以通过-XX:MaxPermSize进行设置，一旦类的元数据超过了永久代大小，就会跑出OOM异常。 当Full GC进行的时候，默认的方式是尽量清空新生代，因此在调用System.gc()时，新生代中存活的对象会提前进入老年代。Java 堆内存 新生代 （转） 高并发秒杀系统Java开发面试：高并发秒杀系统如何设计与优化。 为何JAVA虚函数（虚方法）会造成父类可以”访问”子类的假象？ SQL语句优化： 尽量避免在where字句中使用!=或&lt;&gt;操作符，否则引擎将放弃使用索引而进行全表扫描 尽量避免在where字句中对字段进行null值判断，否则将导致引擎放弃使用索引而进行全表扫描，如： 1select id from t where num is null 可以在num上设置默认值0，确保表中num列没有null值，然后这样查询： 1select id from t where num = 0 使用exists代替in 用where代替having drop、delete和truncate的区别 drop直接删除表，truncate删除表中数据，再插入时自增长id又从1开始，delete删除表中数据，可以加where字句。 对互斥锁加锁后，任何其他试图再对该互斥锁加锁的线程都会被阻塞直到当前持有锁的线程释放锁 当读写锁是写加锁时，在这个锁被解锁之前，所有试图对这个锁加锁的线程都会被阻塞；当读写锁是读加锁时，所有试图以读模式对它进行加锁的线程都可以得到访问权 Struts2中Filter和Inteceptor的区别： filter是依赖于Servlet容器的，没有Servlet容器就没法回调doFilter方法，而Interceptor与Servlet无关 Filter的过滤范围比Interceptor大，Filter除了过滤请求外通过通配符还可以保护页面、图片、文件等，而Interceptor只能过滤请求，只对action起作用 Interceptor可以访问action上下文、值栈中的对象，而Filter不能 在action的生命周期中，拦截器可以被多次调用，而过滤器只能在容器初始化时被调用一次 假设有多台memcached服务器，编号分别为m0、m1、m2…，对于一个key，由客户端来决定存放到哪台机器，那最简单的hash公式就是key%N，其中N就是机器的总数。但这有个问题，一旦机器数变少，或者增加机器，N发生变化，那之前存放的数据就全部无效了，因为你按照新的N值取模计算出的计算编号，和当时按照旧的取模算出的机器编号肯定是不等的，也就意味着绝不部分缓存会失效。 这个问题的解决方法就是用1种特别的Hash函数，尽可能使得，增加机器/减少机器时，缓存失效的数目降到最低，这就是Hash环，或者叫一致性Hash。 上面说的Hash函数，只经历了一次hash，即把key hash到对应的机器编号，而hash环有两次hash： 把所有机器编号hash到这个环上 把key也hash到这个环上，然后在这个环上进行匹配，看这个key和哪台机器匹配 具体来说，假设有这样一个hash函数，其值空间为0~2^32-1，也就是说，其hash值是个32位无符号整型数字，这些数字形成一个环。 然后，先对机器进行hash（比如根据机器的IP），算出每台机器在这个环上的位置，再对key进行hash，算出该key在环上的位置，然后从这个位置走，遇到的第一台机器就是该key对应的机器，就把该（key, value）存储到该机器上。 首先计算出每台Cache服务器在环上的位置（图中的大圆圈）；然后每来一个(key, value)，计算出在环上的位置（图中的小圆圈），然后顺时针走，遇到的第1个机器，就是其要存储的机器。 这里的关键点是：当你增加/减少机器时，其他机器在环上的位置并不会发生改变。这样只有增加的那台机器、或者减少的那台机器附近的数据会失效，其他机器上的数据都还是有效的。 分布式锁 基于缓存实现分布式锁 使用缓存实现一方面性能较好，另一方面很多缓存是可以集群部署的，可以解决单点问题。 使用Zookeeper实现分布式锁 基于zookeeper临时有序节点实现分布式锁。每个客户端在对方法加锁时，在zookeeper上的与该方法对应的指定结点的目录下，生成一个唯一的瞬时有序结点，判断是否获取锁的方式很简单，只需要判断有序节点中序号最小的一个。 当释放锁的时候，只需将这个瞬时节点删除即可。同时，其可以避免服务宕机导致的锁无法释放，而产生的死锁问题。 锁无法释放？使用Zookeeper可以有效的解决锁无法释放的问题，因为在创建锁的时候，客户端会在ZK中创建一个临时节点，一旦客户端获取到锁之后突然挂掉（Session连接断开），那么这个临时节点就会自动删除掉。其他客户端就可以再次获得锁。 不可重入？使用Zookeeper也可以有效的解决不可重入的问题，客户端在创建节点的时候，把当前客户端的主机信息和线程信息直接写入到节点中，下次想要获取锁的时候和当前最小的节点中的数据比对一下就可以了。如果和自己的信息一样，那么自己直接获取到锁，如果不一样就再创建一个临时的顺序节点，参与排队。 单点问题？使用Zookeeper可以有效的解决单点问题，ZK是集群部署的，只要集群中有半数以上的机器存活，就可以对外提供服务。 本小节参考分布式锁原理及实现方式。 JAVA软件面试之杭州。 分布式锁 当在分布式模型下，数据只有一份（或有限制），此时需要利用锁的技术控制某一时刻修改数据的进程数。 与单机模式下的锁不仅需要保证进程可见，还需要考虑进程与锁之间的网络问题。（我觉得分布式情况下之所以问题变得复杂，主要就是需要考虑到网络的延时和不可靠。。。一个大坑） 分布式锁还是可以将标记存在内存，只是该内存不是某个进程分配的内存而是公共内存如Redis、Memcache。至于利用数据库、文件等做锁与单机的实现是一样的，只要保证标记能互斥就行。 redis的SETNX操作 其格式为：SETNX key value 将key的值设为value，当且仅当key不存在；若给定的key已经存在，则SETNX不做任何动作。 使用SETNX实现分布式锁 多个进程执行以下Redis命令：SETNX lock.foo &lt;current Unix time + lock timeout + 1&gt; 如果SETNX返回1，说明该进程获得锁，SETNX将键lock.foo的值设置为锁的超时时间（当前时间+锁的有效时间）； 如果SETNX返回0，说明其他进程获得锁，进程不能进入临界区，进程可以在一个循环中不断的尝试SETNX操作，以获得锁。 两阶段提交（Two-phase Commit, 2PC） 两阶段提交协议经常被用来实现分布式事务，一般分为协调器和若干事务执行者两种角色，这里的事务执行者就是具体的数据库，协调者可以和事务执行器在一台机器上。 在分布式系统中，每个节点虽然可以知晓自己的操作是成功或者失败，却无法知道其他节点的操作的成功或失败。当一个事务跨越多个节点时，为了保持事务的ACID特性，需要引入一个作为协调者的组件来统一掌控所有节点（称作参与者）。 我们设想从支付宝里转10000元到余额宝的场景： 首先我们的应用程序发起一个请求到协调器，然后由控制器来保证分布式事务 准备凭证阶段 协调器先将&lt;prepare&gt;消息写到本地日志 向所有的参与者发起&lt;prepare&gt;消息，以支付宝转账到余额宝为例，协调器给A的prepare消息是通知支付宝数据库相应账目扣款10000，协调器给B的prepare消息是通知余额宝数据库相应账目增加10000。 注: 为什么在执行任务前需要先写本地日志，主要是为了故障后恢复用，本地日志起到现实生活中凭证 的效果，如果没有本地日志（凭证），出问题容易死无对证 参与者收到&lt;prepare&gt;消息后，执行具体本机事务，但不会进行commit，如果成功返回&lt;yes&gt;，不成功返回&lt;no&gt;。同理，返回前都应把要返回的消息写到日志里，当作凭证。 支付宝： 123456789BEGIN WORK select money from zhifubao where user='xiaorui' for update; update zhifubao set money=money-10000 where user='xiaorui'; ... Operation N 向协调者发送YES或者NO ! 等待协调者的指令过来 ! 余额宝： 123456789BEGIN WORK select money from yuebao where user='xiaorui' for update; update yuebao set money=money+10000 where user='xiaorui'; ... Operation N 根据状态向协调者发送YES或者NO ! 然后等待协调者的指令过来 ... .... 协调器收集所有执行器返回的消息，如果所有执行器都返回yes，那么给所有执行器发生送commit消息，执行器收到commit后执行本地事务的commit操作；如果有任一个执行器返回no，那么给所有执行器发送abort消息，执行器收到abort消息后执行事务abort操作。 123456#blog: xiaorui.cc if 协调者指令 == \"to_commit\": commit work #提交事务else: ROLLBACK #回滚 协调器或参与者把发送或接收到的消息先写到日志里，主要是为了故障后恢复用。举个例子，比如某个参与者从故障中恢复后，先检查本机的日志，如果已收到&lt;commit &gt;，则提交，如果&lt;abort &gt;则回滚。如果是&lt;yes&gt;，则再向控制器询问一下，确定下一步。如果什么都没有，则很可能在&lt;prepare&gt;阶段Si就崩溃了，因此需要回滚。 二阶段协议存在的问题是： 同步阻塞问题：执行过程中，所有参与节点都是事务阻塞型的，当参与者占有公共资源时，其他第三方节点访问公共资源不得不处于阻塞状态 单点故障：由于协调者的重要性，一旦协调者发生故障，参与者将会一直阻塞下去，尤其在第二阶段，协调者发生故障，那么所有的参与者还都处于锁定事务资源的状态中，而无法继续完成事务操作 数据不一致：在二阶段提交的阶段二中，当协调者向参与者发送commit请求之后，发生了局部网络异常或者在发送commit请求过程中协调者发生了故障，这会导致只有一部分参与者接受到了commit请求，而这部分参与者接到commit请求之后就会执行commit操作，但是其他部分未收到commit请求的机器则无法执行事务提交，于是出现数据不一致的现象 本文转载自理解分布式事务的两阶段提交2pc。 RocketMQ事务消息实现分布式事务 和两阶段提交不同，RocketMQ事务消息实现分布式事务主要包含下面几个步骤： 发送Prepared消息 update DB 根据update DB结果成功或失败，Confirm或者取消Prepared消息 如果前两步执行成功了，最后1步失败了怎么办？这里就涉及到RocketMQ的关键点：RocketMQ会定期（默认是1分钟）扫描所有的Prepared消息，询问发送方，到底是要确认这条消息发出去？还是取消此条消息？ 具体实现如下： 也就是定义了一个checkListener，RocketMQ会回调此Listener，从而实现上面所述的方案。 面试总结。 enum定义的类默认继承的是java.lang.Enum类而不是Object类，同时注意枚举类不能派生子类（类的默认修饰符是final），其原因是它只有private构造器。 枚举类是包含有固定数量实例（并且实例的值也固定）的特殊类，如果其含有public构造器，那么在类的外部就可以通过这个构造器来新建实例，显然这时实例的数量和值不固定。 ​","tags":[{"name":"Java 面试","slug":"Java-面试","permalink":"https://glemontree.github.io/tags/Java-面试/"}]},{"title":"[SpringMVC] 解决The resource identified by this request is only capable of generating responses with characteristics not acceptable according to the request accept headers.","date":"2017-10-07T07:52:10.000Z","path":"2017/10/07/[SpringMVC] 解决The resource identified by this request is only capable of generating responses with characteristics not acceptable according to the request accept headers/","text":"解决方法如下： 在pom.xml文件中添加json所需要的依赖 123456789101112131415161718&lt;!--json所需要的依赖--&gt;&lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-core&lt;/artifactId&gt; &lt;version&gt;2.7.3&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt; &lt;version&gt;2.7.3&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-annotations&lt;/artifactId&gt; &lt;version&gt;2.7.3&lt;/version&gt;&lt;/dependency&gt; 在SpringMVC的配置文件中配置对应的Bean 1234567891011121314151617&lt;!--转化json--&gt;&lt;bean class=\"org.springframework.web.servlet.mvc.annotation.AnnotationMethodHandlerAdapter\"&gt; &lt;property name=\"messageConverters\"&gt; &lt;list&gt; &lt;!--json视图拦截器，读取到@ResponseBody的时候去配置它--&gt; &lt;ref bean=\"mappingJacksonHttpMessageConverter\"/&gt; &lt;/list&gt; &lt;/property&gt;&lt;/bean&gt;&lt;!--json转化器，它可以将结果转化--&gt;&lt;bean id=\"mappingJacksonHttpMessageConverter\" class=\"org.springframework.http.converter.json.MappingJackson2HttpMessageConverter\"&gt; &lt;property name=\"supportedMediaTypes\"&gt; &lt;list&gt; &lt;value&gt;application/json;charset=UTF-8&lt;/value&gt; &lt;/list&gt; &lt;/property&gt;&lt;/bean&gt; ​","tags":[{"name":"SpringMVC、JSON","slug":"SpringMVC、JSON","permalink":"https://glemontree.github.io/tags/SpringMVC、JSON/"}]},{"title":"[Redis] 推荐一篇关于Redis集群的文章","date":"2017-09-21T10:53:20.000Z","path":"2017/09/21/[Redis] 推荐一篇关于Redis集群的文章/","text":"这篇文章介绍了Windows下使用RedisCluster集群，大家感兴趣的可以参考：windows下使用RedisCluster集群简单实例。 当然你也可以参考这篇文章：集群教程。","tags":[{"name":"Redis","slug":"Redis","permalink":"https://glemontree.github.io/tags/Redis/"}]},{"title":"[MyBatis]MyBatis第七课---resultMap的用法","date":"2017-09-18T13:32:45.000Z","path":"2017/09/18/[MyBatis] MyBatis第七课---resultMap的用法/","text":"自动映射 全局setting设置 autoMappingBehavior默认是PARTIAL，开启自动映射的功能，唯一的要求是列名和javaBean属性名一致 如果autoMappingBehavior设置为null则会取消自动映射 数据库字段命名规范，POJO属性符合驼峰命名法，如A_COLUMN—&gt;aColumn，我们可以开启自动驼峰命名规则映射功能，mapUnderscoreToCamelCase=true 自定义resultMap，实现高级结果集映射 第一个例子定义接口123public interface EmployeeMapperPlus &#123; public Employee getEmpById(Integer id);&#125; 定义映射文件123456789101112131415161718192021222324252627282930313233&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"&gt;&lt;mapper namespace=\"com.glemontree.mybatis.dao.EmployeeMapperPlus\"&gt; &lt;!-- &lt;select id=\"getEmpById\" resultType=\"com.glemontree.mybatis.bean.Employee\"&gt; select * from tbl_employee where id = #&#123;id&#125; &lt;/select&gt; --&gt; &lt;!-- resultMap：自定义结果集映射规则 --&gt; &lt;!-- 自定义javaBean的封装规则 type：自定义规则的Java类型 id：唯一标识符，方便引用 --&gt; &lt;resultMap type=\"com.glemontree.mybatis.bean.Employee\" id=\"MyEmp\"&gt; &lt;!-- 指定主键列的封装规则 id定义主键底层会有优化 column：指定哪一列 property：指定对应的JavaBean属性 --&gt; &lt;id column=\"id\" property=\"id\"/&gt; &lt;!-- result定义普通列封装规则 --&gt; &lt;result column=\"last_name\" property=\"lastName\"/&gt; &lt;!-- 其他不指定的列会进行自动封装，推荐写上全部的映射规则 --&gt; &lt;result column=\"email\" property=\"email\"/&gt; &lt;result column=\"gender\" property=\"gender\"/&gt; &lt;/resultMap&gt; &lt;select id=\"getEmpById\" resultMap=\"MyEmp\"&gt; select * from tbl_employee where id = #&#123;id&#125; &lt;/select&gt;&lt;/mapper&gt; 测试123456789101112@Testpublic void test06() throws IOException &#123; SqlSessionFactory sqlSessionFactory = getSqlSessionFactory(); SqlSession openSession = sqlSessionFactory.openSession(); try &#123; EmployeeMapperPlus mapper = openSession.getMapper(EmployeeMapperPlus.class); Employee employee = mapper.getEmpById(1); System.out.println(employee); &#125; finally &#123; openSession.close(); &#125;&#125; 第二个例子Employee12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970package com.glemontree.mybatis.bean;import org.apache.ibatis.type.Alias;public class Employee &#123; private Integer id; private String lastName; private String email; private String gender; private Department dept; public Department getDept() &#123; return dept; &#125; public void setDept(Department dept) &#123; this.dept = dept; &#125; public Integer getId() &#123; return id; &#125; public void setId(Integer id) &#123; this.id = id; &#125; public String getLastName() &#123; return lastName; &#125; public void setLastName(String lastName) &#123; this.lastName = lastName; &#125; public String getEmail() &#123; return email; &#125; public void setEmail(String email) &#123; this.email = email; &#125; public String getGender() &#123; return gender; &#125; public void setGender(String gender) &#123; this.gender = gender; &#125; @Override public String toString() &#123; return \"Employee [id=\" + id + \", lastName=\" + lastName + \", email=\" + email + \", gender=\" + gender + \"]\"; &#125; public Employee(Integer id, String lastName, String email, String gender) &#123; super(); this.id = id; this.lastName = lastName; this.email = email; this.gender = gender; &#125; public Employee() &#123; &#125;&#125; Department1234567891011121314151617181920212223package com.glemontree.mybatis.bean;public class Department &#123; private Integer id; private String departmentName; public Integer getId() &#123; return id; &#125; public void setId(Integer id) &#123; this.id = id; &#125; public String getDepartmentName() &#123; return departmentName; &#125; public void setDepartmentName(String departmentName) &#123; this.departmentName = departmentName; &#125; @Override public String toString() &#123; return \"Department [id=\" + id + \", departmentName=\" + departmentName + \"]\"; &#125;&#125; 接口1public Employee getEmpAndDept(Integer id); 映射文件1234567891011121314&lt;!-- 联合查询：级联属性封装结果集 --&gt;&lt;resultMap type=\"com.glemontree.mybatis.bean.Employee\" id=\"MyDifEmp\"&gt; &lt;id column=\"id\" property=\"id\"/&gt; &lt;result column=\"last_name\" property=\"lastName\"/&gt; &lt;result column=\"gender\" property=\"gender\"/&gt; &lt;result column=\"did\" property=\"dept.id\"/&gt; &lt;result column=\"dept_name\" property=\"dept.departmentName\"/&gt;&lt;/resultMap&gt;&lt;select id=\"getEmpAndDept\" resultMap=\"MyDifEmp\"&gt; SELECT e.id id, e.last_name last_name, e.gender gender, e.d_id d_id, d.id did, d.dept_name dept_name FROM tbl_employee e, tbl_dept d WHERE e.d_id = d.id AND e.id = #&#123;id&#125;&lt;/select&gt; 小结上面这段程序展示了使用resultMap进行关联查询，在resultMap中使用级联属性封装结果集： 12&lt;result column=\"did\" property=\"dept.id\"/&gt;&lt;result column=\"dept_name\" property=\"dept.departmentName\"/&gt; 其实还有另外一种方法可以用来定义关联的单个对象的封装规则： 123456789101112131415&lt;!-- 使用association定义关联的单个对象的封装规则 --&gt;&lt;resultMap type=\"com.glemontree.mybatis.bean.Employee\" id=\"MyDifEmp2\"&gt; &lt;id column=\"id\" property=\"id\"/&gt; &lt;result column=\"last_name\" property=\"lastName\"/&gt; &lt;result column=\"gender\" property=\"gender\"/&gt; &lt;!-- association可以指定联合的javaBean对象 property=\"dept\"：指定哪个属性时联合的对象 javaType：指定这个属性对象的类型[不能省略] --&gt; &lt;association property=\"dept\" javaType=\"com.glemontree.mybatis.bean.Department\"&gt; &lt;id column=\"did\" property=\"id\"/&gt; &lt;result column=\"dept_name\" property=\"departmentName\"/&gt; &lt;/association&gt;&lt;/resultMap&gt; 推荐使用这种方法。","tags":[{"name":"MyBatis, resultMap","slug":"MyBatis-resultMap","permalink":"https://glemontree.github.io/tags/MyBatis-resultMap/"}]},{"title":"[MyBatis] MyBatis第六课---select操作","date":"2017-09-13T12:09:47.000Z","path":"2017/09/13/[MyBatis] MyBatis第六课---select操作/","text":"select返回List如果返回的是一个集合，那么resultType应当为集合中元素的类型： 1public List&lt;Employee&gt; getEmpsByLastNameLike(String lastName); 123&lt;select id=\"getEmpsByLastNameLike\" resultType=\"com.glemontree.mybatis.bean.Employee\"&gt; select * from tbl_employee where last_name like #&#123;lastName&#125;&lt;/select&gt; select返回记录封装成map返回一条记录的map，key就是列名，值就是对应的值：1public Map&lt;String, Object&gt; getEmpByIdReturnMap(Integer id); 123&lt;select id=\"getEmpByIdReturnMap\" resultType=\"map\"&gt; select * from tbl_employee where id = #&#123;id&#125;&lt;/select&gt; 123456789101112@Testpublic void test05() throws IOException &#123; SqlSessionFactory sqlSessionFactory = getSqlSessionFactory(); SqlSession openSession = sqlSessionFactory.openSession(); try &#123; EmployeeMapper mapper = openSession.getMapper(EmployeeMapper.class); Map&lt;String, Object&gt; map = mapper.getEmpByIdReturnMap(1); System.out.println(map); &#125; finally &#123; openSession.close(); &#125;&#125; 最后的输出为： 1&#123;gender=1, last_name=tom, id=1, email=tom@gmail.com&#125; 多条记录封装一个mapMap&lt;Integer, Employee&gt;：键是这条记录的主键，值是记录封装后的JavaBean。 12@MapKey(\"id\") // 告诉MyBatis封装Map时使用id这个属性作为keypublic Map&lt;Integer, Employee&gt; getEmpByLastNameLikeReturnMap(String lastName); 123&lt;select id=\"getEmpByLastNameLikeReturnMap\" resultType=\"com.glemontree.mybatis.bean.Employee\"&gt; select * from tbl_employee where last_name like #&#123;lastName&#125; &lt;/select&gt; 对于resultType属性，其实可以这样判断：我们查询出来的每条数据你希望是什么类型resultType就是什么类型，比如在上面一小节中返回一条记录的map，那么resultType就是map类型，而当多条记录封装一个map时，每条记录其实还是Employee，因此这里的resultType就是Employee。","tags":[{"name":"MyBatis","slug":"MyBatis","permalink":"https://glemontree.github.io/tags/MyBatis/"}]},{"title":"[DB] SQL小知识","date":"2017-09-13T12:05:26.000Z","path":"2017/09/13/[DB] SQL小知识/","text":"使用sql语句desc table_name可以显示table_name表中的字段名以及Type等属性 使用sql语句alter table employees modify email null修改email字段的属性为可以为null mysql中使用sql语句生成一张表并且同时指定表的编码： 1234567CREATE TABLE USER( id INT(11) PRIMARY KEY NOT NULL AUTO_INCREMENT, nickname VARCHAR(45) NOT NULL, PASSWORD VARCHAR(45) NOT NULL, first_name VARCHAR(45) DEFAULT NULL, last_name VARCHAR(45) DEFAULT NULL) CHARACTER SET utf8 COLLATE utf8_general_ci; 注意utf8不能写成utf-8。 mysql中使用sql语句生成一张表并且同时指定外键： 1234567CREATE TABLE blog( id INT(11) PRIMARY KEY NOT NULL AUTO_INCREMENT, title VARCHAR(100) NOT NULL, content VARCHAR(255) DEFAULT NULL, user_id INT(11) NOT NULL, CONSTRAINT FK_ID FOREIGN KEY(user_id) REFERENCES USER(id)) CHARACTER SET utf8 COLLATE utf8_general_ci; 如下方式可以在创建表的同时指定索引： 12345678910111213CREATE DATABASE seckill;USE seckill;CREATE TABLE seckill( `seckill_id` BIGINT PRIMARY KEY NOT NULL AUTO_INCREMENT COMMENT '商品库存id', `name` VARCHAR(255) NOT NULL COMMENT '商品名称', `number` INT NOT NULL COMMENT '商品数量', `create_time` TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间', `start_time` TIMESTAMP NOT NULL COMMENT '秒杀开始时间', `end_time` TIMESTAMP NOT NULL COMMENT '秒杀结束时间', KEY idx_start_time(start_time), // 指定索引，KEY表示索引，idx_start_time为新建的索引的名字 KEY idx_end_time(end_time), KEY idx_create_time(create_time)) ENGINE=INNODB DEFAULT CHARSET=utf8 COLLATE=utf8_unicode_ci COMMENT='秒杀库存表'; // 指定字符集并且添加描述，注意和字段添加描述的不同 对于自增主键，可以在创建数据库的时候指定自增主键的起始值： 1CREATE TABLE seckill() ENGINE=InnoDB AUTO_INCREMENT=1000 DEFAULT CHARSET=utf8 COMMENT='秒杀库存表' 执行下面的语句可以查看表的创建过程： 1show create table seckill\\G; 因此在创建数据库的时候通过COMMENT添加注释可以有助于理解。 修改表的某个字段的属性： 1alter table employees modify email null; 给某个表添加一列： 1ALTER TABLE tbl_employee ADD COLUMN d_id INT(11); 给某个表添加外键 1ALTER TABLE tbl_employee ADD CONSTRAINT fk_emp_dept FOREIGN KEY(d_id) REFERENCES tbl_dept(id); 联合主键及索引 1234567CREATE TABLE `appointment` ( `book_id` bigint(20) NOT NULL COMMENT '图书ID', `student_id` bigint(20) NOT NULL COMMENT '学号', `appoint_name` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_STAMP COMMENT '预约时间', -- 当执行update操作时，并且字段有ON UPDATE CURRENT_STAMP属性，则字段无论值有没有变化，它的值也会跟着更新为当前UPDATE操作时的时间 PRIMARY KEY (`book_id`, `student_id`), INDEX `idx_appoint_time` (`appoint_time`)) ENGINE=InnoDB DEFAULT CHARSET=utf8 COMMENT='预约图书表' ​","tags":[{"name":"DB","slug":"DB","permalink":"https://glemontree.github.io/tags/DB/"}]},{"title":"[MyBatis] MyBatis第五课---MyBatis参数处理","date":"2017-09-13T08:38:13.000Z","path":"2017/09/13/[MyBatis] MyBatis第五课---MyBatis参数处理/","text":"单个参数的传递通过#{参数名}取出参数值，实际上在传递单个参数的时候，MyBatis不会做特殊处理，实际上#{}内部的参数名你可以任意取值，但还是建议和接口中参数的名字保持一致。 多个参数的传递MyBatis遇见多个参数时会进行特殊处理，多个参数会被封装成一个Map，#{}就是从Map中获取指定key的值，key的值为param1...paramN，而value才是我们传入的值。要想从传入的Map中取值，只能通过#{param1}、#{param2}…或者#{0}、#{1}… 1public Employee getEmpByIdAndLastName(Integer id, String lastName); 其对应的SQL映射为： 123&lt;select id=\"getEmpByIdAndLastName\" resultType=\"com.glemontree.mybatis.bean.Employee\"&gt; select * from tbl_employee where id = #&#123;param1&#125; and last_name = #&#123;param2&#125;&lt;/select&gt; 然后进行测试： 123456789101112131415161718@Testpublic void test04() throws IOException &#123; // 获取SqlSessionFactory对象 SqlSessionFactory sqlSessionFactory = getSqlSessionFactory(); // 根据SqlSessionFactory获取SqlSession对象 // openSession()方法不会自动提交，需要自己手动提交 // openSession(true)方法会进行自动提交 SqlSession openSession = sqlSessionFactory.openSession(); // 获取接口的实现类对象 // MyBatis会为接口自动的创建一个代理对象，代理对象去执行增删改查 try &#123; EmployeeMapper mapper = openSession.getMapper(EmployeeMapper.class); Employee employee = mapper.getEmpByIdAndLastName(1, \"tom\"); System.out.println(employee); &#125; finally &#123; openSession.close(); &#125;&#125; 这种方法虽然可以使用，但是不够直观，因此，通常使用命名参数：明确指定封装参数时Map的key，不要再使用param1、param2...，可以使用@Param注解来完成。 1public Employee getEmpByIdAndLastName(@Param(\"id\") Integer id, @Param(\"lastName\") String lastName); 这样，在封装Map时所使用的key就是id和lastName。 另一方面，如果参数很多，正好是业务逻辑的数据模型，我们就可以直接传入POJO，此时使用#{属性名}就可以取出传入的POJO属性值。 如果多个参数不是业务逻辑的数据模型，没有对应的POJO，为了方便，我们也可以传入Map，此时#{key}就是取出Map中对应的值。 1public Employee getEmpByMap(Map&lt;String, Object&gt; map); 123&lt;select id=\"getEmpByMap\" resultType=\"com.glemontree.mybatis.bean.Employee\"&gt; select * from tbl_employee where id = #&#123;id&#125; and last_name = #&#123;lastName&#125;&lt;/select&gt; 1234567891011121314151617181920@Test public void test04() throws IOException &#123; // 获取SqlSessionFactory对象 SqlSessionFactory sqlSessionFactory = getSqlSessionFactory(); // 根据SqlSessionFactory获取SqlSession对象 // openSession()方法不会自动提交，需要自己手动提交 // openSession(true)方法会进行自动提交 SqlSession openSession = sqlSessionFactory.openSession(); // 获取接口的实现类对象 // MyBatis会为接口自动的创建一个代理对象，代理对象去执行增删改查 try &#123; EmployeeMapper mapper = openSession.getMapper(EmployeeMapper.class); Map&lt;String, Object&gt; map = new HashMap&lt;String, Object&gt;(); map.put(\"id\", 1); map.put(\"lastName\", \"tom\"); Employee employee = mapper.getEmpByMap(map); &#125; finally &#123; openSession.close(); &#125; &#125; 如果多个参数不是业务模型中的数据，但是经常要使用，推荐编写一个TO（Transfer Object）数据传输对象。比如分页查询的时候封装一个Page： 1234Page &#123; int index; int size;&#125; 需要注意的是，如果接口参数类型为Collection（List、Set）类型或者是数组也会特殊处理，也是把传入的List或者数组封装在Map中，若为Collection，key使用的是collection，若为List，key还可以使用list；若为数组，则key使用的是array，例如： 假设接口如下： 1public Employee getEmpById(List&lt;Integer&gt; ids); 则取值的时候取出第一个id的值需要使用#{list[0]}。 参数值的获取#{}可以获取Map中的值或者POJO对象属性的值，对于MyBatis来说，还支持${}的取值方式。两者的区别在于：#{}是以预编译的形式将参数设置到SQL语句中，可以防止SQL注入，而${}取出的值直接拼装在SQL语句中，会有安全问题。 大多情况下我们取参数的值都应该使用#{}，对于原生JDBC不支持占位符的地方就可以使用${}进行取值。举个例子： 分表操作，按照年份分表拆分： 1select * from $&#123;year&#125;_salary where xxx; 原生JDBC是不能如下操作的： 1select * from ? where xxx; 此时可以使用${}进行取值。 再比如排序： 1select * from tbl_employee order by $&#123;f_name&#125; $&#123;order&#125;; 同样地，原生JDBC不支持order by后面使用占位符。 参数处理 参数可以指定一个特殊的数据类型： 12#&#123;property, javaType=int, jdbcType=NUMERIC&#125;#&#123;height, javaType=double, jdbcType=NUMERIC, numericScale=2&#125; javaType通常可以从参数对象中来确定 如果null被当做值来传递，对于所有可能为空的列，jdbcType需要被设置 对于数值类型，还可以设置小数点后保留的位数 mode属性（存储过程）允许指定IN、OUT或INOUT参数，如果参数为OUT或INOUT，参数对象属性的真实值将会被改变 jdbcType通常需要在某种特定的条件下被设置：在我们数据为null的时候，有些数据库可能不能识别MyBatis对null的默认处理比如Oracle，Oracle会报JdbcType OTHER无效的类型错误。 MyBatis对所有的null映射的是原生Jdbc的OTHER类型，Oracle不能正确处理。 此时可以做如下设置： 1#&#123;email, jdbcType=NULL&#125; 这是因为全局配置中jdbcTypeForNull=OTHER，Oracle不支持，因此主要有以下两种解决办法： #{email, jdbcType=OTHER} 这种解决方法只会影响当前SQL语句的jdbcType。 更改全局配置中jdbcTypeForNull，将其改为NULL即可，如下： 123&lt;settings&gt; &lt;setting name=\"jdbcTypeForNull\" value=\"NULL\"/&gt;&lt;/settings&gt; ​ ​","tags":[{"name":"MyBatis, 参数处理","slug":"MyBatis-参数处理","permalink":"https://glemontree.github.io/tags/MyBatis-参数处理/"}]},{"title":"[Android] 利用APT实现Android编译时注解","date":"2017-09-12T03:40:15.000Z","path":"2017/09/12/[Android] 利用APT实现Android编译时注解/","text":"说在前面本文转载自文章利用APT实现Android编译时注解，文章对实现编译时注解讲解很详细！ APT概述我们在前面的java注解详解一文中已经讲过，可以在运行时利用反射机制运行处理注解。其实，我们还可以在编译时处理注解，这就是不得不说官方为我们提供的注解处理工具APT (Annotation Processing Tool )。 APT用来在编译时期扫描处理源代码中的注解信息，我们可以根据注解信息生成一些文件，比如Java文件。利用APT为我们生成的Java代码，实现冗余的代码功能，这样就减少手动的代码输入，提升了编码效率，而且使源代码看起来更清晰简洁。 从Java5开始，JDK就自带了注解处理器APT，不过从近几年开始APT才真正的流行起来，这要得益于Android上各种主流库都用了APT来实现，比如Dagger、ButterKnife、AndroidAnnotation、EventBus等。因为我本身工作中经常用到上面这些框架，为了更深入了解这些框架的实现过程，因此想利用APT技术实现自己的编译时注解。 实现目标在Android开发中我们经常要编写如下冗余的代码： 12345678910Button button = (Button) findViewById(R.id.button1); Button button2 = (Button) findViewById(R.id.button2); button.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View view) &#123;&#125; &#125;); button2.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View view) &#123;&#125; &#125;); 编写上面这些冗余代码不但浪费时间，而且一定程度上造成源代码冗余复杂。那么为了解决这种问题，我们可以利用注解和APT工具生成一个代理类（ProxyClass），让这个代理类帮助我们实现上面这些冗余的代码。 首先我们通过自定义的注解注解要处理的元素： 12345678910111213141516public class MainActivity extends AppCompatActivity &#123; @ViewById(R.id.tv) TextView textView; @ViewById(R.id.btn) Button button; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); ProxyTool.bind(this); &#125; @Click(&#123;R.id.tv, R.id.btn&#125;) public void myClick(View view) &#123; //Click &#125; &#125; 然后我们利用APT生成MainActivity的代理类 MainActivity$$Proxy，让该类帮我们实现冗余的功能： 12345678910111213141516public class MainActivity$$Proxy implements IProxy&lt;MainActivity&gt; &#123; @Override public void inject(final MainActivity target, View root) &#123; target.button = (Button)(root.findViewById(R.id.btn)); target.textView = (TextView)(root.findViewById(R.id.tv)); View.OnClickListener listener; listener = new View.OnClickListener() &#123; @Override public void onClick(View view) &#123; target.myClick(view); &#125; &#125; ; (root.findViewById(R.id.btn)).setOnClickListener(listener); (root.findViewById(R.id.tv)).setOnClickListener(listener); &#125; &#125; OK，我们接下来就要实现上面的功能。 项目框架我把我们的注解框架命名为ProxyTool，把该框架分为四个模块，前三个为核心模块： proxytool-api：框架api模块，供使用者调用，Android Library类型模块 proxytool-annotations：自定义注解模块，Java类型模块 proxytool-compiler：注解处理器模块，用于处理注解并生成文件，Java类型模块 proxytool-sample：示例Demo模块，Android工程类型模块 其中这四个模块的依赖关系如下： proxytool-api依赖proxytool-annotations模块。proxytool-compiler依赖proxytool-annotations模块。proxytool-sample模块依赖proxytool-api模块。 有人也许会问，为什么不可以将这写模块写在一起呢？ 因为注解处理模块器proxytool-compiler只在我们编译过程中需要使用到，在APP运行阶段就不需要使用该模块了。所以在发布APP时，我们就不必把注解处理器模块打包进来，以免造成程序臃肿，所以把proxytool-compiler模块单独拿出来。同时注解处理模块和api模块都需要使用到自定义注解模块，所以就需要把自定义注解模块单独拿出来。这样为何需要分成三个模块的原因也就一目了然了，其实butterfnife框架也是这样分的。 自定义注解模块首先我们在自定义注解模块中定义两个注解类型，分别用于绑定View的id和注册View的点击事件： 12345678/** * Bind a field to the view for the specified ID */ @Retention(RetentionPolicy.SOURCE) @Target(ElementType.FIELD) public @interface ViewById &#123; int value(); &#125; 12345678/** * Bind a method to an android.view.View.OnClickListener on the view for each ID specified. */ @Target(ElementType.METHOD) @Retention(RetentionPolicy.SOURCE) public @interface OnClick &#123; public int[] value(); &#125; ViewById中的value用于接收注解该View的id值，OnClick中的value数组用于接收一组View的id值，这些view会被注册点击响应事件。因为这些注册只在编译时有需要用到，程序运行时就不再需要了，所以我们把这些注解定义成编译时保留（RetentionPolicy.SOURCE）即可。限于篇幅的考虑，下面的介绍中我只对ViewById注解做处理，OnClick注解处理也是类似的。 注解处理器模块创建好自定义注解后，我们就需要利用java提供的注解处理器根据自定义的注解来生成代理类了，该模块需要依赖其他三个模块： 123compile &apos;com.squareup:javapoet:1.7.0&apos; compile &apos;com.google.auto.service:auto-service:1.0-rc2&apos; compile project(&apos;:proxytool-annotations&apos;) javapoet是square公司出的一个帮助我们非常方便生成java代码文件的第三方库，避免我们手动拼接字符串的麻烦。 auto-service是google公司出的第三方库，主要用于注解处理器，可以自动帮我们生成META-INF 配置信息。 注解处理器要根据自定义注解进行解析，所以也需要依赖该模块。 让我们看一下注解处理器的API。所有的注解处理器都必须继承AbstractProcessor，如下所示： 12345678910111213141516171819202122232425262728293031323334353637383940414243/** * 注解处理器 */ @AutoService(Processor.class) public class ProxyToolProcessor extends AbstractProcessor &#123; private Filer mFiler; //文件相关工具类 private Elements mElementUtils; //元素相关的工具类 private Messager mMessager; //日志相关的工具类 /** * 处理器的初始化方法，可以获取相关的工具类 */ @Override public synchronized void init(ProcessingEnvironment processingEnv) &#123; super.init(processingEnv); mFiler = processingEnv.getFiler(); mElementUtils = processingEnv.getElementUtils(); mMessager = processingEnv.getMessager(); &#125; /** * 处理器的主方法，用于扫描处理注解，生成java文件 */ @Override public boolean process(Set&lt;? extends TypeElement&gt; annotations, RoundEnvironment roundEnv) &#123; ... return false; &#125; /** * 指定哪些注解应该被注解处理器注册 */ @Override public Set&lt;String&gt; getSupportedOptions() &#123; Set&lt;String&gt; types = new LinkedHashSet&lt;&gt;(); types.add(ViewById.class.getName()); types.add(OnClick.class.getName()); return types; &#125; /** * 用来指定你使用的 java 版本 */ @Override public SourceVersion getSupportedSourceVersion() &#123; return SourceVersion.latestSupported(); &#125; &#125; @AutoService(Processor.class) 属于auto-service库，可以自动生成META-INF/services/javax.annotation.processing.Processor文件（该文件是所有注解处理器都必须定义的），免去了我们手动配置的麻烦。 init(ProcessingEnvironment processingEnvironment) 在处理器初始化的调用，通过processingEnv参数我们可以拿到一些实用的工具类Elements, Messager和Filer。我们在后面将会使用到它们。Elements，一个用来处理Element的工具类。Messager，一个用来输出日志信息的工具类。Filer、如这个类的名字所示，你可以使用这个类来创建文件。 process(Set set, RoundEnvironment roundEnvironment) 这是注解处理器的主方法，你可以在这个方法里面编码实现扫描，处理注解，生成 java 文件。 getSupportedAnnotationTypes() 在这个方法里面你必须指定哪些注解应该被注解处理器注册。它的返回值是一个String集合，包含了你的注解处理器想要处理的注解类型的全限定名。 getSupportedSourceVersion() 用来指定你使用的 java 版本，通常我们返回SourceVersion.latestSupported()即可。 1234567891011121314151617@SupportedSourceVersion(SourceVersion.RELEASE_7)@SupportedAnnotationTypes(&#123; \"proxytool.ViewById\", \"proxytool.OnClick\"&#125;)public class MyProcessor extends AbstractProcessor &#123; @Override public boolean process(Set&lt;? extends TypeElement&gt; annoations, RoundEnvironment env) &#123; return false; &#125; @Override public synchronized void init(ProcessingEnvironment processingEnv) &#123; super.init(processingEnv); &#125;&#125; 但是考虑到兼容性问题，建议还是重写getSupportedSourceVersion方法和getSupportedAnnotationTypes方法 Element元素在继续讲解处理器之前，我们必须先明白Elment元素这个概念。在注解处理器中，我们扫描 java 源文件，源代码中的每一部分都是Element的一个特定类型。换句话说：Element代表程序中的元素，比如说 包，类，方法。在下面的例子中，我将添加注释来说明这个问题： 1234567891011121314package com.example; //PackageElement public class Foo &#123; // TypeElement private int a; // VariableElement private Foo other; // VariableElement public Foo() &#123;&#125; // ExecuteableElement public void setA( // ExecuteableElement int newA // TypeElement ) &#123; &#125; &#125; ExecuteableElement：可以表示一个普通方法、构造方法、初始化方法（静态和实例）。 PackageElement：代表一个包名。 TypeElement：代表一个类、接口。 VariableElement：代表一个字段、枚举常量、方法或构造方法的参数、本地变量、或异常参数等。 Element：上述所有元素的父接口，代表源码中的每一个元素。 在注解处理器世界中，整个java代码被结构化了。我们需要像解析XML文件一样去解析整个源代码。Element就像XML解析器中的DOM元素，你可以通过如下两个方法获取该元素的子元素和父元素： 12Element getEnclosingElement(); //获取父元素 List&lt;? extends Element&gt; getEnclosedElements(); //获取子元素 比如你有如下的一个类 1234567public class Foo &#123; private int a; // VariableElement private Foo other; // VariableElement public Foo() &#123;&#125; // ExecuteableElement &#125; 成员变量a通过getEnclosingElement()方法返回的是的父元素是类Foo，类Foo 通过getEnclosedElements()返回的子元素就包括成员变量a、成员变量other以及构造方法Foo()。关于这两个方法更多的解释，可以参见官方文档。 实现process方法收集注解信息注解处理器中，最核心的方法就是process()，在这里你可以扫描和处理注解，并生成java文件。首先我们扫描所有被@ViewById注解的元素： 1234567891011@Override public boolean process(Set&lt;? extends TypeElement&gt; set, RoundEnvironment roundEnvironment) &#123; //处理被ViewById注解的元素 for (Element element : roundEnv.getElementsAnnotatedWith(ViewById.class)) &#123; if (!isValid(ViewById.class, \"fields\", element)) &#123; return true; &#125; parseViewById(element); &#125; ... 通过roundEnvironment.getElementsAnnotatedWith(ViewById.class)方法返回一个被@ViewById注解的Element 类型的元素列表。注意这里是Element列表，而不是类列表，Element可以包括类、方法、变量等。 匹配准则接下来我们需要对这个元素做进一步的检查，保证被注解的元素是符合规范的。如果使用者不按规范随意注解元素的话，程序是无法正常运行的。所以我们需要执行isVaid方法用于检测被注解元素的合法性： 1234567891011121314151617181920212223242526272829303132333435363738394041424344private boolean isValid(Class&lt;? extends Annotation&gt; annotationClass, String targetThing, Element element) &#123; boolean isVaild = true; //获取变量的所在的父元素，肯能是类、接口、枚举 TypeElement enclosingElement = (TypeElement) element.getEnclosingElement(); //父元素的全限定名 String qualifiedName = enclosingElement.getQualifiedName().toString(); // 所在的类不能是private或static修饰 Set&lt;Modifier&gt; modifiers = element.getModifiers(); if (modifiers.contains(PRIVATE) || modifiers.contains(STATIC)) &#123; error(element, \"@%s %s must not be private or static. (%s.%s)\", annotationClass.getSimpleName(), targetThing, enclosingElement.getQualifiedName(), element.getSimpleName()); isVaild = false; &#125; // 父元素必须是类，而不能是接口或枚举 if (enclosingElement.getKind() != ElementKind.CLASS) &#123; error(enclosingElement, \"@%s %s may only be contained in classes. (%s.%s)\", annotationClass.getSimpleName(), targetThing, enclosingElement.getQualifiedName(), element.getSimpleName()); isVaild = false; &#125; //不能在Android框架层注解 if (qualifiedName.startsWith(\"android.\")) &#123; error(element, \"@%s-annotated class incorrectly in Android framework package. (%s)\", annotationClass.getSimpleName(), qualifiedName); return false; &#125; //不能在java框架层注解 if (qualifiedName.startsWith(\"java.\")) &#123; error(element, \"@%s-annotated class incorrectly in Java framework package. (%s)\", annotationClass.getSimpleName(), qualifiedName); return false; &#125; return isVaild; &#125; private void error(Element e, String msg, Object... args) &#123; mMessager.printMessage(Diagnostic.Kind.ERROR, String.format(msg, args), e); &#125; 在isValid方法中，它检查被注解的元素是否符合规则： 被注解元素的父元素必须是个类，而不能是接口、枚举。 被注解元素的父元素必须是非private 和 非static修饰。 被注解的元素只能注解非框架层元素。 这里只是简单的列出几个是否符合注解规范的条件，更严格的判断条件还需要大家来完善。 错误处理不知道大家有没有发现，在error方法中利用了Messager（init方法中获取到的工具类）来处理错误信息。Messager为注解处理器提供了一种报告错误消息，警告信息和其他消息的方式。它不是注解处理器开发者的日志工具。Messager是用来给那些使用了你的注解处理器的第三方开发者显示信息的。其中非常重要的是Kind.ERROR级别信息，因为这种消息类型是用来表明我们的注解处理器在处理过程中出错了。有可能是第三方开发者误使用了我们的@ViewById注解（比如，使用@ViewById注解了一个接口中的变量）。这个概念与传统的 java 应用程序有一点区别。传统的 java 应用程序出现了错误，你可以抛出一个异常。如果你在process()中抛出了一个异常，那 jvm 就会崩溃。注解处理器的使用者将会得到一个从 javac 给出的非常难懂的异常错误信息。因为它包含了注解处理器的堆栈信息。因此注解处理器提供了Messager类。它能打印漂亮的错误信息，而且你可以链接到引起这个错误的元素上。回到process中： 123456789101112@Override public boolean process(Set&lt;? extends TypeElement&gt; set, RoundEnvironment roundEnvironment) &#123; //处理被ViewById注解的元素 for (Element element : roundEnvironment.getElementsAnnotatedWith(ViewById.class)) &#123; if (!isValid(ViewById.class, \"fields\", element)) &#123; return true; &#125; parseViewById(element); &#125; ... &#125; 为了能够获取Messager显示的信息，非常重要的是注解处理器必须不崩溃地完成运行。这就是我们在调用error()后，跳出isValid，执行return true的原因。如果我们在这里没有返回的话，process()就会继续运行，因为messager.printMessage( Diagnostic.Kind.ERROR)并不会终止进程。 数据模型一旦isValid方法检查通过，那么就表示该注解元素是可以使用的，因此我们继续执行parseViewById方法，把这些元素封装成model，供后面生成Java文件时使用。 1234567891011121314151617181920212223242526272829private Map&lt;String, ProxyClass&gt; mProxyClassMap = new HashMap&lt;&gt;(); /** * 处理ViewById注解 * * @param element */ private void parseViewById(Element element) &#123; ProxyClass proxyClass = getProxyClass(element); //把被注解的view对象封装成一个model，放入代理类的集合中 FieldViewBinding bindView = new FieldViewBinding(element); proxyClass.add(bindView); &#125; /** * 生成或获取注解元素所对应的ProxyClass类 */ private ProxyClass getProxyClass(Element element) &#123; //被注解的变量所在的类 TypeElement classElement = (TypeElement) element.getEnclosingElement(); String qualifiedName = classElement.getQualifiedName().toString(); ProxyClass proxyClass = mProxyClassMap.get(qualifiedName); if (proxyClass == null) &#123; //生成每个宿主类所对应的代理类，后面用于生产java文件 proxyClass = new ProxyClass(classElement, mElementUtils); mProxyClassMap.put(qualifiedName, proxyClass); &#125; return proxyClass; &#125; parseViewById(Element element)：在该方法中，首先需要通过getProxyClass方法获取一个ProxyClass类型的对象。ProxyClass代表了该注解元素所对应的类元素，这里我们利用面向对象的思想进行了封装。然后我们把被注解的元素也封装成一个FieldViewBinding类型的model，并放入到ProxyClass中。 getProxyClass(Element element)：该方法主要是生成或获取注解元素所对应的类，。你可以在getProxyClass方法中看到，利用getEnclosingElement方法获取了该注解元素的父元素，也就是该注解元素的所在的类。我们把每一个类元素TypeElement都封装成了ProxyClass，并保存在HashMap中。 上面这两个方法的作用，主要是把注解的元素和注解元素所在的类都封装成了model，并存储起来，供我们后面生成Java源码时使用。下面表示了两个model类： FieldViewBinding类： 12345678910111213141516171819202122232425262728293031public class FieldViewBinding &#123; /** 注解元素*/ private VariableElement mElement; /** 资源id*/ private int mResId; /** 变量名*/ private String mVariableName; /**变量类型*/ private TypeMirror mTypeMirror; public FieldViewBinding(Element element) &#123; mElement = (VariableElement) element; ViewById viewById = element.getAnnotation(ViewById.class); //资源id mResId = viewById.value(); //变量名 mVariableName = element.getSimpleName().toString(); //变量类型 mTypeMirror = element.asType(); &#125; public VariableElement getElement() &#123; return mElement;&#125; public int getResId() &#123; return mResId;&#125; public String getVariableName() &#123;return mVariableName;&#125; public TypeMirror getTypeMirror() &#123;return mTypeMirror;&#125; &#125; 12345678910111213141516171819202122232425262728public class ProxyClass &#123; /**类元素 */ public TypeElement mTypeElement; /**元素相关的辅助类*/ private Elements mElementUtils; /** FieldViewBinding类型的集合*/ private Set&lt;FieldViewBinding&gt; bindViews = new HashSet&lt;&gt;(); public ProxyClass(TypeElement mTypeElement, Elements mElementUtils) &#123; this.mTypeElement = mTypeElement; this.mElementUtils = mElementUtils; &#125; public void add(FieldViewBinding bindView) &#123; bindViews.add(bindView); &#125; /** * 用于生成代理类 */ public JavaFile generateProxy() &#123; ... &#125; &#125; ProxyClass类中的generateProxy()方法是用于生成每个类所对应的代理类，比如类MainActivity就会生成类MainActivity$$Proxy，该方法生成的详细过程会后面再讲。 文件的生成既然我们已经收集到了注解元素和注解元素所在的类，那么我们就需要为每个类生成一个全新的代理类，在代理类中执行那些冗余的代码操作。继续回到process方法中： 123456789101112131415161718[java] view plain copy@Override public boolean process(Set&lt;? extends TypeElement&gt; annotations, RoundEnvironment roundEnv) &#123; ... //为每个宿主类生成所对应的代理类 for (ProxyClass proxyClass_ : mProxyClassMap.values()) &#123; try &#123; proxyClass_.generateProxy().writeTo(mFiler); &#125; catch (IOException e) &#123; error(null, e.getMessage()); &#125; &#125; mProxyClassMap.clear(); return true; &#125; 现在既然已经收集到了每个注解元素所对应的类，那么我们就需要为每个类生成所对应的代理类，遍历所有的类元素集合mProxyClassMap 通过ProxyClass的generateProxy()方法来生成Java源码： ProxyClass##generateProxy() 123456789101112131415161718192021222324252627282930313233343536373839404142//proxytool.IProxy public static final ClassName IPROXY = ClassName.get(\"proxytool.api\", \"IProxy\"); //android.view.View public static final ClassName VIEW = ClassName.get(\"android.view\", \"View\"); //生成代理类的后缀名 public static final String SUFFIX = \"$$Proxy\"; /** * 用于生成代理类 */ public JavaFile generateProxy() &#123; //生成public void inject(final T target, View root)方法 MethodSpec.Builder injectMethodBuilder = MethodSpec.methodBuilder(\"inject\") .addModifiers(Modifier.PUBLIC) .addAnnotation(Override.class) .addParameter(TypeName.get(mTypeElement.asType()), \"target\", Modifier.FINAL) .addParameter(VIEW, \"root\"); //在inject方法中，添加我们的findViewById逻辑 for (FieldViewBinding model : bindViews) &#123; // find views injectMethodBuilder.addStatement(\"target.$N = ($T)(root.findViewById($L))\", model.getVariableName(), ClassName.get(model.getTypeMirror()), model.getResId()); &#125; // 添加以$$Proxy为后缀的类 TypeSpec finderClass = TypeSpec.classBuilder(mTypeElement.getSimpleName() + SUFFIX) .addModifiers(Modifier.PUBLIC) //添加父接口 .addSuperinterface(ParameterizedTypeName.get(IPROXY, TypeName.get(mTypeElement.asType()))) //把inject方法添加到该类中 .addMethod(injectMethodBuilder.build()) .build(); //添加包名 String packageName = mElementUtils.getPackageOf(mTypeElement).getQualifiedName().toString(); //生成Java文件 return JavaFile.builder(packageName, finderClass).build(); &#125; 上面我们使用了javapoet来帮助我们生成Java源码，免去手动拼接字符串的麻烦。生成过程很简单，看注释就明白了。 不知道大家发现了没有循环结束后我们还执行了mProxyClassMap.clear()，原因就在于process()可以被多次调用，因为新生成的Java文件很可能包括@ViewById注解，所以process方法会多次执行直到没有生成该注解为止。所以我们应该清空之前的数据，避免生成重复的代理类。 API模块既然已经生成了代理类，那么我还需要提供API供使用者访问该代理类，供在Activity、Fragment、View中如下使用： 12345678//Activity ProxyTool.bind(this); //Fragment ProxyTool.bind(this, view); //View ProxyTool.bind(this); 在ProxyTool的bind()方法中我们需要为需要为不同的目标（比如 Activity、Fragment 和 View 等）提供重载的注入方法，这些方法最终都调用createBinding()方法： 12345678910111213141516171819202122232425262728293031323334353637public class ProxyTool &#123; //Activity @UiThread public static void bind(@NonNull Activity target) &#123; View sourceView = target.getWindow().getDecorView(); createBinding(target, sourceView); &#125; //View @UiThread public static void bind(@NonNull View target) &#123; createBinding(target, target); &#125; //Fragment @UiThread public static void bind(@NonNull Object target, @NonNull View source) &#123; createBinding(target, source); &#125; public static final String SUFFIX = \"$$Proxy\"; public static void createBinding(@NonNull Object target, @NonNull View root) &#123; try &#123; //生成类名+后缀名的代理类，并执行注入操作 Class&lt;?&gt; targetClass = target.getClass(); Class&lt;?&gt; proxyClass = Class.forName(targetClass.getName() + SUFFIX); IProxy proxy = (IProxy) proxyClass.newInstance(); proxy.inject(target, root); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; &#125; 我们重载了三个bind方法用于接收的不同目标（Activity、Fragment 和 View 等），target参数表示注解元素所在的类，root参数表示要查找的View的，因为Activity和View本身即是target也是root，所以只要一个参数即可，而Fragment中类和View是分离的，所以需要两个参数。 所有bind方法最终调用了createBinding方法，在该方法中我们通过targetClass.getName() + SUFFIX，拼接成代理类的全限定名，然后生成代理类的实例，并执行代理类的inject方法，该方法中执行的就是findViewById的操作。 这里我们还需要注意一点，所有生成的代理类都默认实现IProxy接口： 12345678public interface IProxy&lt;T&gt; &#123; /** * @param target 所在的类 * @param root 查找 View 的地方 */ public void inject(final T target, View root); &#125; 该接口定义了inject方法，代理类中需要在该方法中实现具体的注入逻辑。代理类的生成和inject方法的实现，都是在注解处理器模块中进行处理，具体的生成过程都在文件的生成章节中，这里就不再讲。 项目中的使用上面三个核心模块都已经介绍完了，现在让我们在具体的项目中使用吧。 首先在整个工程的build.gradle中添加如下： 1234dependencies &#123; ... classpath &apos;com.neenbedankt.gradle.plugins:android-apt:1.8&apos; &#125; 然后在自己module的build.gradle中添加插件和依赖，如下所示： 123456789apply plugin: &apos;com.neenbedankt.android-apt&apos; ... dependencies &#123; ... compile project(&apos;:proxytool-api&apos;) apt project(&apos;:proxytool-compiler&apos;) &#125; 然后我们在项目中使用该框架的注解和API： 1234567891011121314151617181920public class MainActivity extends AppCompatActivity &#123; @ViewById(R.id.btnOne) Button btnOne; @ViewById(R.id.btnTwo) Button btnTwo; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); ProxyTool.bind(this); &#125; @OnClick(&#123;R.id.btnOne,R.id.btnTwo&#125;) public void myClick(View view)&#123; btnOne.setText(\"111111\"); btnTwo.setText(\"222222\"); &#125; &#125; 执行Make Project操作后，在build/generated/source/apt/debug/下就会生成所对应的代理MainActivity$$Proxy： 12345678910111213141516public class MainActivity$$Proxy implements IProxy&lt;MainActivity&gt; &#123; @Override public void inject(final MainActivity target, View root) &#123; target.btnTwo = (Button)(root.findViewById(2131427414)); target.btnOne = (Button)(root.findViewById(2131427413)); View.OnClickListener listener; listener = new View.OnClickListener() &#123; @Override public void onClick(View view) &#123; target.myClick(view); &#125; &#125; ; (root.findViewById(2131427413)).setOnClickListener(listener); (root.findViewById(2131427414)).setOnClickListener(listener); &#125; &#125; 总结限于篇幅的考虑，上面只介绍了如何对ViewById注解进行处理，OnClick注解处理也是类似的。整个项目的地址：https://github.com/maofan4041/ProxyTool 参考：ANNOTATION PROCESSING 101Annotation-Processing-Tool详解Android 利用 APT 技术在编译期生成代码Android 如何编写基于编译时注解的项目万能的APT！编译时注解的妙用","tags":[{"name":"Android, APT、编译时注解","slug":"Android-APT、编译时注解","permalink":"https://glemontree.github.io/tags/Android-APT、编译时注解/"}]},{"title":"[Java] Java反射","date":"2017-09-11T12:00:00.000Z","path":"2017/09/11/[Java] Java反射/","text":"声明本篇文章转载自JAVA反射与注解，作者先讲解了Java反射，然后在Java反射的基础上又对Java注解进行了讲解，我主要是对其中Java反射部分进行摘录。 什么是Java反射主要是指程序可以访问，检测和修改它本身状态或行为的一种能力，并能根据自身行为的状态和结果，调整或修改应用所描述行为的状态和相关的语义。 什么是反射机制反射机制就是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性；这种动态获取的信息以及动态调用对象的方法的功能称为java语言的反射机制。 用一句话总结就是反射可以实现在运行时可以知道任意一个类的属性和方法。 反射机制能做什么反射机制主要提供了以下功能： 在运行时判断任意一个对象所属的类； 在运行时构造任意一个类的对象； 在运行时判断任意一个类所具有的成员变量和方法； 在运行时调用任意一个对象的方法； 生成动态代理 Java反射机制的应用场景是什么 逆向代码 ，例如反编译 与注解相结合的框架 例如Retrofit 单纯的反射机制应用框架 例如EventBus 动态生成类框架 例如Gson 理解Class类和类类型想要了解反射首先理解一下Class类，它是反射实现的基础。类是java.lang.Class类的实例对象，而Class是所有类的类（There is a class named Class）对于普通的对象，我们一般都会这样创建和表示： 1Code code1 = new Code(); 上面说了，所有的类都是Class的对象，那么如何表示呢，可不可以通过如下方式呢： 1Class c = new Class(); 但是我们查看Class的源码时，是这样写的： 123private Class(ClassLoader loader) &#123; classLoader = loader; &#125; 可以看到构造器是私有的，只有JVM可以创建Class的对象，因此不可以像普通类一样new一个Class对象，虽然我们不能new一个Class对象，但是却可以通过已有的类得到一个Class对象，共有三种方式，如下： 123Class c1 = Code.class; // 这说明任何一个类都有一个隐含的静态成员变量class，这种方式是通过获取类的静态成员变量class得到的Class c2 = code1.getClass(); // code1是Code的一个对象，这种方式是通过一个类的对象的getClass()方法获得的 Class c3 = Class.forName(\"com.trigl.reflect.Code\"); // 这种方法是Class类调用forName方法，通过一个类的全量限定名获得 这里，c1、c2、c3都是Class的对象，他们是完全一样的，而且有个学名，叫做Code的类类型（class type）。这里就让人奇怪了，前面不是说Code是Class的对象吗，而c1、c2、c3也是Class的对象，那么Code和c1、c2、c3不就一样了吗？为什么还叫Code什么类类型？这里不要纠结于它们是否相同，只要理解类类型是干什么的就好了，顾名思义，类类型就是类的类型，也就是描述一个类是什么，都有哪些东西，所以我们可以通过类类型知道一个类的属性和方法，并且可以调用一个类的属性和方法，这就是反射的基础。 举个简单例子代码： 12345678910111213141516public class ReflectDemo &#123; public static void main(String[] args) throws ClassNotFoundException &#123; //第一种：Class c1 = Code.class; Class class1=ReflectDemo.class; System.out.println(class1.getName()); //第二种：Class c2 = code1.getClass(); ReflectDemo demo2= new ReflectDemo(); Class c2 = demo2.getClass(); System.out.println(c2.getName()); //第三种：Class c3 = Class.forName(\"com.trigl.reflect.Code\"); Class class3 = Class.forName(\"com.tengj.reflect.ReflectDemo\"); System.out.println(class3.getName()); &#125;&#125; 执行结果： 123com.tengj.reflect.ReflectDemocom.tengj.reflect.ReflectDemocom.tengj.reflect.ReflectDemo Java反射相关操作在这里先看一下sun为我们提供了那些反射机制中的类： java.lang.Class; java.lang.reflect.Constructor; java.lang.reflect.Field; java.lang.reflect.Method; java.lang.reflect.Modifier; 前面我们知道了怎么获取Class，那么我们可以通过这个Class干什么呢？总结如下： 获取成员方法Method 获取成员变量Field 获取构造函数Constructor 下面来具体介绍： 获取成员方法信息两个参数分别表示方法名和方法参数类的类类型列表 12345678public Method getDeclaredMethod(String name, Class&lt;?&gt;... parameterTypes) // 得到该类所有的方法，不包括父类的 public Method getMethod(String name, Class&lt;?&gt;... parameterTypes) // 得到该类所有的public方法，包括父类的//具体使用Method[] methods = class1.getDeclaredMethods();//获取class对象的所有声明方法 Method[] allMethods = class1.getMethods();//获取class对象的所有public方法 包括父类的方法 Method method = class1.getMethod(\"info\", String.class);//返回次Class对象对应类的、带指定形参列表的public方法 Method declaredMethod = class1.getDeclaredMethod(\"info\", String.class);//返回次Class对象对应类的、带指定形参列表的方法 举个例子： 例如类A有如下一个方法： 123public void fun(String name,int age) &#123; System.out.println(\"我叫\"+name+\",今年\"+age+\"岁\");&#125; 现在知道A有一个对象a，那么就可以通过： 1234Class c = Class.forName(\"com.tengj.reflect.Person\"); //先生成classObject o = c.newInstance(); //newInstance可以初始化一个实例Method method = c.getMethod(\"fun\", String.class, int.class);//获取方法method.invoke(o, \"tengj\", 10); //通过invoke调用该方法，参数第一个为实例对象，后面为具体参数值 完整代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849public class Person &#123; private String name; private int age; private String msg=\"hello wrold\"; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; public Person() &#123; &#125; private Person(String name) &#123; this.name = name; System.out.println(name); &#125; public void fun() &#123; System.out.println(\"fun\"); &#125; public void fun(String name,int age) &#123; System.out.println(\"我叫\"+name+\",今年\"+age+\"岁\"); &#125;&#125;public class ReflectDemo &#123; public static void main(String[] args)&#123; try &#123; Class c = Class.forName(\"com.tengj.reflect.Person\"); Object o = c.newInstance(); Method method = c.getMethod(\"fun\", String.class, int.class); method.invoke(o, \"tengj\", 10); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125; 执行结果： 1我叫tengj,今年10岁 有时候我们想获取类中所有成员方法的信息，要怎么办。可以通过以下几步来实现： 获取所有方法的数组： 1234Class c = Class.forName(\"com.tengj.reflect.Person\");Method[] methods = c.getDeclaredMethods(); // 得到该类所有的方法，不包括父类的或者：Method[] methods = c.getMethods();// 得到该类所有的public方法，包括父类的 然后循环这个数组就得到每个方法了： 1for (Method method : methods) 完整代码如下：person类跟上面一样，这里以及后面就不贴出来了，只贴关键代码 1234567891011121314public class ReflectDemo &#123; public static void main(String[] args)&#123; try &#123; Class c = Class.forName(\"com.tengj.reflect.Person\"); Method[] methods = c.getDeclaredMethods(); for(Method m:methods)&#123; String methodName= m.getName(); System.out.println(methodName); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125; 执行结果如下： 123456getNamesetNamesetAgefunfungetAge 这里如果把c.getDeclaredMethods();改成c.getMethods();执行结果如下，多了很多方法，以为把Object里面的方法也打印出来了，因为Object是所有类的父类： 123456789101112131415getNamesetNamegetAgesetAgefunfunwaitwaitwaitequalstoStringhashCodegetClassnotifynotifyAll 获取成员变量信息想一想成员变量中都包括什么：成员变量类型+成员变量名 类的成员变量也是一个对象，它是java.lang.reflect.Field的一个对象，所以我们通过java.lang.reflect.Field里面封装的方法来获取这些信息。 单独获取某个成员变量，通过Class类的以下方法实现： 12345678public Field getDeclaredField(String name) // 获得该类自身声明的所有变量，不包括其父类的变量public Field getField(String name) // 获得该类自所有的public成员变量，包括其父类变量//具体实现Field[] allFields = class1.getDeclaredFields();//获取class对象的所有属性 Field[] publicFields = class1.getFields();//获取class对象的public属性 Field ageField = class1.getDeclaredField(\"age\");//获取class指定属性 Field desField = class1.getField(\"des\");//获取class指定的public属性 举个例子： 例如一个类A有如下成员变量： 1private int msg; 如果A有一个对象a，那么就可以这样得到其成员变量： 12Class c = a.getClass();Field field = c.getDeclaredField(\"msg\"); 完整代码如下： 123456789101112131415public class ReflectDemo &#123; public static void main(String[] args)&#123; try &#123; Class c = Class.forName(\"com.tengj.reflect.Person\"); //获取成员变量 Field field = c.getDeclaredField(\"msg\"); //因为msg变量是private的，所以不能用getField方法 Object o = c.newInstance(); field.setAccessible(true);//设置是否允许访问，因为该变量是private的，所以要手动设置允许访问，如果msg是public的就不需要这行了。 Object msg = field.get(o); System.out.println(msg); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125; 执行结果： 1hello wrold 同样，如果想要获取所有成员变量的信息，可以通过以下几步 获取所有成员变量的数组： 1Field[] fields = c.getDeclaredFields(); 遍历变量数组，获得某个成员变量field 1for (Field field : fields) 完整代码如下： 12345678910111213public class ReflectDemo &#123; public static void main(String[] args)&#123; try &#123; Class c = Class.forName(\"com.tengj.reflect.Person\"); Field[] fields = c.getDeclaredFields(); for(Field field :fields)&#123; System.out.println(field.getName()); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125; 执行结果如下： 123nameagemsg 获取构造函数最后再想一想构造函数中都包括什么：构造函数参数同上，类的成构造函数也是一个对象，它是java.lang.reflect.Constructor的一个对象，所以我们通过java.lang.reflect.Constructor里面封装的方法来获取这些信息。 单独获取某个构造函数,通过Class类的以下方法实现： 12345678public Constructor&lt;T&gt; getDeclaredConstructor(Class&lt;?&gt;... parameterTypes) // 获得该类所有的构造器，不包括其父类的构造器public Constructor&lt;T&gt; getConstructor(Class&lt;?&gt;... parameterTypes) // 获得该类所以public构造器，包括父类//具体Constructor&lt;?&gt;[] allConstructors = class1.getDeclaredConstructors();//获取class对象的所有声明构造函数 Constructor&lt;?&gt;[] publicConstructors = class1.getConstructors();//获取class对象public构造函数 Constructor&lt;?&gt; constructor = class1.getDeclaredConstructor(String.class);//获取指定声明构造函数 Constructor publicConstructor = class1.getConstructor(String.class);//获取指定声明的public构造函数 举个例子： 例如类A有如下一个构造函数： 123public A(String a, int b) &#123; // code body&#125; 那么就可以通过： 1Constructor constructor = a.getDeclaredConstructor(String.class, int.class); 来获取这个构造函数。 完整代码： 12345678910111213public class ReflectDemo &#123; public static void main(String[] args)&#123; try &#123; Class c = Class.forName(\"com.tengj.reflect.Person\"); //获取构造函数 Constructor constructor = c.getDeclaredConstructor(String.class); constructor.setAccessible(true);//设置是否允许访问，因为该构造器是private的，所以要手动设置允许访问，如果构造器是public的就不需要这行了。 constructor.newInstance(\"tengj\"); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125; 执行结果： 1tengj 注意：Class的newInstance方法，只能创建只包含无参数的构造函数的类，如果某类只有带参数的构造函数，那么就要使用另外一种方式： 1fromClass.getDeclaredConstructor(String.class).newInstance(\"tengj\"); 获取所有的构造函数，可以通过以下步骤实现： 获取该类的所有构造函数，放在一个数组中： 1Constructor[] constructors = c.getDeclaredConstructors(); 遍历构造函数数组，获得某个构造函数constructor: 1for (Constructor constructor : constructors) 完整代码： 1234567891011public class ReflectDemo &#123; public static void main(String[] args)&#123; Constructor[] constructors = c.getDeclaredConstructors(); for(Constructor constructor:constructors)&#123; System.out.println(constructor); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125; 执行结果： 12public com.tengj.reflect.Person()public com.tengj.reflect.Person(java.lang.String) 其他方法注解需要用到的： 1234Annotation[] annotations = (Annotation[]) class1.getAnnotations();//获取class对象的所有注解 Annotation annotation = (Annotation) class1.getAnnotation(Deprecated.class);//获取class对象指定注解 Type genericSuperclass = class1.getGenericSuperclass();//获取class对象的直接超类的 Type Type[] interfaceTypes = class1.getGenericInterfaces();//获取class对象的所有接口的type集合 获取class对象的信息： 12345678910111213141516boolean isPrimitive = class1.isPrimitive();//判断是否是基础类型 boolean isArray = class1.isArray();//判断是否是集合类boolean isAnnotation = class1.isAnnotation();//判断是否是注解类 boolean isInterface = class1.isInterface();//判断是否是接口类 boolean isEnum = class1.isEnum();//判断是否是枚举类 boolean isAnonymousClass = class1.isAnonymousClass();//判断是否是匿名内部类 boolean isAnnotationPresent = class1.isAnnotationPresent(Deprecated.class);//判断是否被某个注解类修饰 String className = class1.getName();//获取class名字 包含包名路径 Package aPackage = class1.getPackage();//获取class的包信息 String simpleName = class1.getSimpleName();//获取class类名 int modifiers = class1.getModifiers();//获取class访问权限 Class&lt;?&gt;[] declaredClasses = class1.getDeclaredClasses();//内部类 Class&lt;?&gt; declaringClass = class1.getDeclaringClass();//外部类getSuperclass()：获取某类的父类 getInterfaces()：获取某类实现的接口","tags":[{"name":"Java 反射","slug":"Java-反射","permalink":"https://glemontree.github.io/tags/Java-反射/"}]},{"title":"[Java] Java注解","date":"2017-09-11T11:27:51.000Z","path":"2017/09/11/[Java] Java注解/","text":"声明本文转载自文章Java中的注解是如何工作的？，文章对注解讲解比较清楚，所以转载下来做个记录。 什么是注解注解其实就是元数据，即一种描述数据的数据，所以，可以说注解就是源代码的元数据，比如，下面这段代码： 1234@Overridepublic String toString() &#123; return \"This is a test\";&#125; 上面的代码中，重写了toString()方法，并且使用了@Override注解，但是即使不使用@Override注解，程序也能够正常运行，事实上，@Override注解告诉编译器这个方法是一个重写方法（描述方法的元数据），如果父类中不存在该方法，编译器就会报错，提示该方法没有重写父类中的方法，如果不小心拼写错误，例如将toString()写成了toStrring()方法，而且如果没有使用@Override注解，那么程序依然能够编译运行，但运行结果和期望的不同。 Annotation是一种应用于类、方法、参数、变量、构造器及包声明中的特殊修饰符。它是一种由JSR-175标准选择用来描述元数据的一种工具。 为什么要引入注解使用Annotation之前(甚至在使用之后)，XML被广泛的应用于描述元数据。不知何时开始一些应用开发人员和架构师发现XML的维护越来越糟糕了。他们希望使用一些和代码紧耦合的东西，而不是像XML那样和代码是松耦合的(在某些情况下甚至是完全分离的)代码描述。如果你在Google中搜索“XML vs. annotations”，会看到许多关于这个问题的辩论。最有趣的是XML配置其实就是为了分离代码和配置而引入的。上述两种观点可能会让你很疑惑，两者观点似乎构成了一种循环，但各有利弊。下面我们通过一个例子来理解这两者的区别。 假如你想为应用设置很多的常量或参数，这种情况下，XML是一个很好的选择，因为它不会同特定的代码相连。如果你想把某个方法声明为服务，那么使用Annotation会更好一些，因为这种情况下需要注解和方法紧密耦合起来，开发人员也必须认识到这点。 另一个很重要的因素是Annotation定义了一种标准的描述元数据的方式。在这之前，开发人员通常使用他们自己的方式定义元数据。例如，使用标记interfaces，注释，transient关键字等等。每个程序员按照自己的方式定义元数据，而不像Annotation这种标准的方式。 目前，许多框架将XML和Annotation两种方式结合使用，平衡两者之间的利弊。 Annotation是如何工作的？怎么编写自定义的Annotation？编写Annotation非常简单，可以将Annotation的定义同接口的定义进行比较。我们来看两个例子：一个是标准的注解@Override，另一个是用户自定义注解@Todo。 12345@Target(ElementType.METHOD)@Retention(RetentionPolicy.SOURCE)public @interface Override &#123; &#125; 对于@Override注释你可能有些疑问，它什么都没做，那它是如何检查在父类中有一个同名的函数呢。当然，不要惊讶，我是逗你玩的。@Override注解的定义不仅仅只有这么一点代码。这部分内容很重要，我不得不再次重复：Annotations仅仅是元数据，和业务逻辑无关。理解起来有点困难，但就是这样。如果Annotations不包含业务逻辑，那么必须有人来实现这些逻辑。元数据的用户来做这个事情。Annotations仅仅提供它定义的属性(类/方法/包/域)的信息。Annotations的用户(同样是一些代码)来读取这些信息并实现必要的逻辑。 J2SE5.0版本在java.lang.annotation提供了四种元注解，专门注解其他的注解： @Documented：一个简单的Annotations标记注解，表示是否将注解信息添加到Java文档中 @Retenion：定义该注解的生命周期 RetentionPolicy.SOURCE：在编译阶段丢弃。这些注解在编译结束之后就不再有任何意义，所以它们不会写入字节码。@Override, @SuppressWarnings都属于这类注解。 RetentionPolicy.CLASS：在类加载的时候丢弃。在字节码文件的处理中有用。注解默认使用这种方式。 RetentionPolicy.RUNTIME：始终不会丢弃，运行期也保留该注解，因此可以使用反射机制读取该注解的信息。我们自定义的注解通常使用这种方式。 @Target：表示该注解用于什么地方。如果不明确指出，该注解可以放在任何地方。以下是一些可用的参数。需要说明的是：属性的注解是兼容的，如果你想给7个属性都添加注解，仅仅排除一个属性，那么你需要在定义target包含所有的属性。 ElementType.TYPE：用于描述类、接口或enum声明 ElementType.FIELD：用于描述实例变量 ElementType.METHOD ElementType.PARAMETER ElementType.CONSTRUCTOR ElementType.LOCAL_VARIABLE ElementType.ANNOTATION_TYPE： 另一个注释 ElementType.PACKAGE ：用于记录java文件的package信息 ​ @Inherited：定义该注释和子类的关系，可以被子类所继承 那么，注解的内部到底是如何定义的呢？Annotations只支持基本类型、String及枚举类型。注释中所有的属性被定义成方法，并允许提供默认值。 123456789@Target(ElementType.METHOD)@Retention(RetentionPolicy.RUNTIME)@interface Todo &#123; public enum Priority &#123;LOW, MEDIUM, HIGH&#125; public enum Status &#123;STARTED, NOT_STARTED&#125; String author() default \"Yash\"; Priority priority() default Priority.LOW; Status status() default Status.NOT_STARTED;&#125; 下面的例子演示了如何使用上面的注解： 1234@Todo(priority = Todo.Priority.MEDIUM, author = \"Yashwant\", status = Todo.Status.STARTED)public void inCompleteMethod1() &#123; &#125; 如果注解中只有一个属性，可以直接命名为”value”，使用时无需再标明属性名。 1234567@interface Author &#123; String value();&#125;@Author(\"Yashwant\")public void someMethod() &#123; &#125; 到目前为止一切看起来都还不错。我们定义了自己的注解并将其应用在业务逻辑的方法上。现在我们需要写一个用户程序调用我们的注解。这里我们需要使用反射机制。如果你熟悉反射代码，就会知道反射可以提供类名、方法和实例变量对象。所有这些对象都有getAnnotation()这个方法用来返回注解信息。我们需要把这个对象转换为我们自定义的注释(使用instanceOf()检查之后)，同时也可以调用自定义注释里面的方法。看看以下的实例代码，使用了上面的注解： 12345678910Class businessLoginClass = BusinessLogic.class;for (Method method : businessLoginClass.getMethods()) &#123; Todo todoAnnotation = (Todo) method.getAnnotation(Todo.class); if (todoAnnotation != null) &#123; System.out.println(\"Method Name: \" + method.getName()); System.out.println(\"Author: \" + todoAnnotation.author()); System.out.println(\"Priority: \" + todoAnnotation.priority()); System.out.println(\"Status: \" + todoAnnotation.status()); &#125;&#125;","tags":[{"name":"Java 注解","slug":"Java-注解","permalink":"https://glemontree.github.io/tags/Java-注解/"}]},{"title":"[MyBatis] MyBatis第四课---SQL映射文件","date":"2017-09-10T06:27:56.000Z","path":"2017/09/10/[MyBatis] MyBatis第四课---SQL映射文件/","text":"一、增删改查定义接口123456789public interface EmployeeMapper &#123; public Employee getEmpById(Integer id); public void addEmp(Employee employee); public void updateEmp(Employee employee); public void deleteEmpById(Integer id);&#125; 定义SQL映射文件12345678910111213141516171819202122&lt;!-- parameterType：可以省略--&gt;&lt;insert id=\"addEmp\" parameterType=\"com.glemontree.mybatis.bean.Employee\"&gt; insert into tbl_employee(last_name, email, gender) values( #&#123;lastName&#125;, #&#123;email&#125;, #&#123;gender&#125; )&lt;/insert&gt;&lt;update id=\"updateEmp\"&gt; update tbl_employee set last_name = #&#123;lastName&#125;, email = #&#123;email&#125;, gender = #&#123;gender&#125; where id = #&#123;id&#125;&lt;/update&gt;&lt;delete id=\"deleteEmpById\"&gt; delete from tbl_employee where id = #&#123;id&#125;&lt;/delete&gt; 使用#{}的方式从传入的Employee对象中取属性！ 定义测试文件1234567891011121314151617181920212223242526272829@Testpublic void test03() throws IOException &#123; // 获取SqlSessionFactory对象 SqlSessionFactory sqlSessionFactory = getSqlSessionFactory(); // 根据SqlSessionFactory获取SqlSession对象 // openSession()方法不会自动提交，需要自己手动提交 // openSession(true)方法会进行自动提交 SqlSession openSession = sqlSessionFactory.openSession(); // 获取接口的实现类对象 // MyBatis会为接口自动的创建一个代理对象，代理对象去执行增删改查 try &#123; EmployeeMapper mapper = openSession.getMapper(EmployeeMapper.class); // 测试添加 /*Employee employee = new Employee(null, \"jery\", \"jerry@gmail.com\", \"1\"); mapper.addEmp(employee);*/ // 测试修改 /*Employee employee = new Employee(1, \"jerry\", \"jerry@gmail.com\", \"0\"); mapper.updateEmp(employee);*/ // 测试删除 mapper.deleteEmpById(2); // 手动提交数据 openSession.commit(); &#125; finally &#123; openSession.close(); &#125;&#125; 这里需要的是SqlSessionFactory的openSession()方法有两种形式，第一种是不带参数，此时在执行增删改的时候需要手动提交数据，也即上面代码的 1openSession.commit(); 第二种是带参数，该参数的含义是是否自动提交数据，如果设置为true，那么在执行增删改的时候不需要自己再去执行上面这行代码。 另外，MyBatis允许增删改直接定义以下类型的返回值：Integer、Long、Boolean。如果返回值为Boolean，此时在执行增删改的时候如果影响了0行以上，就会返回true，否则返回false。如果返回值为Integer或者Long，那么返回的就是影响了数据库中多少行的数据。 二、insert获取自增主键的值原生的JDBC是支持获取自增主键的值的，使用statement.getGeneratedKeys()方法，MyBatis也支持自增主键，自增主键的获取也是利用statement.getGeneratedKeys()方法，我们需要设置&lt;insert&gt;标签的useGeneratedKeys=&quot;true&quot;属性，表示使用自增主键值获取主键值策略，同时设置&lt;insert&gt;标签的keyProperty属性指定对应的主键属性，也就是MyBatis获取到主键值以后将主键值封装给JavaBean的哪个属性，如下： 123456789101112131415&lt;!-- parameterType：可以省略 MySQL支持自增主键，自增主键的获取，MyBatis也是利用Statement.getGeneratedKeys()方法 useGeneratedKeys=\"true\"：使用自增主键值获取主键值策略 keyProperty=\"\"：指定对应的主键属性，也就是MyBatis获取到主键值以后将主键值封装给JavaBean的哪个属性--&gt;&lt;insert id=\"addEmp\" parameterType=\"com.glemontree.mybatis.bean.Employee\" useGeneratedKeys=\"true\" keyProperty=\"id\"&gt; insert into tbl_employee(last_name, email, gender) values( #&#123;lastName&#125;, #&#123;email&#125;, #&#123;gender&#125; )&lt;/insert&gt; 三、insert Oracle使用序列生成主键Oracle不支持自增，但是Oracle使用序列来模拟自增，每次插入的数据的主键是从序列中取出的值。在Oracle中可以使用下面的语句查看当前用户的序列，last_number表示当前值。 1select * from user_sequences; 因此Oracle在插入数据时首先从序列中查出下一个将要使用的序列的值： 1select EMPLOYEE_SEQ.nextval from dual; 然后再执行插入操作： 1insert into employees(EMPLOYEE_ID, LAST_NAME, EMAIL) values(xxx, 'admin', 'admin@gmail.com'); // xxx表示上一步中使用sql语句获取到的序列中的值 这样在映射文件中可以这样写： 12345678910111213&lt;insert id=\"addEmp\" databaseId=\"oracle\"&gt; &lt;!-- keyProperty表示将查出的主键值封装给JavaBean的哪个属性 order=\"BEFORE\"：当前SQL在插入SQL之前执行 resultType=\"\"：查出的数据的类型 --&gt; &lt;selectKey keyProperty=\"id\" order=\"BEFORE\" resultType=\"Integer\"&gt; &lt;!-- 编写查询主键的sql语句 --&gt; select EMPLOYEE_SEQ.nextval from dual; &lt;/selectKey&gt; &lt;!-- 插入时的主键是从序列中拿到的 --&gt; insert into employees(EMPLOYEE_ID, LAST_NAME, EMAIL) values(#&#123;id&#125;, #&#123;lastName&#125;, #&#123;email&#125;);&lt;/insert&gt; 在上面的这段代码中需要注意，使用&lt;selectKey&gt;标签在插入语句执行之前获取主键值，其keyProperty属性表示将查出的主键值封装给JavaBean的哪个属性，order属性表示当前SQL语句在插入SQL语句之前执行，而resultType属性则表示查出的数据的类型。","tags":[{"name":"MyBatis, SQL映射文件","slug":"MyBatis-SQL映射文件","permalink":"https://glemontree.github.io/tags/MyBatis-SQL映射文件/"}]},{"title":"[MyBatis] MyBatis第三课---全局配置文件","date":"2017-09-09T14:50:44.000Z","path":"2017/09/09/[MyBatis] MyBatis第三课---全局配置文件/","text":"一、&lt;properties&gt;标签引入外部配置文件MyBatis可以使用properties来引入外部properties配置文件的内容，其具有两个属性： resource：引入类路径下的资源 url：引入网络路径或者磁盘路径下的资源 12345678910111213141516171819202122232425262728&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE configuration PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-config.dtd\"&gt;&lt;configuration&gt; &lt;!-- - MyBatis可以使用&lt;properties&gt;标签来引入外部properties配置文件的内容 - resource：引入类路径下的资源 - url：引入网络路径或磁盘路径下的资源 --&gt; &lt;properties resource=\"dbconfig.properties\"&gt;&lt;/properties&gt; &lt;environments default=\"development\"&gt; &lt;environment id=\"development\"&gt; &lt;transactionManager type=\"JDBC\" /&gt; &lt;dataSource type=\"POOLED\"&gt; &lt;property name=\"driver\" value=\"$&#123;jdbc.driver&#125;\" /&gt; &lt;property name=\"url\" value=\"$&#123;jdbc.url&#125;\" /&gt; &lt;property name=\"username\" value=\"$&#123;jdbc.root&#125;\" /&gt; &lt;property name=\"password\" value=\"$&#123;jdbc.password&#125;\" /&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;mappers&gt; &lt;mapper resource=\"EmployeeMapper.xml\" /&gt; &lt;/mappers&gt;&lt;/configuration&gt; 二、&lt;settings&gt;标签运行时行为设置其有很多设置项可以决定运行时的行为，我们看下其中的一个设置项mapUnderscoreToCamelCase，表示是否开启自动驼峰命名规则映射： 123456789101112131415161718192021222324252627282930313233&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE configuration PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-config.dtd\"&gt;&lt;configuration&gt; &lt;!-- - MyBatis可以使用&lt;properties&gt;标签来引入外部properties配置文件的内容 - resource：引入类路径下的资源 - url：引入网络路径或磁盘路径下的资源 --&gt; &lt;properties resource=\"dbconfig.properties\"&gt;&lt;/properties&gt; &lt;!-- settings包含很多重要的设置项 setting：用来设置每一个设置项 name：设置项名 value：设置项取值 --&gt; &lt;settings&gt; &lt;setting name=\"mapUnderscoreToCamelCase\" value=\"true\"/&gt; &lt;/settings&gt; &lt;environments default=\"development\"&gt; &lt;environment id=\"development\"&gt; &lt;transactionManager type=\"JDBC\" /&gt; &lt;dataSource type=\"POOLED\"&gt; &lt;property name=\"driver\" value=\"$&#123;jdbc.driver&#125;\" /&gt; &lt;property name=\"url\" value=\"$&#123;jdbc.url&#125;\" /&gt; &lt;property name=\"username\" value=\"$&#123;jdbc.username&#125;\" /&gt; &lt;property name=\"password\" value=\"$&#123;jdbc.password&#125;\" /&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;mappers&gt; &lt;mapper resource=\"EmployeeMapper.xml\" /&gt; &lt;/mappers&gt;&lt;/configuration&gt; 三、&lt;typeAlias&gt;标签12345&lt;!-- typeAliases：别名处理器，可以为Java类型起别名 --&gt;&lt;typeAliases&gt; &lt;!-- 为某个Java类型起别名 ，type指定要其别名的类型的全类名，默认别名就是类名小写，alias属性可以指定新的别名--&gt; &lt;typeAlias type=\"com.glemontree.mybatis.bean.Employee\"/&gt;&lt;/typeAliases&gt; 可以使用&lt;typeAliases&gt;标签为Java类型起别名，其子标签&lt;typeAlias&gt;用来为某个Java类型起别名，type指定要其别名的类型的全类名，默认别名就是类名小写，alias属性可以指定新的别名。 为了对某个包下的所有类起别名，可以使用批量起别名： 12345678&lt;!-- typeAlias：别名处理器，可以为Java类型起别名，别名不区分大小写 --&gt;&lt;typeAliases&gt; &lt;!-- 为某个Java类型起别名 ，type指定要其别名的类型的全类名，默认别名就是类名小写，alias属性可以指定新的别名--&gt; &lt;!-- &lt;typeAlias type=\"com.glemontree.mybatis.bean.Employee\"/&gt; --&gt; &lt;!-- package标签可以为某个包下的所有类批量起别名，name属性为包名，会为当前包以及当前包的子包都起一个默认别名（类名小写） --&gt; &lt;package name=\"com.glemontree.mybatis.bean\"/&gt;&lt;/typeAliases&gt; 还有一种方式可以为类名起别名，就是使用@Alias注解的方式，在批量起别名的情况下，可以使用@Alias 注解为某个类型指定新的别名，例如： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849package com.glemontree.mybatis.bean;import org.apache.ibatis.type.Alias;@Alias(\"emp\")public class Employee &#123; private Integer id; private String lastName; private String email; private String gender; public Integer getId() &#123; return id; &#125; public void setId(Integer id) &#123; this.id = id; &#125; public String getLastName() &#123; return lastName; &#125; public void setLastName(String lastName) &#123; this.lastName = lastName; &#125; public String getEmail() &#123; return email; &#125; public void setEmail(String email) &#123; this.email = email; &#125; public String getGender() &#123; return gender; &#125; public void setGender(String gender) &#123; this.gender = gender; &#125; @Override public String toString() &#123; return \"Employee [id=\" + id + \", lastName=\" + lastName + \", email=\" + email + \", gender=\" + gender + \"]\"; &#125;&#125; 四、&lt;environments&gt;标签MyBatis可以配置多种环境，其下面可以包含&lt;environment&gt;标签，，用来配置一个具体的环境信息。 &lt;environment&gt;标签必须配置&lt;transactionManager&gt;和&lt;dataSource&gt;两个子标签： &lt;transactionManager&gt;表示事务管理器，其具有一个属性type，表示事务管理器的类型，共有两种取值，为JDBC （JdbcTransactionFactory）| MANAGED（ManagedTransactionFactory），当然也可以自定义事务管理器，通过实现TransactionFactory来实现自定义事务管理器，此时type属性就是全类名。 &lt;dataSource&gt;表示数据源，其具有一个属性type，表示数据源的类型，内置的有三种取值，为UNPOOLED （不使用连接池，UnpooledDataSourceFactory）| POOLED （使用连接池，PooledDataSourceFactory）| JNDI（使用JNDI技术，PooledDataSourceFactory），当然也可以自定义数据源，通过实现DataSource接口即可实现自定义数据源，此时type属性就是全类名。 &lt;environment&gt;标签的id属性代表当前环境的唯一标识，通过&lt;environments&gt;标签的default属性指定某种使用环境，从而可以达到快速切换环境的目的。 1234567891011121314151617181920&lt;environments default=\"development\"&gt; &lt;environment id=\"test\"&gt; &lt;transactionManager type=\"\"&gt;&lt;/transactionManager&gt; &lt;dataSource type=\"\"&gt; &lt;property name=\"driver\" value=\"$&#123;jdbc.driver&#125;\" /&gt; &lt;property name=\"url\" value=\"$&#123;jdbc.url&#125;\" /&gt; &lt;property name=\"username\" value=\"$&#123;jdbc.username&#125;\" /&gt; &lt;property name=\"password\" value=\"$&#123;jdbc.password&#125;\" /&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;environment id=\"development\"&gt; &lt;transactionManager type=\"JDBC\" /&gt; &lt;dataSource type=\"POOLED\"&gt; &lt;property name=\"driver\" value=\"$&#123;jdbc.driver&#125;\" /&gt; &lt;property name=\"url\" value=\"$&#123;jdbc.url&#125;\" /&gt; &lt;property name=\"username\" value=\"$&#123;jdbc.username&#125;\" /&gt; &lt;property name=\"password\" value=\"$&#123;jdbc.password&#125;\" /&gt; &lt;/dataSource&gt; &lt;/environment&gt;&lt;/environments&gt; 五、&lt;databaseIdProvider&gt;标签MyBatis可以根据数据库厂商执行不同的数据库语句，首先需要在全局配置文件中进行下面的配置： 123456789101112&lt;!-- databaseIdProvider：支持多数据库厂商 type=\"DB_VENDOR\"：VendorDatabaseIdProvider 作用是得到数据库厂商的标识，MyBatis就能根据数据库厂商标识来执行不同的SQL MySQL,Oracle,SQL Server...--&gt;&lt;databaseIdProvider type=\"DB_VENDOR\"&gt; &lt;!-- 为不同的数据库厂商起别名 --&gt; &lt;property name=\"MySQL\" value=\"mysql\"/&gt; &lt;property name=\"Oracle\" value=\"oracle\"/&gt; &lt;property name=\"SQL Server\" value=\"sqlserver\"/&gt;&lt;/databaseIdProvider&gt; 然后在SQL映射文件中这样配置： 12345678910111213141516&lt;mapper namespace=\"com.glemontree.mybatis.dao.EmployeeMapper\"&gt;&lt;!-- namespace:名称空间;指定为接口的全类名id：唯一标识resultType：返回值类型#&#123;id&#125;：从传递过来的参数中取出id值public Employee getEmpById(Integer id); --&gt; &lt;select id=\"getEmpById\" resultType=\"emp\" databaseId=\"mysql\"&gt; select * from tbl_employee where id = #&#123;id&#125; &lt;/select&gt; &lt;select id=\"getEmpById\" resultType=\"emp\" databaseId=\"oracle\"&gt; select EMPLOYEE_ID id, LAST_NAME lastName, EMAIL email from employees where EMPLOYEE_ID = #&#123;id&#125; &lt;/select&gt;&lt;/mapper&gt; &lt;select&gt;标签具有一个databaseId属性，用来指定在哪个数据库下执行这个语句，这里我们分别配置了mysql和oracle，当当前数据库环境为mysql时就会执行上面的SQL语句，当当前数据库环境为oracle时就会执行下面的SQL语句。 Oracle在where语句中是不能使用字段别名的，所以这里的where语句不能写成where id = #{id}，而只能用字段名。 六、&lt;mappers&gt;标签将写好的映射文件注册到全局配置文件中，&lt;mappers&gt;标签下的&lt;mapper&gt;子标签就是用来注册SQL映射文件的，其具有以下几个属性： resource：引用类路径下的SQL映射文件 url：引用网络或磁盘路径下的SQL映射文件 class：引用（注册）接口 有SQL映射文件，映射文件名必须和接口同名，并且放在与接口同一目录下 没有SQL映射文件，所有的SQL都是利用注解写在接口上 1234public interface EmployeeMapperAnnotation &#123; @Select(\"select * from tbl_employee where id = #&#123;id&#125;\") public Employee getEmpById(Integer id);&#125; 不要忘记在全局配置文件中进行注册： 123&lt;mappers&gt; &lt;mapper class=\"com.glemontree.mybatis.dao.EmployeeMapperAnnotation\"/&gt;&lt;/mappers&gt; 推荐：比较重要的和复杂的Dao接口写sql映射文件，不重要的和简单的Dao接口为了开发快速可以使用注解。 &lt;mappers&gt;标签下还有一个&lt;package&gt;标签，其可以实现批量注册，但需要注意的是如果是使用SQL映射文件，映射文件名必须与接口同名，并且与接口放在同一目录下。 七、注意点全局配置文件中这些标签的配置是有顺序的，如果顺序不对也会报错，比如我在实验过程中就发现如果将&lt;databaseIdProvider&gt;标签放在&lt;environments&gt;标签的前面就会报错。","tags":[{"name":"MyBatis","slug":"MyBatis","permalink":"https://glemontree.github.io/tags/MyBatis/"}]},{"title":"[MyBatis] MyBatis第二课---接口式编程","date":"2017-09-09T14:12:09.000Z","path":"2017/09/09/[MyBatis] MyBatis第二课---接口式编程/","text":"一、创建接口创建一个接口文件： 1234567package com.glemontree.mybatis.dao;import com.glemontree.mybatis.bean.Employee;public interface EmployeeMapper &#123; public Employee getEmpById(Integer id);&#125; 这个接口可以与SQL映射文件进行动态绑定，此时需要对SQL映射文件进行一些修改，如下： 1234567891011121314151617&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"&gt;&lt;mapper namespace=\"com.glemontree.mybatis.dao.EmployeeMapper\"&gt;&lt;!-- namespace:名称空间;指定为接口的全类名id：唯一标识resultType：返回值类型#&#123;id&#125;：从传递过来的参数中取出id值public Employee getEmpById(Integer id); --&gt; &lt;select id=\"getEmpById\" resultType=\"com.glemontree.mybatis.bean.Employee\"&gt; select * from tbl_employee where id = #&#123;id&#125; &lt;/select&gt;&lt;/mapper&gt; 所进行的修改主要有： 修改namespace为接口的全类名 修改&lt;select&gt;标签的id属性为接口中方法的名字 二、测试测试代码如下： 12345678910111213141516@Testpublic void test01() throws IOException &#123; // 获取SqlSessionFactory对象 SqlSessionFactory sqlSessionFactory = getSqlSessionFactory(); // 根据SqlSessionFactory获取SqlSession对象 SqlSession openSession = sqlSessionFactory.openSession(); // 获取接口的实现类对象 // MyBatis会为接口自动的创建一个代理对象，代理对象去执行增删改查 try &#123; EmployeeMapper mapper = openSession.getMapper(EmployeeMapper.class); Employee employee = mapper.getEmpById(1); System.out.println(employee); &#125; finally &#123; openSession.close(); &#125;&#125;","tags":[{"name":"MyBatis","slug":"MyBatis","permalink":"https://glemontree.github.io/tags/MyBatis/"}]},{"title":"[MyBatis] MyBatis第一课---创建一个HelloWorld","date":"2017-09-09T13:24:00.000Z","path":"2017/09/09/[MyBatis] MyBatis第一课---创建一个HelloWorld/","text":"一、加入Jar包在工程目录下新建lib文件夹，加入下面的Jar包： mybatis-3.4.1.jar mysql-connector-java-5.1.37-bin.jar log4j.jar 其中，第一个为Mybatis的Jar包，第二个是MySQL的Jar包，第三个是日志的Jar包，当然，为了使用日志，还需要在类路径下加入log4j.xml。 在工程目录下新建conf源代码文件夹，加入log4j.xml，到此第一步完成。 二、加入MyBatis的配置文件在类路径下加入MyBatis的配置文件，该配置文件的作用是从这个配置文件中创建SqlSessionFactory，这里我们同样在conf文件夹下加入mybatis-config.xml文件，文件内容如下： 123456789101112131415161718192021&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE configuration PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-config.dtd\"&gt;&lt;configuration&gt; &lt;environments default=\"development\"&gt; &lt;environment id=\"development\"&gt; &lt;transactionManager type=\"JDBC\" /&gt; &lt;dataSource type=\"POOLED\"&gt; &lt;property name=\"driver\" value=\"com.mysql.jdbc.Driver\" /&gt; &lt;property name=\"url\" value=\"jdbc:mysql://localhost:3306/mybatis\" /&gt; &lt;property name=\"username\" value=\"root\" /&gt; &lt;property name=\"password\" value=\"1230\" /&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;!--将我们写好的SQL映射文件注册到全局配置文件中--&gt; &lt;mappers&gt; &lt;mapper resource=\"EmployeeMapper.xml\" /&gt; &lt;/mappers&gt;&lt;/configuration&gt; &lt;dataSource&gt;标签下为数据库的一些配置，包括MySQL的driver、url、username和password。 小技巧：Eclipse下ctrl+shift+F快捷键可以快速格式化代码。 至于&lt;mapper&gt;标签下的内容我们后面再说。 三、根据数据库的内容创建对应的JavaBean我这里在数据库里建立了一个Employee表，其有以下4个字段，分别是： id user_name email gender 我们在Eclipse中建立对应的JavaBean类，如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647package com.glemontree.mybatis.bean;public class Employee &#123; private Integer id; private String lastName; private String email; private String gender; public Integer getId() &#123; return id; &#125; public void setId(Integer id) &#123; this.id = id; &#125; public String getLastName() &#123; return lastName; &#125; public void setLastName(String lastName) &#123; this.lastName = lastName; &#125; public String getEmail() &#123; return email; &#125; public void setEmail(String email) &#123; this.email = email; &#125; public String getGender() &#123; return gender; &#125; public void setGender(String gender) &#123; this.gender = gender; &#125; @Override public String toString() &#123; return \"Employee [id=\" + id + \", lastName=\" + lastName + \", email=\" + email + \", gender=\" + gender + \"]\"; &#125;&#125; 四、创建映射文件在conf目录下创建映射文件，映射文件的内容如下： 1234567891011121314151617&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"&gt;&lt;mapper namespace=\"com.glemontree.mybatis.EmployeeMapper\"&gt;&lt;!-- namespace:名称空间;指定为接口的全类名id：唯一标识resultType：返回值类型#&#123;id&#125;：从传递过来的参数中取出id值public Employee getEmpById(Integer id); --&gt; &lt;select id=\"selectEmp\" resultType=\"com.glemontree.mybatis.bean.Employee\"&gt; select * from tbl_employee where id = #&#123;id&#125; &lt;/select&gt;&lt;/mapper&gt; 此时我们需要更改第二步中MyBatis配置文件下&lt;mapper&gt;标签中的内容，将其改为我们刚刚创建的这个文件。 五、创建测试代码创建Junit单元测试类，如下： 123456789101112131415161718192021222324252627282930package com.glemontree.mybatis.test;import static org.junit.Assert.*;import java.io.IOException;import java.io.InputStream;import org.apache.ibatis.io.Resources;import org.apache.ibatis.session.SqlSessionFactory;import org.apache.ibatis.session.SqlSessionFactoryBuilder;import org.junit.Test;public class MyBatisTest &#123; public SqlSessionFactory getSqlSessionFactory() throws IOException &#123; String resource = \"mybatis-config.xml\"; InputStream inputStream = Resources.getResourceAsStream(resource); SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream); return sqlSessionFactory; &#125; @Test public void test() throws IOException &#123; SqlSessionFactory sqlSessionFactory = getSqlSessionFactory(); SqlSession openSession = sqlSessionFactory.openSession(); // 告诉MyBatis执行EmployeeMapper.xml文件下的id为selectEmp的SQL语句 Employee employee = openSession.selectOne(\"com.glemontree.mybatis.dao.EmployeeMapper.selectEmp\", 1); System.out.println(employee); &#125;&#125; 其主要流程如下： 根据xml配置文件（全局配置文件）创建SqlSessionFactory对象 由SqlSessionFactory创建SqlSession对象，能直接执行已经映射的SQL语句 使用selectOne()方法进行查询，其第一个参数为映射的SQL语句的唯一id标识符，第二个参数为传入的查询参数 六、创建MyBatis工程的步骤 根据xml配置文件（全局配置文件）创建SqlSessionFactory对象，xml配置文件中含有数据源的一些信息 SQL映射文件：配置了每一个SQL，以及SQL的封装规则等 将SQL映射文件注册到全局配置文件中 写代码 根据全局配置文件得到SqlSessionFactory 使用SqlSessionFactory获取到SqlSession对象，使用SqlSession来进行增删改查，一个SqlSession就是代表和数据库的一次对话，用完记得关闭 使用SQL的唯一标识来告诉MyBatis执行哪个SQL，SQL都是保存在SQL映射文件中的。","tags":[{"name":"MyBatis","slug":"MyBatis","permalink":"https://glemontree.github.io/tags/MyBatis/"}]},{"title":"[Redis] Windows安装和配置Redis","date":"2017-09-08T16:10:24.000Z","path":"2017/09/09/[Redis] Windows安装和配置Redis/","text":"最近准备研究一下Redis，今天就先来在Windows系统下安装Redis。 下载Windows版本的RedisRedis的官网没有Windows版本的Redis下载，只能在GitHub上下载，官网只提供Linux版本的下载，下面分别给出官网的下载地址和GitHub的下载地址： 官网下载地址：http://redis.io/download GitHub下载地址：http://github.com/MSOpenTech/redis/tags Redis安装我下载的Redis版本是Redis-x64-3.2.100，WIN+R打开cmd窗口，进入解压后的目录，输入下面的命令： 1redis-server redis.windows.conf 出现下面的界面即表示启动成功了： Redis设置虽然上面成功启动了Redis，但是如果关闭cmd窗口，那么Redis就会消失，所以要把Redis设置成Windows下的服务，执行下面的命令： 1redis-server --service-install redis.windows-service.conf --loglevel verbose 这样设置成功后，WIN+R打开运行界面，输入services.msc查看系统服务，发现Redis已经存在，此时Redis服务并没有打开，需要执行下面的命令： 1redis-server --service-start 当然，如果想停止服务可以执行下面的命令： 1redis-servcer --service-stop 如果想卸载服务，可以执行下面的命令： 1redis-server --service-uninstall 出现下面的界面即表示Redis服务启动成功： 配置Redis环境变量我们每次执行命令都要去Redis的解压路径下去执行，这无疑是很麻烦的，为了解决这个问题，可以将Redis的解压路径加入到系统的环境变量中 现在你可以在任何路径下执行Redis的命令了。 参考资料本文参考自文章Redis在windows下安装过程。","tags":[{"name":"Redis","slug":"Redis","permalink":"https://glemontree.github.io/tags/Redis/"}]},{"title":"[SpringMVC] 今日最坑","date":"2017-09-05T15:07:21.000Z","path":"2017/09/05/[SpringMVC] 今日最坑/","text":"折腾了一晚上，在将一个Eclipse项目转移到IDEA中时，发现&lt;c:if&gt;标签始终不起作用，到最后才发现问题出在了web.xml文件中，IDEA默认创建的web.xml文件是这样的： 123&lt;web-app&gt; &lt;display-name&gt;Archetype Created Web Application&lt;/display-name&gt;&lt;/web-app&gt; 这样将SpringMVC的环境搭建好后，&lt;c:if&gt;标签不起作用，最后发现如下就可以了： 123456&lt;web-app xmlns=\"http://xmlns.jcp.org/xml/ns/javaee\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_3_1.xsd\" version=\"3.1\"&gt; &lt;display-name&gt;Archetype Created Web Application&lt;/display-name&gt;&lt;/web-app&gt;","tags":[{"name":"SpringMVC","slug":"SpringMVC","permalink":"https://glemontree.github.io/tags/SpringMVC/"}]},{"title":"[IntelliJ IDEA] IntelliJ IDEA 源值1.5已过时，将在未来所有版本中删除","date":"2017-09-05T06:06:15.000Z","path":"2017/09/05/[IntelliJ IDEA] IntelliJ IDEA 源值1.5已过时，将在未来所有版本中删除/","text":"本文转载自文章IntelliJ IDEA 源值1.5已过时，将在未来所有版本中删除，解决了运行Tomcat时提示”IntelliJ IDEA 源值1.5已过时，将在未来所有版本中删除”的问题，亲测可行！ 感谢博主的分享！","tags":[{"name":"IDEA","slug":"IDEA","permalink":"https://glemontree.github.io/tags/IDEA/"}]},{"title":"[HTTPS] 一个故事讲完HTTPS","date":"2017-08-31T05:38:44.000Z","path":"2017/08/31/[HTTPS] 一个故事讲完HTTPS/","text":"说在前面本文来自：码农翻身（微信号：coderising），本文是我在Java编程公众号（公众号：JavaCoder1024）上看到的，觉得写得很形象生动因此转载下载做个记录！ 序言今天来聊一聊HTTPS安全传输的原理。 在开始之前，我们来虚构两个人物， 一个是位于中国的张大胖（怎么又是你？！）， 还有一个是位于米国的Bill (怎么还是你？！)。 这俩哥们隔着千山万水，通过网络联系上了， 两个人臭味相投，聊得火热。 此时正值米国大选， 张大胖亲切地“致电”Bill, 对米国总统大选的情况表示强烈地关注。 Bill则回电说谢谢关心米国人的事情我们米国人自己做主，不用你们歪果仁瞎操心…… 张大胖继续“致电”说其实我们支持特朗普， 因为希拉里太情绪化，太难打交道了， 我们挺希望看到特朗普上台这样米国就会变成 The Divided State of America …… Bill 回电： 拉倒你吧你， 我们米国的政体有着强大的纠错性， 虽然有时候发展得慢， 有时候会走上岔路， 但很快就会回到正途，几百年来稳定得很，不像你们像坐了过山车一样….. 两个人越聊越投机，天南地北，海阔天空，还夹杂着不少隐私的话题。 总是有一种被偷看的感觉有一天， Bill 突然意识到： 坏了， 我们的通信是明文的， 这简直就是网络上裸奔啊， 任何一个不怀好意的家伙都可以监听我们通信，打开我们发送的数据包，窥探我们的隐私啊。 张大胖说： “你不早点说，我刚才是不是把我的微信号给你发过去了？ 我是不是告诉你我上周去哪儿旅游了? 估计已经被人截取了吧！” Bill 提议： “要不我们做个数据的加密？ 每次传输之前， 你把消息用一个加密算法加密， 然后发到我这里以后我再解密， 这样别人就无法偷窥了，像这样： ” 张大胖冰雪聪明，一看就明白了， 这加密和解密算法是公开的，那个密钥是保密的， 只有两人才知道， 这样生成的加密消息（密文） 别人就无法得知了。 他说： “Bill 老兄，你生成一个密钥， 然后把密钥发给我， 咱们这就开启加密消息， 让那些偷窥狂人们哭去吧！” （码农翻身注：这叫对称加密算法， 因为加密和解密用的是同一个密钥） 一炷香功夫过去了， Bill 还是没有回音， 张大胖忍不住地催促： “快发啊？！！！” Bill 终于回复了： “ 我感觉有一双眼睛正在虎视眈眈地盯着我们的通话， 如果我把密钥发给你， 也被他截取了， 那加密岂不白费工夫？” 张大胖沉默了， 是啊， 网络是不安全的， 这密钥怎么安全地发过来啊 ？ “奥，对了，我下周要去米国旅游，到时候我们见一面，把密码确定下来，写到纸上，谁也偷不走， 这不就结了？” “哈哈， 这倒是终极解决之道 ” Bill 笑了， “不过，我不仅仅和你聊天， 我还要和易卜拉欣，阿卜杜拉， 弗拉基米尔，克里斯托夫，玛格丽特， 桥本龙太郎， 李贤俊， 许木木，郭芙蓉，吕秀才等人通信， 我总不能打着飞的，满世界的和人交换密码吧？ ” 张大胖心里暗自佩服Bill同学的好友竟然遍布全球，看来他对加密通信的要求更加强烈啊！ 可是这个加密解密算法需要的密钥双方必须得知道啊， 但是密钥又无法通过网络发送， 这该死的偷窥者！ RSA : 非对称加密Bill 和 张大胖的通信无法加密，说话谨慎了不少， 直到有一天， 他们听说了一个叫做RSA的非对称加密算法，一下子来了灵感。 这个RSA算法非常有意思，它不是像之前的算法， 双方必须协商一个保密的密钥， 而是有一对儿钥匙， 一个是保密的，称为私钥，另外一个是公开的，称为公钥。 更有意思的是，用私钥加密的数据，只有对应的公钥才能解密，用公钥加密的数据， 只有对应的私钥才能解密。 有了这两个漂亮的特性， 当张大胖给Bill发消息的时候， 就可以先用Bill的公钥去加密（反正Bill的公钥是公开的，地球人都知道）， 等到消息被Bill 收到后， 他就可以用自己的私钥去解密（只有Bill才能解开，私钥是保密的 ） 反过来也是如此， 当Bill 想给张大胖发消息的时候，就用张大胖的公钥加密， 张大胖收到后，就用自己的私钥解密。 这样以来，通信安全固若金汤， 没有任何人能窥探他们的小秘密了。 非对称加密+对称加密两人实验了几次， 张大胖说： “Bill , 你有没有感觉这个RSA的加密和解密有点慢啊？” Bill叹了口气 ：“是啊， 我也注意到了， 刚才搜了一下，这个RSA算法比之前的对称密钥算法要慢上百倍。我们就是加个密而已，现在搞得都没法用了” “回到咱们最初的问题，我们想用一个密钥来加密通信，那个对称加密算法是非常快的，但是苦于密钥无法安全传输， 现在有了RSA ,我想可以结合一下， 分两步走 (1) 我生成一个对称加密算法的密钥， 用RSA的方式安全发给你， (2) 我们随后就不用RSA了， 只用这个密钥，利用对称加密算法来通信, 如何？ ” Bill 说： “你小子可以啊， 这样以来既解决了密钥的传递问题， 又解决了RSA速度慢的问题，不错。” 于是两人就安全地传递了对称加密的密钥， 用它来加密解密，果然快多了！ 中间人攻击张大胖把和Bill 聊天的情况给老婆汇报了一次。 老婆告诫他说： “你要小心啊， 你确定网络那边坐着的确实是Bill ?” 张大胖着急地辩解说：“肯定是他啊，我都有他的公钥，我们俩的通信都是加密的。” 老婆提醒道：＂假如啊，Bill给你发公钥的时候， 有个中间人，截取了Bill的公钥， 然后把自己的公钥发给了你，冒充Bill ，你发的消息就用中间人的公钥加了密， 那中间人不就可以解密看到消息了？＂ 张大胖背后出汗了，是啊，这个中间人解密以后，还可以用Bill的公钥加密，发给Bill , Bill和我根本都意识不到， 还以为我们在安全传输呢！ 看来问题出现在公钥的分发上！ 虽然这个东西是公开的， 但是在别有用心的人看来，截取以后还可以干坏事 ！ 你到底是谁？但是怎么安全地分发公钥呢？ 似乎又回到了最初的问题： 怎么安全的保护密钥？ 可是似乎和最初的问题还不一样，这一次的公钥不用保密，但是一定得有个办法声明这个公钥确实是Bill的， 而不是别人的。 怎么声明呢？ 张大胖突然想到： 现实中有公证处，它提供的公证材料大家都信任，那在网络世界也可以建立一个这样的具备公信力的认证中心， 这个中心给大家颁发一个证书， 用于证明一个人的身份。 这个证书里除了包含一个人的基本信息之外，还有包括最关键的一环：这个人的公钥！ 这样以来我拿到证书就可以安全地取到公钥了 ！ 完美！ 可是Bill 马上泼了一盆冷水：证书怎么安全传输？ 要是证书传递的过程中被篡改了怎么办？ 张大胖心里不由地咒骂起来： 我操， 这简直就是鸡生蛋，蛋生鸡的问题啊。 天无绝人之路， 张大胖很快就找到了突破口： 数字签名。 简单来讲是这样的， Bill可以把他的公钥和个人信息用一个Hash算法生成一个消息摘要， 这个Hash算法有个极好的特性，只要输入数据有一点点变化，那生成的消息摘要就会有巨变，这样就可以防止别人修改原始内容。 可是作为攻击者的中间人笑了： “虽然我没办法改公钥，但是我可以把整个原始信息都替换了， 生成一个新的消息摘要， 你不还是辨别不出来？” 张大胖说你别得意的太早 ， 我们会让有公信力的认证中心（简称CA）用它的私钥对消息摘要加密，形成签名： 这还不算， 还把原始信息和数据签名合并， 形成一个全新的东西，叫做“数字证书” 张大胖接着说：当Bill把他的证书发给我的时候， 我就用同样的Hash 算法， 再次生成消息摘要，然后用CA的公钥对数字签名解密， 得到CA创建的消息摘要， 两者一比，就知道有没有人篡改了！ 如果没人篡改， 我就可以安全的拿到Bill的公钥喽，有了公钥， 后序的加密工作就可以开始了。 虽然很费劲， 但是为了防范你们这些偷窥者，实在是没办法啊。 中间人恶狠狠地说： “算你小子狠！ 等着吧，我还有别的招。 对了，我且问你， 你这个CA的公钥怎么拿到？ 难道不怕我在你传输ＣＡ公钥的时候发起中间人攻击吗？ 如果我成功的伪装成了ＣＡ，你这一套体系彻底玩完。” 张大胖语塞了，折腾了半天，又回到了公钥安全传输的问题！ 不过转念一想，想解决鸡生蛋，蛋生鸡的问题必须得打破这个怪圈才行，我必须得信任ＣＡ，并且通过安全的的方式获取他们的公钥，这样才能把游戏玩下去。 （注：这些ＣＡ本身也有证书来证明自己的身份，并且ＣＡ的信用是像树一样分级的，高层的ＣＡ给底层的ＣＡ做信用背书，而操作系统／浏览器中会内置一些顶层的ＣＡ的证书，相当于你自动信任了他们。 这些顶层的ＣＡ证书一定得安全地放入操作系统／浏览器当中，否则世界大乱。） HTTPS终于可以介绍HTTPS了，前面已经介绍了HTTPS的原理， 你把张大胖替换成浏览器， 把Bill 替换成某个网站就行了。 一个简化的（例如下图没有包含Pre-Master Secret）HTTPS流程图是这样的， 如果你理解了前面的原理，这张图就变得非常简单： 来自：码农翻身（微信号：coderising）","tags":[{"name":"HTTPS、对称加密、非对称加密","slug":"HTTPS、对称加密、非对称加密","permalink":"https://glemontree.github.io/tags/HTTPS、对称加密、非对称加密/"}]},{"title":"[JQuery] JQuery第八课","date":"2017-08-31T01:49:21.000Z","path":"2017/08/31/[JQuery] JQuery第八课/","text":"说明本文转自菜鸟教程。 JQuery遍历JQuery遍历用于根据相对于其他元素的关系来查找HTML元素，通过JQuery遍历，可以从被选的元素开始，轻松的在家族树中向上移动，向下移动，水平移动，这种移动称为对DOM进行遍历。 JQuery遍历-祖先向上遍历DOM树主要有以下这些方法： parent() parents() parentsUntil() JQuery parent()方法parent()返回被选元素的直接父元素，该方法只会向上一级对DOM树进行遍历，例如： 123456789101112131415161718192021222324252627282930313233343536373839404142&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=\"utf-8\"&gt;&lt;style&gt;.ancestors *&#123; display: block; border: 2px solid lightgrey; color: lightgrey; padding: 5px; margin: 15px;&#125;&lt;/style&gt;&lt;script src=\"https://cdn.bootcss.com/jquery/1.10.2/jquery.min.js\"&gt;&lt;/script&gt;&lt;script&gt;$(document).ready(function()&#123; $(\"span\").parent().css(&#123;\"color\":\"red\",\"border\":\"2px solid red\"&#125;);&#125;);&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=\"ancestors\"&gt; &lt;div style=\"width:500px;\"&gt;div (曾祖父元素) &lt;ul&gt;ul (祖父元素) &lt;li&gt;li (父元素) &lt;span&gt;span&lt;/span&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;div style=\"width:500px;\"&gt;div (祖父元素) &lt;p&gt;p (父元素) &lt;span&gt;span&lt;/span&gt; &lt;/p&gt; &lt;/div&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; JQuery parents()方法parents()方法返回被选元素的所有祖先元素，它一路直到文档的根元素（&lt;html&gt;），举个例子： 123$(document).ready(function()&#123; $(\"span\").parents();&#125;); 当然也可以使用可选参数来过滤祖先元素的搜索，例如： 123$(document).ready(function() &#123; $(\"span\").parents(\"ul\");&#125;); 上面的代码将返回所有&lt;span&gt;元素的所有祖先，并且它是&lt;ul&gt;元素。 JQuery parentsUntil()方法parentUtil()方法返回介于两个给定元素之间的所有祖先元素，例如： 123$(document).ready(function() &#123; $(\"span\").parentsUtil(\"div\");&#125;); 需要注意的是不包含parentsUtil()参数的祖先元素的。 JQuery遍历-后代JQuery children()方法children()方法返回被选元素的所有直接子元素，该方法只会向下一级对DOM树进行遍历，例如： 123$(document).ready(function() &#123; $(\"div\").children();&#125;); 同样地你可以使用可选参数来过滤对子元素的搜索，例如： 123$(document).ready(function() &#123; $(\"div\").children(\"p.1\");&#125;); 上面的代码中将返回类名为”1”的所有p元素，并且它们是&lt;div&gt;的直接子元素。 JQuery find()方法find()方法返回被选元素的后代元素，一路向下直到最后一个后代，例如： 123$(document).ready(function() &#123; $(\"div\").find(\"span\");&#125;); 上面的代码将返回属于&lt;div&gt;后代的所有&lt;span&gt;元素。 123$(document).ready(function()&#123; $(\"div\").find(\"*\");&#125;); 上面的代码将返回属于&lt;div&gt;后代的所有元素。 JQuery遍历-同胞有下面这些方法可以在DOM树进行水平遍历： siblings() next() nextAll() nextUntil() prev() prevAll() prevUntil() JQuery siblings()方法siblings()方法返回被选元素的所有同胞元素，例如： 123$(document).ready(function() &#123; $(\"h2\").siblings();&#125;); 当然也可以使用可选参数对同胞元素进行过滤： 123$(document).ready(function() &#123; $(\"h2\").siblings(\"p\");&#125;); 上面的代码将返回属于&lt;h2&gt;的同胞元素的所有&lt;p&gt;元素。 JQuery next()方法next()方法返回被选元素的下一个同胞元素，该方法只返回一个元素： 123$(document).ready(function() &#123; $(\"h2\").next();&#125;); JQuery nextAll()方法nextAll()返回被选元素的所有跟随的同胞元素： 123$(document).ready(function() &#123; $(\"h2\").nextAll();&#125;); JQuery nextUntil()方法nextUntil()方法返回介于两个给定参数之间的所有跟随的同胞元素： 123$(document).ready(function() &#123; $(\"h2\").nextUntil(\"h6\");&#125;); 另外三个方法不加以介绍，和上面几个方法道理相同。 JQuery遍历-过滤JQuery first()first()返回被选元素的首个元素，例如： 123$(document).ready(function() &#123; $(\"div p\").first();&#125;); 上面的代码选取首个&lt;div&gt;元素内部的第一个&lt;p&gt;元素。 JQuery last()last()方法返回被选元素的最后一个元素： 123$(document).ready(function() &#123; $(\"div p\").last();&#125;); 上面的代码选择最后一个&lt;div&gt;元素中的最后一个&lt;p&gt;元素。 JQuery eq()方法eq()方法返回被选元素中带有指定索引号的元素，索引号从0开始，因此首个元素的索引号是0而不是1： 123$(document).ready(function() &#123; $(\"p\").eq(1);&#125;); 上面的代码选取第二个&lt;p&gt;元素。 JQuery filter()方法filter()返回匹配的元素： 123$(document).ready(function() &#123; $(\"p\").filter(\".url\");&#125;); 上面的代码返回带有类名”url”的所有&lt;p&gt;元素。 JQuery not()方法not()方法返回不匹配标准的所有元素： 123$(document).ready(function() &#123; $(&quot;p&quot;).not(&quot;.url&quot;);&#125;); 上面的代码返回不带有类名”url”的所有&lt;p&gt;元素。","tags":[{"name":"JQuery","slug":"JQuery","permalink":"https://glemontree.github.io/tags/JQuery/"}]},{"title":"[JQuery] JQuery第七课","date":"2017-08-30T09:01:48.000Z","path":"2017/08/30/[JQuery] JQuery第七课/","text":"说明本文转自菜鸟教程。 AJAX简介AJAX是与服务器交换数据的技术，它在不重载全部页面的情况下，实现了对部分网页的更新。AJAX的全称是Asynchronous JavaScript and XML，即异步JavaScript和XML，通过JQuery AJAX方法，您能够使用HTTP Get和HTTP Post从远程服务器上请求文本、HTML、XML或JSON。 AJAX load()方法load()方法从服务器加载数据，并把返回的数据放入被选元素中。其语法如下： 1$(selector).load(URL, data, callback); 其中，必须的URL表示希望加载的URL，可选的data参数规定与请求一同发送的查询字符串键/值对集合，可选的callback参数是load()方法完成后所执行的函数名称。 看下面这个例子： 首先由这样一个文件demo_test.txt： 12&lt;h2&gt;jQuery AJAX 是个非常棒的功能！&lt;/h2&gt;&lt;p id=\"p1\"&gt;这是段落的一些文本。&lt;/p&gt; 通过load()方法将demo_test.txt中的内容加载到指定的元素中： 1$(\"#div1\").load(\"/try/ajax/demo_test.txt\"); 也可以把JQuery选择器添加到URL参数，下面的例子将demo_test.txt文件中id=p1的元素的内容加载到指定的元素： 1$(\"#div1\").load(\"/try/ajax/demo_test.txt #p1\"); 可选的callback参数规定当load()方法完成后所要运行的回调函数，回调函数可以设置不同的参数： responseTxt：包含调用成功时的结果内容 statusTxt：包含调用的状态 xhr：包含XML HttpRequest对象 看下面这个例子： 12345678910$(\"button\").click(function() &#123; $(\"#div1\").load(\"/try/ajax/demo_test.txt\", function(responseTxt, statusTxt, xhr) &#123; if (statusTxt == \"success\") &#123; alert(\"外部内容调用成功\"); &#125; if (statusTxt == \"error\") &#123; alert(\"Error: \" + xhr.status + \": \" + xhr.statusText); &#125; &#125;);&#125;); AJAX get()和post()get()和post()用于通过HTTP GET或POST请求从服务器请求数据。 HTTP请求 GET：从指定的资源请求数据 POST：向指定的资源提交要处理的数据 JQuery $.get()方法$.get()方法通过HTTP GET请求从服务器上请求数据，其语法格式如下： 1$.get(URL, callback); 必须得URL参数规定希望请求的URL，可选的callback参数是请求成功后所执行的函数名，举个例子： 12345$(\"button\").click(function() &#123; $.get(\"demo_test.php\", function(data, status) &#123; alert(\"数据：\" + data + \"\\n状态：\" + status); &#125;);&#125;); $.get()的第一个参数是我们希望请求的URL，第二个参数是回调函数，第一个回调参数存有被请求页面的内容，第二个回调参数存有请求的状态。 JQuery $.post()方法$.post()方法通过HTTP POST请求从服务区上请求数据，其语法如下： 1$.post(URL, data, callback); 必须的URL参数规定您希望请求的URL，可选的data参数规定连同请求发送的数据，可选的callback参数是请求成功后所执行的函数名。举个例子如下： 12345678910$(\"button\").click(function() &#123; $.post(\"/try/ajax/demo_test_post.php\", &#123; name: \"百度\" url: \"www.baidu.com\" &#125;, function(data, status) &#123; alert(\"数据：\\n\" + data + \"\\n状态：\" + status); &#125;);&#125;);","tags":[{"name":"JQuery","slug":"JQuery","permalink":"https://glemontree.github.io/tags/JQuery/"}]},{"title":"[JQuery] JQuery第六课","date":"2017-08-30T07:39:34.000Z","path":"2017/08/30/[JQuery] JQuery第六课/","text":"说明本文转自菜鸟教程。 JQuery获取内容和属性获得内容三个简单实用的用于DOM操作的JQuery方法： text()：设置或返回所选元素的文本内容 html()：设置或返回所选元素的内容（包括HTML标记） val()：设置或返回表单字段的值 例如： 123456$(\"#btn1\").click(function()&#123; alert(\"Text: \" + $(\"#test\").text());&#125;);$(\"#btn2\").click(function()&#123; alert(\"HTML: \" + $(\"#test\").html());&#125;); 下面的例子是通过JQuery的val()方法获得输入字段的值： 123$(\"#btn1\").click(function()&#123; alert(\"值为: \" + $(\"#test\").val());&#125;); 获取属性-attr()JQuery attr()方法用于获取属性值，下面的例子为获得链接中href属性的值： 123$(\"button\").click(function()&#123; alert($(\"#runoob\").attr(\"href\"));&#125;); JQuery设置内容和属性设置内容-text()、html()以及val() text()：设置或返回所选元素的文本内容 html()：设置或返回所选元素的内容（包括HTML标记） val()：设置或返回表单字段的值 例如： 123456789$(\"#btn1\").click(function()&#123; $(\"#test1\").text(\"Hello world!\");&#125;);$(\"#btn2\").click(function()&#123; $(\"#test2\").html(\"&lt;b&gt;Hello world!&lt;/b&gt;\");&#125;);$(\"#btn3\").click(function()&#123; $(\"#test3\").val(\"RUNOOB\");&#125;); text()、html()以及val()的回调函数text()、html()以及val()均拥有回调函数，回调函数有两个参数：被选元素列表当中当前元素的下标以及原始的值，然后以函数新值返回您希望使用的字符串： 12345$(\"#btn1\").click(function() &#123; $(\"#test1\").text(function(i, origText) &#123; return \"旧文本：\" + origText + \" 新文本：Hello World! (index: \" + i + \")\"; &#125;);&#125;); 设置属性-attr()attr()方法用于设置/改变属性值，例如： 123$(\"button\").click(function() &#123; $(\"#runoob\").attr(\"href\", \"http://www.google.com\");&#125;); attr()方法也可以同时设置多个属性，例如： 123456$(\"button\").click(function() &#123; $(\"#runoob\").attr(&#123; \"href\" : \"http:www.google.com\", \"title\": \"JQuery\" &#125;);&#125;); JQuery添加元素append()用于在被选元素的结尾插入内容，例如： 1$(\"p\").append(\"追加\"); prepend()在被选元素的开头插入内容，例如： 1$(\"p\").prepend(\"在开头追加\"); 通过append()和prepend()方法添加若干新元素append()和prepend()方法能够通过参数无限数量的新元素，在下面的例子中，我们创建若干个元素，这些元素可以通过text/HTML、JQuery或者JavaScript/DOM来创建，然后通过append()方法把这些新元素追加到文本中： 12345678function appendText() &#123; var text1 = \"&lt;p&gt;文本。&lt;/p&gt;\"; // 使用HTML标签创建文本 var text2 = $(\"&lt;p&gt;&lt;/p&gt;\").text(\"文本。\"); // 使用JQuery创建文本 var text3 = document.createElement(\"p\"); // 使用DOM创建文本 text3.innerHTML=\"文本\"; $(\"body\").append(text1, text2, text3); // 追加新元素&#125; after()和before()after() 方法在被选元素之后插入内容，before() 方法在被选元素之前插入内容。 12$(\"img\").after(\"在后面添加文本\");$(\"img\").before(\"在前面添加文本\"); 通过after()和before()方法添加若干新元素after()和before()方法能够通过参数无限数量的新元素，在下面的例子中，我们创建若干个元素，这些元素可以通过text/HTML、JQuery或者JavaScript/DOM来创建，然后通过append()方法把这些新元素追加到文本中： 12345678function appendText() &#123; var text1 = \"&lt;b&gt;I &lt;/b&gt;\"; // 使用HTML标签创建文本 var text2 = $(\"&lt;i&gt;&lt;/i&gt;\").text(\"love \"); // 使用JQuery创建文本 var text3 = document.createElement(\"big\"); // 使用DOM创建文本 text3.innerHTML=\"JQuery!\"; $(\"img\").after(text1, text2, text3); // 追加新元素&#125; after()、before()与append()、prepend()之间的区别看下面的例子： append: 123456&lt;p&gt; &lt;span class=\"s1\"&gt;s1&lt;/span&gt;&lt;/p&gt;&lt;script&gt;$(\"p\").append('&lt;span class=\"s2\"&gt;s2&lt;/span&gt;');&lt;/script&gt; 结果如下： 1234&lt;p&gt; &lt;span class=\"s1\"&gt;s1&lt;/span&gt; &lt;span class=\"s2\"&gt;s2&lt;/span&gt;&lt;/p&gt; 而对于after： 123456&lt;p&gt; &lt;span class=\"s1\"&gt;s1&lt;/span&gt;&lt;/p&gt;&lt;script&gt;$(\"p\").after('&lt;span class=\"s2\"&gt;s2&lt;/span&gt;');&lt;/script&gt; 结果如下： 1234&lt;p&gt; &lt;span class=\"s1\"&gt;s1&lt;/span&gt;&lt;/p&gt;&lt;span class=\"s2\"&gt;s2&lt;/span&gt; 可见两者的区别是： append/prepend 是在选择元素内部嵌入。 after/before 是在元素外面追加。 JQuery删除元素如需删除元素和内容，有以下两个方法： remove()：删除被选元素及其子元素 empty()：从被选元素中删除子元素 remove()remove()方法删除被选元素及其子元素： 1$(\"#div1\").remove(); empty()empty()方法删除被选元素的子元素： 1$(\"#div1\").empty(); 过滤被删除的元素remove()方法可以接收一个参数，允许对被删除元素进行过滤，该参数可以是任何JQuery选择器的语法，例如： 1$(\"p\").remove(\".italic\"); 上面的例子用于删除class=”italic”的所有p元素。 JQuery获取并设置CSS类 addClass()：向被选元素添加一个或多个类 removeClass()：从被选元素删除一个或多个类 toggleClass()：对被选元素进行添加/删除类的切换操作 css()：设置或返回样式属性 实例样式表1234567.important &#123; font-weight: bold; font-size: xx-large;&#125;.blue &#123; color: blue;&#125; addClass()1234$(\"button\").click(function() &#123; $(\"h1,h2,p\").addClass(\"blue\"); $(\"div\").addClass(\"important\");&#125;); 在上面的例子中，在添加类时可以同时选取多个元素，当然，也可以在addClass()方法中规定多个类： 123$(\"button\").click(function() &#123; $(\"body div:first\").addClass(\"important blue\");&#125;); removeClass()123$(\"button\").click(function() &#123; $(\"h1,h2,p\").removeClass(\"blue\");&#125;); JQuery css()方法css()方法用于返回或设置被选元素的一个或多个样式属性。 返回CSS属性其语法格式如下： 1css(&quot;propertyname&quot;); 看下面的这个例子： 1$(\"p\").css(\"background-color\"); 设置CSS属性其语法格式如下： 1css(&#123;&quot;propertyname&quot;:&quot;value&quot;, &quot;propertyname&quot;:&quot;value&quot;,...&#125;); 看下面这个例子： 1$(\"p\").css(&#123;\"background-color\":\"yellow\", \"font-size\":\"200%\"&#125;); JQuery尺寸通过JQuery可以很容易处理元素和浏览器窗口的尺寸，其常用方法有： width() height() innerWidth() innerHeight() outerWidth() outerHeight() 看下面这张图： width()和height()width() 方法设置或返回元素的宽度（不包括内边距、边框或外边距），height() 方法设置或返回元素的高度（不包括内边距、边框或外边距）。 12345$(\"button\").click(function() &#123; var text = \"\"; text += \"div的宽度是：\" + $(\"div1\").width() + \"&lt;br/&gt;\"; text += \"div的高度时：\" + $(\"div1\").height();&#125;); innerWidth()和innerHeight()innerWidth() 方法返回元素的宽度（包括内边距），innerHeight() 方法返回元素的高度（包括内边距）。 123456$(\"button\").click(function()&#123; var txt = \"\"; txt += \"div 宽度，包含内边距: \" + $(\"#div1\").innerWidth() + \"&lt;/br&gt;\"; txt += \"div 高度，包含内边距: \" + $(\"#div1\").innerHeight(); $(\"#div1\").html(txt);&#125;); outerWidth()和outerHeight()outerWidth() 方法返回元素的宽度（包括内边距和边框），outerHeight() 方法返回元素的高度（包括内边距和边框）。 123456$(\"button\").click(function()&#123; var txt = \"\"; txt += \"div 宽度，包含内边距和边框: \" + $(\"#div1\").outerWidth() + \"&lt;/br&gt;\"; txt += \"div 高度，包含内边距和边框: \" + $(\"#div1\").outerHeight(); $(\"#div1\").html(txt);&#125;);","tags":[{"name":"JQuery","slug":"JQuery","permalink":"https://glemontree.github.io/tags/JQuery/"}]},{"title":"[SpringMVC] SpringMVC","date":"2017-08-29T13:03:47.000Z","path":"2017/08/29/[SpringMVC] SpringMVC/","text":"RequestMapping注解 SpringMVC使用@RequestMapping注解为控制器指定可以处理哪些URL请求 在控制器的类定义及方法定义处都可标注 类定义处：提供初步的请求映射信息，相对于WEB应用的根目录 方法定义处：提供进一步的细分映射信息，相对于类定义处的URL，若类定义处未标注@RequestMapping，则方法标记处的URL相当于WEB应用的根目录 DispatchServlet截获请求后，就通过控制器上@RequestMapping提供的映射信息确定请求所对应的处理方法。 @RequestMapping除了可以使用请求URL映射请求外，还可以使用请求方法、请求参数及请求头映射请求 @RequestMapping的value、method、params和heads分别表示请求URL、请求方法、请求参数及请求头的映射条件，它们之间是与的关系，联合使用多个条件可以让请求映射更加精确化 params和headers支持简单的表达式： param1：表示请求必须包含名为param1的请求参数 !param1：表示请求不能包含名为param1的请求参数 param1!=value1：表示请求包含名为param1的请求参数，但其值不能为value1 {“param1=value1”, “param2”}：表示请求包含名为param1和param2的两个请求参数，且param1参数的值必须为value1 Ant风格资源地址支持3种匹配符： ?：匹配文件名中的一个字符 *：匹配文件名中的任意字符 **：匹配多层路径 @RequestMapping还支持Ant风格的URL： /user/*/createUser：匹配/user/aaa/createUser、/user/bbb/createUser等URL /user/**/createUser：匹配/user/createUser、/user/aaa/bbb/createUser等URL /user/createUser??：匹配/user/createUseraa、/user/createUserbb等URL @PathVariable注解@PathVariable映射URL绑定的占位符，通过@PathVariable可以将URL中占位符参数绑定到控制器处理方法的入参中：URL中的{xxx}占位符可以通过@PathVariable(&quot;xxx&quot;)绑定到操作方法的入参中。 12345@RequestMapping(\"/testPathVariable/&#123;id&#125;\")public String testPathVariable(@PathVariable(value=\"id\") Integer id) &#123; System.out.println(\"testPathVariable: \" + id); return SUCCESS;&#125; RESTHTTP协议里面，四个操作方式的动词：GET、POST、PUT、DELETE，它们分别对应4种基本操作：GET用来获取资源，POST用来新建资源，PUT用来更新资源，DELETE用来删除资源。 示例： /order/1 HTTP GET：得到id=1的order /order/1 HTTP DELETE：删除id=1的order /order/1 HTTP PUT：更新id=1的order /order HTTP POST：新增order 浏览器form表单只支持GET和POST请求，而DELETE、PUT等method并不支持，Spring添加了一个过滤器HiddenHttpMethodFilter，可以将这些请求转换为标准的http方法，使得支持GET、POST、PUT与DELETE请求。 需在web.xml中配置HiddenHttpMethodFilter，例如： 123456789&lt;!--配置org.springframework.web.filter.HiddenHttpMethodFilter：可以把POST请求转为DELETE或PUT请求--&gt;&lt;filter&gt; &lt;filter-name&gt;hiddenHttpMethodFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.HiddenHttpMethodFilter&lt;/filter-class&gt;&lt;/filter&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;hiddenHttpMethodFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt;&lt;/filter-mapping&gt; 相应的index.jsp如下： 12345678910111213141516&lt;form action=\"testRest/1\" method=\"post\"&gt; &lt;input type=\"hidden\" name=\"_method\" value=\"PUT\"/&gt; &lt;input type=\"submit\" value=\"TestRest PUT\"/&gt;&lt;/form&gt;&lt;br&gt;&lt;br&gt;&lt;form action=\"testRest/1\" method=\"post\"&gt; &lt;input type=\"hidden\" name=\"_method\" value=\"DELETE\"/&gt; &lt;input type=\"submit\" value=\"TestRest DELETE\"/&gt;&lt;/form&gt;&lt;br&gt;&lt;br&gt;&lt;form action=\"testRest\" method=\"post\"&gt; &lt;input type=\"submit\" value=\"TestRest POST\"/&gt;&lt;/form&gt;&lt;br&gt;&lt;br&gt;&lt;a href=\"testRest/1\"&gt;Test Rest GET&lt;/a&gt;&lt;br&gt;&lt;br&gt; 相应的处理器方法如下： 1234567891011121314151617181920212223@RequestMapping(value = \"/testRest/&#123;id&#125;\", method = RequestMethod.PUT)public String testRestPut(@PathVariable(\"id\") Integer id) &#123; System.out.println(\"testRest PUT: \" + id); return SUCCESS;&#125;@RequestMapping(value = \"/testRest/&#123;id&#125;\", method = RequestMethod.DELETE)public String testRestDELETE(@PathVariable(\"id\") Integer id) &#123; System.out.println(\"testRest DELETE: \" + id); return SUCCESS;&#125;@RequestMapping(value = \"/testRest\", method = RequestMethod.POST)public String testRest() &#123; System.out.println(\"testRest POST\"); return SUCCESS;&#125;@RequestMapping(value = \"/testRest/&#123;id&#125;\", method = RequestMethod.GET)public String testRest(@PathVariable(\"id\") Integer id) &#123; System.out.println(\"testRest GET: \" + id); return SUCCESS;&#125; 使用@RequestParam绑定请求参数值在处理方法入参处使用@RequestParam可以把请求参数传递给请求方法，其具有两个属性：value表示参数名，required表示是否必须，默认为true，表示请求参数中必须包含对应的参数，若不存在，将抛出异常！ 12345@RequestMapping(value = \"/testRquestParam\")public String testRquestParam(@RequestParam(value = \"username\") String username, @RequestParam(value = \"age\") Integer age) &#123; System.out.println(\"testRquestParam, username: \" + username + \" age: \" + age); return SUCCESS;&#125; 使用POJO对象绑定请求参数值SpringMVC会按请求参数名和POJO属性名进行自动匹配，自动为该对象填充属性值，支持级联属性！ 12345@RequestMapping(\"/testPojo\")public String testPojo(User user) &#123; System.out.println(\"testPojo: \" + user); return SUCCESS;&#125; 相应的表单文件为： 123456789101112131415&lt;form action=\"testPojo\" method=\"post\"&gt; username: &lt;input type=\"text\" name=\"username\"/&gt; &lt;br&gt; password: &lt;input type=\"password\" name=\"password\"/&gt; &lt;br&gt; email: &lt;input type=\"text\" name=\"email\"/&gt; &lt;br&gt; age: &lt;input type=\"text\" name=\"age\"/&gt; &lt;br&gt; city: &lt;input type=\"text\" name=\"address.city\"/&gt; &lt;br&gt; province: &lt;input type=\"text\" name=\"address.province\"/&gt; &lt;br&gt; &lt;input type=\"submit\" value=\"submit\"/&gt;&lt;/form&gt; 使用Servlet API作为入参MVC的Handler方法可以接收以下这些类型的ServletAPI参数： HttpServletRequest HttpServletResponse HttpSession java.security.Principal Locale InputStream OutputStream Reader Writer 12345@RequestMapping(\"/testServletAPI\")public void testServletAPI(HttpServletRequest request, HttpServletResponse response, Writer out) throws IOException &#123; System.out.println(\"testServletAPI, \" + request + \", \" + response); out.write(\"hello Spinrmvc\");&#125; 处理模型数据SpringMVC提供了以下几种方法输出模型数据： ModelAndView：处理方法返回值类型为ModelAndView，方法体即可通过该对象添加模型数据 Map和Model：入参为Model、ModelMap或Map时，处理方法返回时，Map中的数据会自动添加到模型中 @SessionAttributes：将模型中的某个属性暂存到HttpSession中，以便多个请求之间可以共享这个属性 @ModelAttribute：方法入参标注该注解后，入参的对象就会放到数据模型中 ModelAndView控制器处理方法的返回值如果是ModelAndView，则其既包含视图信息，又包含模型数据信息。 添加模型数据 ModelAndView addObject(String attributeName, Object attributeValue) ModelAndView addAllObject(Map&lt;String, ?&gt; modelMap) 设置视图 void setView(View view) void setViewName(String viewName) 1234567891011/** * 目标方法的返回值可以是ModelAndView类型，其中可以包含视图和模型信息 * SpringMVC会把ModelAndView的model中的数据放到request域对象中 * @return */@RequestMapping(\"/testModelAndView\")public ModelAndView testModelAndView() &#123; ModelAndView modelAndView = new ModelAndView(SUCCESS); modelAndView.addObject(\"time\", new Date()); return modelAndView;&#125; 正如上面注释所述，通过源码分析可知，添加到ModelAndView中的数据最终放到到了request请求域中。 Map以及ModelSpringMVC在内部使用了一个Model接口存储模型数据，具体步骤为： SpringMVC在调用方法前会创建一个隐含的模型对象作为模型数据的存储数据 如果方法的入参为Map或Model类型，SpringMVC会将隐含模型的引用传递给这些入参，在方法体内，开发者可以通过这个入参对象访问到模型中的所有数据，也可以向模型中添加新的属性数据。 12345678910/** * 目标方法可以添加到Map(实际上也可以是Model或ModelMap)类型的参数 * @param map * @return */@RequestMapping(\"/testMap\")public String testMap(Map&lt;String, Object&gt; map) &#123; map.put(\"names\", Arrays.asList(\"Tom\", \"Jerry\", \"Mike\")); return SUCCESS;&#125; @SessionAttributes若希望在多个请求之间共用某个模型属性数据，则可以在控制器类上标注一个@SessionAttributes，SpringMVC将在模型中对应的属性存到HttpSession中。 @SessionAttributes除了可以通过属性名指定需要放到会话中的属性外，还可以通过模型属性的对象类型指定哪些模型属性需要放到会话中。 @SessionAttributes(types=User.class)会将隐含模型中所有类型为User.class的属性添加到会话中 @SessionAttributes(value={&quot;user1&quot;, &quot;user2&quot;}) @SessionAttributes(types={User.class, Dept.class}) @SessionAttributes(value={&quot;user1&quot;, &quot;user2&quot;}, types={Dept.class}) 1234567@RequestMapping(\"/testSessionAttribute\")public String testSessionAttribute(Map&lt;String, Object&gt; map) &#123; User user = new User(\"Tom\", \"123456\", \"tom@gmail.com\", 15); map.put(\"user\", user); map.put(\"school\", \"initialsoft\"); return SUCCESS;&#125; @ModelAttribute先看下面这个例子： 123456789101112131415161718192021222324252627282930313233343536373839404142434445/** * 1. 有@ModelAttribute标记的方法会在每个目标方法执行之前被SpringMVC调用 * 2. @ModelAttribute注解也可以修饰目标方法POJO类型的入参，其value属性值中具有如下作用： * 1) SpringMVC会使用value属性值在implicitModel中查找对应的对象，若存在则会直接传入到目标方法的入参中 * 2）SpringMVC会以value为key，POJO类型的对象为value存入到request中 * @param id * @param map */@ModelAttributepublic void getUser(@RequestParam(value = \"id\", required = false) Integer id, Map&lt;String, Object&gt; map) &#123; if (id != null) &#123; User user = new User(1, \"Tom\", \"123456\", \"tom@gmail.com\", 12); map.put(\"user\", user); System.out.println(\"从数据库中获取一个对象: \" + user); &#125;&#125;/** * 1. 执行@ModelAttribue注解修饰的方法：从数据库中取出对象，将对象放入到了Map中，键为user * 2. SpringMVC从Map中取出User对象，并把表单的请求参数赋给该User对象的对应属性 * 3. SpringMVC把上述对象传入目标方法的参数 * 注意：在ModelAttribute修饰的方法中放入到Map时的键需要和目标方法入参类型的第一个字母小写的字符串一致 * * 源代码分析的流程： * 1. 调用@ModelAttribute注解修饰的方法，实际上把@ModelAttribute修饰的方法中Map中的数据放到implicitModel中 * 2. 解析请求处理器的目标参数，实际上该目标参数来自于WebDataBinder的target属性 * 1）创建WebDataBinder对象： * ①. 确定objectName属性：若传入的attrName属性值为空的话则objectName为类名第一个字母小写 * 注意：attrName，若目标方法的pojo属性使用了@ModelAttribute来修饰，则attrName值即为@ModelAttribute的value属性值 * ②. 确定target属性 * &gt; 在implicitModel中查找attrName对应的属性值，若存在，ok * &gt; 若不存在，则验证当前Hadnler是否使用了@SessionAttributes进行修饰，若使用了@SessionAttributes修饰，则尝试从Session中获取attrName所对应的属性值 * 若Session中没有对应的属性值，则抛出了异常 * &gt; 若Handler没有使用@SessionAttribute进行修饰，或@SessionAttribute中没有attrName键则通过反射创建了pojo对象 * 2） SpringMVC把表单的请求参数赋给了WebDataBinder的target对应的属性 * 3） SpringMVC会把WebDataBinder的attrName和target给到implicitModel * 4） 把WebDataBinder的target作为参数传递给目标方法的入参 * @param user * @return */@RequestMapping(\"/testModelAttribute\")public String testModelAttribute(User user) &#123; System.out.println(\"修改： \" + user); return SUCCESS;&#125; SpringMVC确定目标方法POJO类型入参的过程 确定一个key 若目标方法的POJO类型的参数木有使用@ModelAttribute作为修饰，则key为POJO类名第一个字母小写 若使用了@ModelAttribute来修饰，则key为@ModelAttribute注解的value属性值 在implicitModel中查找key对应的对象，若存在，则作为入参传入 若在@ModelAttribute标记的方法中在Map中保存过且key和第一步中确定的key一致则会获取到 若不存在key对应的对象则检查当前的Handler是否使用@SessionAttributes注解进行修饰，若使用了该注解，且@SessionAttributes注解的value属性值中包含了key则会从HttpSession中来获取key所对应的value值，若存在则直接传入到目标方法的入参中，若不存在则将抛出异常 若Handler没有标识@SessionAttributes注解或@SessionAttributes注解的value值中不包含key，则会通过反射来创建POJO类型的参数，然后传入为目标方法的参数 SpringMVC会把key和POJO类型的对象保存到implicitModel中进而会保存到request中 视图和视图解析器 无论目标方法返回时String、ModelAndView或者View，SpringMVC都会转换成ModelAndView对象 SpringMVC借助视图解析器（ViewResolver）得到最终的视图对象（View），最终的视图可以是JSP，也可能是Excel、JFreeChart等各种表现形式的视图 若项目中使用了JSTL，则SpringMVC会自动把视图由InternalResourceView转为JstlView 若使用JSTL的fmt标签则需要在SpringMVC的配置文件中配置国际化资源文件 123&lt;bean id=\"messageSource\" class=\"org.springframework.context.support.ResourceBundleMessageSource\"&gt; &lt;property name=\"basename\" value=\"i18n\"&gt;&lt;/property&gt;&lt;/bean&gt; 若希望直接响应通过SpringMVC渲染的页面，不需要经过Handler，可以使用mvc:view-controller标签实现 1&lt;mvc:view-controller path=\"testJstlView\" view-name=\"success\"/&gt; 但是这样配置之后，原来的那些需要经过Handler的链接就将失效，实际上在实际开发中通常需要配置mvc:annotation-driven：&lt;mvc:annotation-driven/&gt;，此时即可解决问题。 自定义视图自定义视图需要实现View接口，并且需要在Spring的配置文件中配置BeanNameViewResolver，如下： HelloView 123456789101112@Componentpublic class HelloView implements View &#123; @Override public String getContentType() &#123; return \"text/html\"; &#125; @Override public void render(Map&lt;String, ?&gt; model, HttpServletRequest request, HttpServletResponse response) throws Exception &#123; response.getWriter().print(\"hello view, time: \" + new Date()); &#125;&#125; HelloView实现View接口，需要实现两个接口，HelloView需要加上@Component注解从而注入到IOC容器中，这是因为BeanNameViewResolver需要从IOC容器中获取该View。 配置文件的配置 12345&lt;!--配置视图解析器BeanNameViewResolver，使用视图的名字来解析视图--&gt;&lt;!--通过order属性来定义视图解析器的优先级，order值越小，优先级越高--&gt;&lt;bean class=\"org.springframework.web.servlet.view.BeanNameViewResolver\"&gt; &lt;property name=\"order\" value=\"100\"/&gt;&lt;/bean&gt; 测试 12345@RequestMapping(\"/testView\")public String testView() &#123; System.out.println(\"testView\"); return \"helloView\";&#125; 需要注意的是testView()的返回值必须返回&quot;helloView&quot;，这是因为HelloView在IOC容器的ID为helloView，而BeanNameViewResolver正是通过testView()方法的返回值在IOC容器中查找自定义View的。 关于重定向 一般情况下控制器方法的返回字符串类型的值会被当成逻辑视图名处理 如果返回的字符串中带forward:或redirect:前缀时，SpringMVC会对他们进行特殊处理，将forward:和redirect:当成指示符，其后的字符串作为URL来处理。 redirect:success.jsp：会完成一个到success.jsp的重定向的操作 forward:success.jsp：会完成一个到success.jsp的转发操作 数据绑定 SpringMVC主框架将ServletRequest对象即目标方法的入参实例传递给WebDataBinderFactory实例，以创建DataBinder实例对象 DataBinder调用装配在SpringMVC上下文的ConversionService组件进行数据类型转换、数据格式化工作，将Servlet中的请求信息填充到入参对象中 调用Validator组件对已经绑定了请求消息的入参对象进行数据合法性校验，并最终生成数据绑定结果BingingData对象 SpringMVC抽取BindingResult中的入参对象和校验错误对象，将它们赋给处理方法的响应入参 SpringMVC通过反射机制对目标处理方法进行解析，将请求消息绑定到处理方法的入参中，数据绑定的核心是DataBinder，运行机制如下： 自定义类型转换器ConversionService是Spring类型转换体系的核心接口，可以利用ConversionServiceFactoryBean在Spring的IOC容器中定义一个ConversionService，Spring将自动识别出IOC容器中的ConversionService，并在Bean属性配置及SpringMVC处理方法入参绑定等场合使用它进行数据的转换。 可通过ConversionServiceFactoryBean的converters属性注册自定义的类型转换器。 Spring定义了3种类型的转换器接口，实现任意一个转换器接口都可以作为自定义转换器注册到ConversionServiceFactoryBean中： Converter&lt;S,T&gt;：将S类型对象转为T类型对象 ConverterFactory：将相同系列多个同质的Converter封装在一起，如果希望将一种类型的对象转换为另一种类型及其子类型的对象（例如将String转换为Number及Number子类）可使用转换器工厂类 GenericConverter：会根据源类对象及目标类对象所在的宿主类中的上下文信息进行类型转换 &lt;mvc:annotation-driven conversion-service=&quot;conversionService&quot;/&gt;会将自定义的ConversionService注册到SpringMVC的上下文中，例如： 12345678&lt;mvc:annotation-driven converson-service=\"conversionService\"/&gt;&lt;bean id=\"conversionService\" class=\"org.springframework.context.support.ConversionServiceFactoryBean\"&gt; &lt;property name=\"converters\"&gt; &lt;list&gt; &lt;bean class=\"\"com.glemontree.springmvc.converters.UserConverter&gt;&lt;/bean&gt; &lt;/list&gt; &lt;/property&gt;&lt;/bean&gt; annotation-driven配置有下面几种情况需要使用annotation-driven： 使用&lt;mvc:view-controller/&gt;配置直接转发的页面，无需经过Handler方法 使用&lt;mvc:default-servlet-handler/&gt;配置访问静态资源文件 在使用自定义类型转换器时使用&lt;mvc:annotation-driven/&gt;的conversion-service属性 在开发过程中通常需要加入该配置。 &lt;mvc:annotation-driven/&gt;会自动注册RequestMappingHandlerMapping、RequestMappingHandlerAdapter以及ExceptionHandlerExceptionResoler三个bean，还提供以下支持： 支持使用ConversionService实例对表单参数进行类型转换 支持使用@NumberFormatannotaion、@DateTimeFormat注解完成数据类型的格式化 支持使用@Valid注解对JavaBean实例进行JSR 303验证 支持使用@ResponseBody和@RequestBody注解 @InitBinder 由@InitBinder标识的方法，可以对WebDataBinder对象进行初始化，WebDataBinder是DataBinder的子类，用于完成由表单字段到JavaBean属性的绑定。 @InitBinder方法不能有返回值，它必须声明为void @InitBinder方法的参数值通常是WebDataBinder 例如： 12345// 不能自动绑定对象中的roleSet属性，另行处理@InitBinderpublic void initBinder(WebDataBinder dataBinder) &#123; dataBinder.setDisallowedFields(\"roleSet\");&#125; 数据的格式化现在有这样一种情况，在Bean中有一个Date类型的对象，此时在表单中提交数据时会报错，因为SpringMVC无法知道你需要将什么样的数据转换为Date类型，此时需要在Bean的目标属性上面通过@DateTimeFormat注解声明日期的格式，例如： 12@DateTimeFormat(pattern=\"yyyy-MM-dd\")private Date birth; 这个的前提是需要在SpringMVC的配置文件中配置： 1&lt;mvc:annotation-driven/&gt; 另外一种情况，假设Bean中有一个float类型的属性： 1private float salary; 现在在表单中输入1,234,567.8，此时也会出错，所以此时也需要在目标属性上加注解： 123// 用#表示数值@NumberFormat(pattern=\"#,###,###.#\")private float salary; Spring在格式化模块中定义了一个实现ConversionService接口的FormattingConversionService实现类，该实现类扩展了GenericConversionService，因此它既具有类型转换的功能，又具有格式化的功能。 FormattingConversionService拥有一个FormattingConversionServiceFactoryBean工厂类，后者用于在Spring上下文中构造前者。 FormattingConversionServiceFactoryBean内部已经注册了： NumberFormatAnnotationFormatterFactory：支持对数字类型的属性使用@NumberFormat注解 JodaDateTimeFormatAnnotationFormatterFactory：支持对日期类型的属性@DateTimeFormat注解 装配了FormattingConversionServiceFactoryBean后，就可以在Spring MVC入参绑定及模型数据输出时使用注解驱动了。 &lt;mvc:annotation-driven/&gt;默认创建的ConversionService实例即为FormattingConversionServiceFactoryBean。 数据校验 JSR 303是Java为Bean数据合法性校验提供的标准框架，它已经包含在JavaEE6.0中 JSR 303通过在Bean属性上标注类似于@NotNull、@Max等标准的注解指定校验规则，并通过标准的验证接口对Bean进行验证。 Hibernate Validator是JSR 303的一个参考实现，除支持所有标准的校验注解外，它还支持以下的扩展注解： @Email 被注解的元素必须是电子邮件地址 @Length 被注解的字符串的大小必须在指定的范围内 @NotEmpty 被注解的字符串必须非空 @Range 被注解的元素必须在合适的范围内 Spring4.0拥有自己的数据校验框架，同时支持JSR 303标准的校验框架 Spring在进行数据绑定时，可同时调用校验框架完成数据校验工作，在SpringMVC中，可直接通过注解驱动的方式进行数据校验 Spring的LocalValidatorFactoryBean既实现了Spring的Validator接口，也实现了JSR 303的Validator接口，只要在Spring容器里定义一个LocalValidatorFactoryBean，即可将其注入到需要数据校验的Bean中 Spring本身并没有提供JSR 303的实现，所以需要将JSR 303的实现者的JAR包放在类路径下。 &lt;mvc:annotation-driven&gt;会默认装配一个LocalValidatorFactoryBean，通过在处理方法的入参上标注@valid注解即可让SpringMVC在完成数据绑定后进行数据的校验 SpringMVC是通过对处理方法签名的规则来保存校验结果的：前一个表单/命令对象的校验结果保存在随后的入参中，这个保存校验结果的入参必须是BindingResult或Errors类型。 整个校验的流程如下： 使用JSR 303验证标准 加入hibernate validator验证框架的Jar包 在SpringMVC配置文件中加入&lt;mvc:annotation-driven/&gt; 需要在bean的属性上添加对应的注解 在目标方法bean类型的前面添加@Valid注解 错误消息 显示错误消息 在jsp中通过&lt;form:errors/&gt;标签进行错误消息的显示，该标签有一个属性path，若设置为*，则显示所有的错误消息。 当然我们可以将错误消息分别显示在对应字段的后面，此时在对应字段的后面加上&lt;form:errors/&gt;标签，其path属性写上对应字段的名字就可以了，例如： 12LastName: &lt;form:input path=\"lastName\"/&gt;&lt;form-errors path=\"lastName\"&gt;&lt;/form-errors&gt; 定制错误消息 每个属性在数据绑定和数据校验发生错误时都会生成一个对应的FieldError对象。 当一个属性校验失败后，校验框架会为该属性生成4和消息代码，这些代码以校验注解类名为前缀，结合modelAttribute、属性名和属性类型名生成多个对应的消息代码，例如User类中的password属性标注了一个@Pattern注解，当该属性不满足@Pattern所定义的规则时，就会产生下面4个消息代码： Pattern.user.password Pattern.password Pattern.java.lang.String Pattern 当使用SpringMVC标签显示错误消息时，SpringMVC会查看WEB上下文是否装配了对应的国际化消息，如果没有，则显示默认的错误消息，否则使用国际化消息。 ​ ​","tags":[{"name":"SpringMVC","slug":"SpringMVC","permalink":"https://glemontree.github.io/tags/SpringMVC/"}]},{"title":"[JQuery] JQuery第五课","date":"2017-08-29T12:16:59.000Z","path":"2017/08/29/[JQuery] JQuery第五课/","text":"说明本文转自菜鸟教程。 JQuery动画JQuery animate()方法用于创建自定义动画，其语法如下： 1$(selector).animate(&#123;params&#125;, speed, callback); 必须的params参数定义形成动画的CSS属性，可选的 speed 参数规定效果的时长。它可以取以下值：”slow”、”fast” 或毫秒，可选的 callback 参数是动画完成后所执行的函数名称，例如： 123$(\"button\").click(function() &#123; $(\"div\").animate(&#123;left: '250px'&#125;);&#125;); 默认情况下，所有HTML元素都有一个静态位置，且无法移动，如需对位置进行操作，要记得首先将元素的CSS position属性设置为relative、fixed或absolute。 JQuery animate()操作多个属性生成动画的同时可同时使用多个属性： 12345678$(\"button\").click(function() &#123; $(\"div\").animate(&#123; left: '250px', opacity: '0.5', height: '150px', width: '150px' &#125;);&#125;); animate()方法基本上可以操作所有CSS属性，不过需要注意的是当使用animate()方法时，必须使用驼峰标记法书写所有的属性名，比如必须使用paddingLeft而不是padding-left等。 JQuery animate() 使用相对值animate()也可以使用相对值，需要在值的前面加上+=或-=，例如： 1234567$(\"button\").click(function() &#123; $(\"div\").animate(&#123; left: '250px', height: '+=150px', width: '+=150px' &#125;);&#125;); JQuery animate() 使用预定义的值您可以把属性的值设置为”show”、”hide()”或”toggle”，例如： 12345$(\"button\").click(function() &#123; $(\"div\").animate(&#123; height: 'toggle' &#125;);&#125;); JQuery animate() 使用队列功能JQuery提供指针动画的队列功能，这意味着可以编写多个animate()调用，JQuery会包含这些方法调用的内部队列，然后逐一运行这些animate调用，例如： 1234567$(\"button\").click(function() &#123; var div = $(\"div\"); div.animate(&#123;height:'300px', opacity:'0.4'&#125;, \"slow\"); div.animate(&#123;width:'300px', opacity:'0.8'&#125;, \"slow\"); div.animate(&#123;height:'100px', opacity:'0.4'&#125;, \"slow\"); div.animate(&#123;height:'100px', opacity:'0.8'&#125;, \"slow\");&#125;) JQuery stop()方法 停止动画JQuery stop()方法用于停止动画，在它们完成之前。stop()方法适用于所有JQuery效果函数，包括滑动、淡入淡出和自定义动画，其语法如下： 1$(selctor).stop(stopAll, goToEnd); 可选的 stopAll 参数规定是否应该清除动画队列。默认是 false，即仅停止活动的动画，允许任何排入队列的动画向后执行。可选的 goToEnd 参数规定是否立即完成当前动画。默认是 false。因此，默认地，stop() 会清除在被选元素上指定的当前动画。 JQuery Callback()方法Callback函数在当前动画100%完成之后执行，例如： 12345$(\"button\").click(function() &#123; $(\"p\").hide(\"slow\", function() &#123; alert(\"段落现在被隐藏了\"); &#125;);&#125;); JQuery 链（Chaining）通过JQuery，可以将动作/方法链接在一起，Chaining允许我们在一条语句中运行多个JQuery方法（在相同的元素上）。 举个例子，下面的例子将css()、slideUp()和slideDown()链接在一起： 1$(\"#p1\").css(\"color\", \"red\").slideUp(2000).slideDown(2000);","tags":[{"name":"JQuery","slug":"JQuery","permalink":"https://glemontree.github.io/tags/JQuery/"}]},{"title":"[JQuery] JQuery第四课","date":"2017-08-29T12:11:20.000Z","path":"2017/08/29/[JQuery] JQuery第四课/","text":"说明本文转自菜鸟教程。 JQuery滑动方法通过JQuery，您可以在元素上创建滑动效果，JQuery拥有以下滑动方法： slideDown() slideUp() slideToggle() JQuery slideDown()方法用于向下滑动元素，其语法如下： 1$(selector).slideDown(speed, callback); 可选的 speed 参数规定效果的时长，它可以取以下值：”slow”、”fast” 或毫秒，可选的 callback 参数是滑动完成后所执行的函数名称。例如： 123$(\"#flip\").click(function() &#123; $(\"#panel\").slideDown();&#125;); JQuery slideUp()方法用于向下滑动元素，其语法如下： 1$(selector).slideUp(speed, callback); 可选的 speed 参数规定效果的时长，它可以取以下值：”slow”、”fast” 或毫秒，可选的 callback 参数是滑动完成后所执行的函数名称。例如： 123$(\"#flip\").click(function() &#123; $(\"#panel\").slideUp();&#125;); JQuery slideToggle()方法jQuery slideToggle() 方法可以在 slideDown() 与 slideUp() 方法之间进行切换。如果元素向下滑动，则 slideToggle() 可向上滑动它们；如果元素向上滑动，则 slideToggle() 可向下滑动它们。 1$(selector).slideToggle(speed, callback); 可选的 speed 参数规定效果的时长，它可以取以下值：”slow”、”fast” 或毫秒，可选的 callback 参数是滑动完成后所执行的函数名称。例如： 123$(\"#flip\").click(function() &#123; $(\"#panel\").slideToggle();&#125;);","tags":[{"name":"JQuery","slug":"JQuery","permalink":"https://glemontree.github.io/tags/JQuery/"}]},{"title":"[JQuery] JQuery第三课","date":"2017-08-29T11:59:17.000Z","path":"2017/08/29/[JQuery] JQuery第三课/","text":"说明本文转自菜鸟教程。 JQuery Fading方法通过JQuery，您可以实现元素的淡入淡出效果，JQuery拥有以下四种方法： fadeIn() fadeOut() fadeToggle() fadeTo() JQuery fadeIn()方法JQuery fadeIn()方法用于淡入已隐藏的元素，语法如下： 1$(selector).fadeIn(speed, callback); 可选的speed参数规定效果的时长，可以取以下值：”slow”、”fast”或毫秒，可选的callback参数是fading完成后所执行的函数的名称，例如： 12345$(\"button\").click(function() &#123; $(\"#div1\").fadeIn(); $(\"#div2\").fadeIn(\"slow\"); $(\"#div3\").fadeIn(3000);&#125;); JQuery fadeOut()方法JQuery fadeOut()方法用于淡出可见的元素，语法如下： 1$(selector).fadeOut(speed, callback); 可选的speed参数规定效果的时长，可以取以下值：”slow”、”fast”或毫秒，可选的callback参数是fading完成后所执行的函数的名称，例如： 12345$(\"button\").click(function() &#123; $(\"#div1\").fadeOut(); $(\"#div2\").fadeOut(\"slow\"); $(\"#div3\").fadeOut(3000);&#125;); JQuery fadeToggle()方法jQuery fadeToggle() 方法可以在 fadeIn() 与 fadeOut() 方法之间进行切换。如果元素已淡出，则 fadeToggle() 会向元素添加淡入效果；如果元素已淡入，则 fadeToggle() 会向元素添加淡出效果。 其语法如下： 1$(selctor).fadeToggle(speed, callback); 可选的speed参数规定效果的时长，可以取以下值：”slow”、”fast”或毫秒，可选的callback参数是fading完成后所执行的函数的名称，例如： 12345$(\"button\").click(function() &#123; $(\"#div1\").fadeToggle(); $(\"#div2\").fadeToggle(\"slow\"); $(\"#div3\").fadeToggle(3000);&#125;); JQuery fadeTo()方法JQuery fadeTo()方法允许渐变为给定的不透明度（值介于0~1之间），其语法如下： 1$(selector).fadeTo(speed, opacity, callback); 必须的speed参数规定效果的时长，它可以取以下值：”slow”、”fast”或毫秒，必须的opacity参数将淡入淡出效果设定为给定的不透明度，可选的callback参数是该函数完成后所执行的函数名称，例如： 12345$(\"button\").click(function() &#123; $(\"#div1\").fadeTo(\"slow\", 0.15); $(\"#div2\").fadeTo(\"slow\", 0.4); $(\"#div3\").fadeTo(\"slow\", 0.7);&#125;);","tags":[{"name":"JQuery","slug":"JQuery","permalink":"https://glemontree.github.io/tags/JQuery/"}]},{"title":"[JQuery] JQuery第二课","date":"2017-08-29T11:48:23.000Z","path":"2017/08/29/[JQuery] JQuery第二课/","text":"说明本文转自菜鸟教程。 JQuery hide()和show()通过JQuery，可以通过hide()和show()方法来隐藏和显示HTML元素，例如： 1234567$(\"#hide\").click(function() &#123; $(\"p\").hide();&#125;);$(\"#show\").click(function() &#123; $(\"p\").show();&#125;); 语法如下： 12$(selector).hide(speed, callback);$(selector).show(speed, callback); 可选的speed参数规定隐藏/显示的速度，可以取以下值：”slow”、”fast”或毫秒。可选的callback参数是隐藏或显示完成后所执行的函数名称，例如： 123$(\"button\").click(function() &#123; $(\"p\").hide(100);&#125;); JQuery toggle()通过JQuery，您可以使用toggle()方法来切换hide()和show()方法，例如： 123$(\"button\").click(function() &#123; $(\"p\").toggle();&#125;); 其语法如下： 1$(selector).toggle(speed, callback); 可选的speed参数规定显示/隐藏的速度，可以取以下值：”slow”、”fast”或毫秒，可选的callback参数是隐藏或显示完成后所执行的函数名称。 对于可选的callback参数，需要注意： $(selector)选中的元素的个数为n个，则callback函数会执行n次； callback函数名后加括号，会立即执行函数体，而不是等到显示/隐藏完成后才执行； callback既可以是函数名，也可以是匿名函数。","tags":[{"name":"JQuery","slug":"JQuery","permalink":"https://glemontree.github.io/tags/JQuery/"}]},{"title":"[JQuery] JQuery第一课","date":"2017-08-29T08:24:19.000Z","path":"2017/08/29/[JQuery] JQuery第一课/","text":"说明本文转自菜鸟教程。 什么是JQueryJQuery是一个JavaScript函数库，其包含以下功能： HTML元素选取 HTML元素操作 CSS操作 HTML事件函数 JavaScript特效与动画 HTML DOM遍历和修改 AJAX Utilities JQuery安装可以通过多种方法在网页中添加JQuery： 从jquery.com下载JQuery库 从CDN中载入JQuery，如从Google中加载JQuery JQuery库是一个JavaScript文件，可以使用HTML的&lt;script&gt;标签引用它： 123&lt;head&gt;&lt;script src=\"jquery-1.10.2.min.js\"&gt;&lt;/script&gt;&lt;/head&gt; 将下载的文件放在网页的同一目录下就可以使用JQuery，注意，在HTML5中，不必在&lt;script&gt;标签中使用type=&quot;text/javascript&quot;，因为JavaScript是HTML5以及所有现代浏览器中的默认脚本语言。 如果你不希望下载并存放JQuery，那么可以使用CDN（内容分发网络）引用它，例如： 1234&lt;!--菜鸟教程CDN--&gt;&lt;head&gt; &lt;script src=\"http://cdn.static.runoob.com/libs/jquery/1.10.2/jquery.min.js\"&gt;&lt;/script&gt;&lt;/head&gt; 1234&lt;!--百度CDN--&gt;&lt;head&gt;&lt;script src=\"https://apps.bdimg.com/libs/jquery/2.1.4/jquery.min.js\"&gt;&lt;/script&gt;&lt;/head&gt; 1234&lt;!--又拍云CDN--&gt;&lt;head&gt;&lt;script src=\"http://upcdn.b0.upaiyun.com/libs/jquery/jquery-2.0.2.min.js\"&gt;&lt;/script&gt;&lt;/head&gt; 1234&lt;!--新浪CDN--&gt;&lt;head&gt;&lt;script src=\"http://lib.sinaapp.com/js/jquery/2.0.2/jquery-2.0.2.min.js\"&gt;&lt;/script&gt;&lt;/head&gt; 1234&lt;!--谷歌CDN--&gt;&lt;head&gt;&lt;script src=\"http://ajax.googleapis.com/ajax/libs/jquery/1.10.2/jquery.min.js\"&gt;&lt;/script&gt;&lt;/head&gt; 1234&lt;!--微软CDN--&gt;&lt;head&gt;&lt;script src=\"http://ajax.htmlnetcdn.com/ajax/jQuery/jquery-1.10.2.min.js\"&gt;&lt;/script&gt;&lt;/head&gt; JQuery语法基本语法JQuery语法是通过选取HTML元素，并对选取的元素执行某些操作，基础语法如下： $(selector).action() 美元符号定义JQuery 选择符（selector）查询和查找HTML元素 JQuery的action()指定对元素的操作 举例如下： $(this).hide()：隐藏当前元素 $(&quot;p&quot;).hide()：隐藏所有&lt;p&gt;元素 $(&quot;p.test&quot;).hide()：隐藏所有class=&quot;test&quot;的&lt;p&gt;元素 $(&quot;#test&quot;).hide()：隐藏所有id=&quot;test&quot;的元素 文档就绪事件123$(document).read(function() &#123; &#125;); 这是为了防止文档在完全加载（就绪）之前运行JQuery代码，即在DOM加载完成之后才可以对DOM进行操作。 简洁写法如下： 123$(function() &#123; &#125;); JQuery选择器JQuery选择器允许您对HTML元素组或某个元素进行操作，JQuery选择器基于元素的id、类、类型、属性、属性值等查找（或选择）HTML元素，JQuery中所有选择器都以美元符号开头：$()。 元素选择器JQuery元素选择器基于元素名选取元素，例如在页面上选取所有&lt;p&gt;元素： 1$(&quot;p&quot;) 又比如下面这个例子： 12345$(function() &#123; $(\"button\").click(function() &#123; $(\"p\").hide(); &#125;);&#125;); #id选择器JQuery #id选择器通过HTML元素的id属性选取指定的元素，页面中元素的id应该是唯一的，其语法如下： 1$(&quot;#test&quot;) 又比如下面这个例子： 12345$(function() &#123; $(\"button\").click(function() &#123; $(\"#test\").hide(); &#125;);&#125;); .class选择器JQuery 类选择器可以通过指定的class查找元素，语法如下： 1$(&quot;.test&quot;) 又比如下面这个例子： 12345$(function() &#123; $(\"button\").click(function() &#123; $(\".test\").hide(); &#125;);&#125;); 用户点击按钮后所有带有class=&quot;test&quot;属性的元素都隐藏。 更多实例 语法 描述 $(“*”) 选取所有元素 $(this) 选取当前HTML元素 $(“p.intro”) 选取class为intro的&lt;p&gt;元素 $(“p:first”) 选取第一个&lt;p&gt;元素 $(“ul li:first”) 选取第一个 &lt;ul&gt;元素的第一个 &lt;li&gt;元素 $(“ul li:first-child”) 选取每个 &lt;ul&gt;元素的第一个 &lt;li&gt;元素 $(“[href]”) 选取带有 href 属性的元素 $(“a[target=’_blank’]”) 选取所有 target 属性值等于 “_blank” 的 &lt;a&gt; 元素 $(“a[target!=’_blank’]”) 选取所有 target 属性值不等于 “_blank” 的&lt;a&gt;元素 $(“:button”) 选取所有 type=”button” 的&lt;input&gt;元素 和 &lt;button&gt; 元素 $(“tr:even”) 选取偶数位置的&lt;tr&gt;元素 $(“tr:odd”) 选取奇数位置的&lt;tr&gt;元素 独立文件中使用JQuery函数可以将JQuery函数放到独立的.js文件中，通过src属性来引用文件，使得页面更加的清晰，例如： 1234&lt;head&gt;&lt;script src=\"http://cdn.static.runoob.com/libs/jquery/1.10.2/jquery.min.js\"&gt;&lt;/script&gt;&lt;script src=\"my_jquery_functions.js\"&gt;&lt;/script&gt;&lt;/head&gt; JQuery事件常见的DOM事件 鼠标事件 键盘事件 表单事件 文档/窗口事件 click keypress submit load keydown change resize keyup focus scroll blur unload 常用的JQuery事件方法 $(document).ready() 允许我们在文档完全加载完后执行函数 click() 当按钮点击事件触发时调用函数 dbclick() 当双击元素时发生dbclick事件 mouseenter() 当鼠标指针穿过元素时会发生moouseenter事件 mouseleave() 当鼠标指针离开元素时会发生mouseleave事件 mousedown() 当鼠标指针移动到元素上方，并按下鼠标按键时，会发生mousedown事件 mouseup() 当在元素上松开鼠标指针时会发生mouseup事件 hover() 用于模拟光标悬停事件，当鼠标移动到元素上时，会触发指定的第一个函数（mouseenter），当鼠标移出这个元素时会触发指定的第二个函数（mouseleave）： 12345678$(\"#p1\").hover(function() &#123; function() &#123; alert(\"你进入了p1!\"); &#125;, function() &#123; alert(\"拜拜，现在你离开了p1!\"); &#125;&#125;); focus() 当元素获得焦点时发生focus事件，当通过鼠标点击选中元素或通过tab键定位到元素时，该元素就会获得焦点。 blur() 当元素失去焦点，发生blur事件。","tags":[{"name":"JQuery","slug":"JQuery","permalink":"https://glemontree.github.io/tags/JQuery/"}]},{"title":"[Android] Android绘制文本基本概念之- top, bottom, ascent, descent, baseline","date":"2017-08-19T14:25:30.000Z","path":"2017/08/19/[Android] Android绘制文本基本概念之- top, bottom, ascent, descent, baseline/","text":"介绍通过一个图来了解一下这些概念： baseline是基线，在Android中绘制文本都是从baseline处开始的，从baseline往上至至文本最高处的距离称之为ascent(上坡度)，baseline至文本最低处的距离称之为descent(下坡度)。top和bottom是绘制文本时在最外层留出的一些内边距。baseline是基线，baseline以上是负值，baseline以下是正值，因此ascent和top都是负值，descent和bottom都是正值。 文本的实际高度应该就是descent-asscent,但是一般都是以top-bottom作为文本的高度。ascent，descent，top，bottom都是文本内容的属性，也即字内容的属性，这些属性都是FontMetrics这个类中的属性，FontMetrics对象可以通过Paint画笔对象mPaint.getFontMetrics()方法来获取，但是要是在paint.setTextSize(mTextSize)之后获取。获取到Paint的FontMetrics对象之后，就可以获取到ascent,descent,top,bottom这些属性值了。 android中绘制文本：drawText(String text, float x, float y,Paint paint)这里的x参数是绘制的文本的最左边的横坐标，y是baseline的纵坐标，注意这里的y不是绘制文本的纵坐标,而是baseline的纵坐标。 我们经常地一个需求就是在View的中心处绘制文本，那么以前看到网上看到最多的在View的中心处绘制文本的公式：x=控件的宽度/2-文本的宽度/2y=控件的高度/2+文本的高度/2都是把y当作是绘制文本的纵坐标，其实这是不正确的，这种公式绘制出的文本并不是居中的。因为y参数并不是绘制文本的纵坐标，而是baseline的纵坐标。那么这里根据上面的ascent,descent,top,bottom概念的学习，给出在View中心处绘制文的x，y值的计算公式：x=getWidth()/2-mPaint.measureText(mText)/2;y=getHeight()/2+(fontMetrics.bottom-fontMetrics.top)/2-fontMetrics.bottom getWidth(): 控件的宽度(view的宽度)getHeight()：控件的高度(view的高度)mPaint.measureText(mText)是精确的测出绘制文本的宽度 。fontMetrics.bottom-fontMetrics.top就是绘制文本的高度。y计算出来就是baseline的纵坐标。 总结本文转载自Android绘制文本基本概念之- top, bottom, ascent, descent, baseline，这里我只有一点需要说明一下： 关于y=getHeight()/2+(fontMetrics.bottom-fontMetrics.top)/2-fontMetrics.bottom获取到的是文本在View中心位置的纵坐标。 这是因为(fontMetrics.bottom-fontMetrics.top) / 2获取到的是文本的高度 / 2，根据文中的图片，文本的高度 / 2 - fontMetrics.bottom获取到的就是baseline距离文本中间的距离。","tags":[{"name":"Android, 绘制文本","slug":"Android-绘制文本","permalink":"https://glemontree.github.io/tags/Android-绘制文本/"}]},{"title":"[Android] Android制作自己的依赖库让别人引用(2)","date":"2017-08-19T06:12:59.000Z","path":"2017/08/19/[Android] Android制作自己的依赖库让别人引用(2)/","text":"制作自己的依赖库的第二种方法上一篇文章中我们介绍了制作自己的依赖库的第一种方法，出于好奇心，今天尝试了下第二种方法，也踩了一些坑，所以在这边做个笔记记录一下。 所谓的第二种方法就是将库发布到jCenter，下面我们具体看下步骤！ 将库发布到jCenter的步骤准备要发布的library这一步直接跳过，不清楚的请上网查询或者查看上一篇文章！ 注册账号jCenter属于bintray旗下的一个仓库，所以先要注册账号：https://bintray.com，这里说下第一个坑。 一开始我点击上图的START YOUR FREE TRIAL按钮进行了注册，结果尼玛只能在组织里创建maven仓库，导致我上传library到jCenter一直失败，后来网上查了一下，发现应该点击右侧的For an Open Source Account，这回总算可以在自己的账号里创建maven仓库了，参考的链接为http://blog.csdn.net/tmac2000/article/details/53261141。 创建maven仓库注册成功并登录之后，点击页面上的Add New Repository，创建maven仓库： 创建packagemaven仓库创建成功之后，在maven仓库中创建一个package，注意package的名字和要发布的library的名字相同。 配置项目的build.gradle文件在项目的build.gradle中添加bintray-release的classpath：classpath &#39;com.novoda:bintray-release:0.3.4，如下： 1234567891011121314151617181920212223// Top-level build file where you can add configuration options common to all sub-projects/modules.buildscript &#123; repositories &#123; jcenter() &#125; dependencies &#123; classpath &apos;com.android.tools.build:gradle:2.3.3&apos; classpath &apos;com.novoda:bintray-release:0.3.4&apos; // NOTE: Do not place your application dependencies here; they belong // in the individual module build.gradle files &#125;&#125;allprojects &#123; repositories &#123; jcenter() &#125;&#125;task clean(type: Delete) &#123; delete rootProject.buildDir&#125; 配置library的build.gradle文件12345678910111213141516171819202122232425262728293031323334353637383940414243444546apply plugin: &apos;com.android.library&apos;apply plugin: &apos;com.novoda.bintray-release&apos;android &#123; compileSdkVersion 26 buildToolsVersion &quot;26.0.1&quot; defaultConfig &#123; minSdkVersion 15 targetSdkVersion 26 versionCode 1 versionName &quot;1.0&quot; testInstrumentationRunner &quot;android.support.test.runner.AndroidJUnitRunner&quot; &#125; buildTypes &#123; release &#123; minifyEnabled false proguardFiles getDefaultProguardFile(&apos;proguard-android.txt&apos;), &apos;proguard-rules.pro&apos; &#125; &#125; lintOptions &#123; abortOnError false &#125;&#125;dependencies &#123; compile fileTree(dir: &apos;libs&apos;, include: [&apos;*.jar&apos;]) androidTestCompile(&apos;com.android.support.test.espresso:espresso-core:2.2.2&apos;, &#123; exclude group: &apos;com.android.support&apos;, module: &apos;support-annotations&apos; &#125;) compile &apos;com.android.support:appcompat-v7:26.+&apos; testCompile &apos;junit:junit:4.12&apos;&#125;//新添加publish &#123; userOrg = &apos;glemontree&apos; //在https://bintray.com上注册的用户名 groupId = &apos;com.glemontree&apos; //jCenter上的路径 artifactId = &apos;PasswordView&apos; //要上传的library名称 publishVersion = &apos;1.0.0&apos; //library的版本号 desc = &apos;A PasswordView library&apos; //library的简单描述 website = &apos;https://github.com/Glemontree/PasswordView&apos; //library的开源地址，例如在github上的地址&#125; 在AS的Terminal中执行命令在Android Studio中的Terminal中执行如下命令：gradlew clean build bintrayUpload -PbintrayUser=BINTRAY_USERNAME -PbintrayKey=BINTRAY_KEY -PdryRun=false，其中PbintrayUser代表注册的用户名，PbintrayKey表示API Key，PdryRun是一个配置参数，当为true的时候，会运行所有的环节，但是不会上传，如下图： 当然API Key你可以在下面的页面中找到： 直接点击图中最左侧的API Key即可查看到。 不出意外的话等待几分钟即可上传成功。 当然这个过程中可能还会出现另外一个坑，如果你不在要上传的library的build.gradle文件的android标签里添加如下代码： 123lintOptions &#123; abortOnError false&#125; 那么你可能会遇到错误：Lint found errors in the project; aborting build.。 上传成功上传成功后就可以在maven仓库中看到我们的library，如下： 点击library的名字后则可以查看详情： 此时我们还不能在项目中引用该库，要将其添加到jCenter，点击上图右下角的Add to JCenter按钮即可，等待数小时审核通过后会邮件通知你的，之后就可以在项目中引用了： 总结本文参考自文章Android 发布开源库到 JitPack、jCenter，有兴趣的可以直接去Othershe的博客进行查看。","tags":[{"name":"Android, 依赖库制作","slug":"Android-依赖库制作","permalink":"https://glemontree.github.io/tags/Android-依赖库制作/"}]},{"title":"[Android] Android制作自己的依赖库让别人引用(1)","date":"2017-08-17T11:56:26.000Z","path":"2017/08/17/[Android] Android制作自己的依赖库让别人引用(1)/","text":"什么是依赖库我们在Android开发过程中不可避免的需要引用别人造的轮子，在Android Studio中往往只需要一行代码就可以引用别人的库文件，如下图： 羡慕吧，那我们怎么将自己的库让别人引用呢？其实有两种方法，大家可以参考Android如何制作自己的依赖库上传至github供别人下载使用 这篇文章，我这里只介绍第一种方法，结合我自己的实践，顺便做个笔记，以后不用每次都去网上找了！ 依赖库制作过程新建普通工程这里我新建一个CircleView过程，如下： 新建Module然后点击File—&gt;New—&gt;New Module菜单栏创建一个Module，创建完成后工程结构如下： 修改Module目录下的build.gradle文件写好代码后，修改Module目录下的build.gradle文件，如下： 切记，不然会帮错：Error:Dependency Puddings:videosdk1218:unspecified on project app resolves to an APK。 上传到GitHub选择菜单项VCS—&gt;Import into Version Control—&gt;Share Project on GitHub，上传工程到GitHub 我这里已经上传过了所以会出现仓库已经存在的提示！ 发布自己的项目在GitHub上找到刚刚的仓库，选择release标签： 填写相关信息： 然后点击Publish release标签即可发布项目。 登录JitPack.io在浏览器中输入https://jitpack.io/，然后在Loop up输入框中输入仓库的地址，比如我的：https://github.com/Glemontree/CircleView： 点击get it即可，然后网页上会自动弹出怎么使用该库： 此时你就可以在项目中使用这个库了。","tags":[{"name":"Android, 依赖库制作","slug":"Android-依赖库制作","permalink":"https://glemontree.github.io/tags/Android-依赖库制作/"}]},{"title":"[Android] Android自定义View修炼之路(2)","date":"2017-08-15T12:40:38.000Z","path":"2017/08/15/[Android] Android自定义View修炼之路(2)/","text":"前言上一篇文章中介绍了自定义View的基本流程，今天我们仍然跟随洋神脚步学习自定义View，本篇文章参考自洋神的 Android 自定义View (三) 圆环交替 等待效果一文，有兴趣的可以去洋神的博客看看哈！ 举例自定义View流程回顾上一篇文章中介绍了下自定义View的流程，在本篇文章中我们仍然将这4个步骤列出来加深印象： 自定义View的属性 在View的构造方法中获得自定义的属性 重写onMeasure 重写onDraw 下面我们按照这4个步骤一步步完成我们的自定义View。 自定义View的属性在工程目录下的res/values子目录下建立一个attrs.xml文件，在里面定义我们需要的属性： 12345678910111213&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;resources&gt; &lt;attr name=\"firstColor\" format=\"color\"/&gt; &lt;attr name=\"secondColor\" format=\"color\"/&gt; &lt;attr name=\"circleWidth\" format=\"dimension\"/&gt; &lt;attr name=\"speed\" format=\"integer\"/&gt; &lt;declare-styleable name=\"CustomView\"&gt; &lt;attr name=\"firstColor\"/&gt; &lt;attr name=\"secondColor\"/&gt; &lt;attr name=\"circleWidth\"/&gt; &lt;attr name=\"speed\"/&gt; &lt;/declare-styleable&gt;&lt;/resources&gt; 如上面这段代码，我们定义了4个属性，分别是第一个圆环的颜色、第二个圆环的颜色、圆环的宽度以及圆环更新的速度，然后我们就可以在layout布局文件中这样使用我们的自定义View及自定义属性： 1234567891011121314&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;RelativeLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:app=\"http://schemas.android.com/apk/res-auto\" xmlns:tools=\"http://schemas.android.com/tools\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" tools:context=\"com.glemontree.customview04.MainActivity\"&gt; &lt;com.glemontree.customview04.CustomView android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:layout_centerInParent=\"true\"/&gt;&lt;/RelativeLayout&gt; 这里我没有添加自定义属性，全都使用的默认属性，如果你有兴趣，可以在layout布局文件中的CustomView子结点下添加app:xxx=&quot;xxx&quot;来使用自定义属性。 在View的构造方法中获取自定义属性紧接着我们可以在自定义View的构造方法中获取自定义的属性，如下： 1234567891011121314151617181920212223242526272829303132333435363738public CustomView(Context context, @Nullable AttributeSet attrs, int defStyleAttr) &#123; super(context, attrs, defStyleAttr); TypedArray a = context.obtainStyledAttributes(attrs, R.styleable.CustomView, defStyleAttr, 0); mFirstColor = a.getColor(R.styleable.CustomView_firstColor, Color.GREEN); mSecondColor = a.getColor(R.styleable.CustomView_secondColor, Color.RED); mCircleWidth = a.getDimensionPixelOffset(R.styleable.CustomView_circleWidth, (int) TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_DIP, 20, getResources().getDisplayMetrics())); mSpeed = a.getInt(R.styleable.CustomView_speed, 20); a.recycle(); mPaint = new Paint(); // 开启线程更新进度并刷新界面 new Thread() &#123; public void run() &#123; while (true) &#123; mProgress++; if (mProgress == 360) &#123; mProgress = 0; if (!mIsNext) &#123; mIsNext = true; &#125; else &#123; mIsNext = false; &#125; &#125; // 刷新界面 postInvalidate(); // Thread.sleep()函数需要使用try-catch语句进行包围 try &#123; Thread.sleep(mSpeed); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125;.start();&#125; 在View的构造方法中我们分别获取了我们自定义的4个属性，并且设置了默认值，这样即使在layout布局文件中不设置这4个自定义属性，仍然可以保证有值。 在构造方法中还开启了一个线程，这个线程主要的目的就是更新mProgress并且刷新界面，mProgress每增加1，就刷新界面一次，刷新界面是通过postInvalidate()方法来实现的。 因为这里并不需要onMeasure()操作，因此省去onMeasure()的实现，我们直接看onDraw()函数。 重写onDrawonDraw()函数的内容如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950@Overrideprotected void onDraw(Canvas canvas) &#123; // 获得中心点 int centre = getWidth() / 2; // 获得半径 int radius = centre - mCircleWidth / 2; // 设置空心线宽 mPaint.setStrokeWidth(mCircleWidth); // 抗锯齿 mPaint.setAntiAlias(true); // 只绘制图形轮廓（描边） mPaint.setStyle(Paint.Style.STROKE); // 指定圆弧的外轮廓矩形区域 RectF oval = new RectF(centre - radius, centre - radius, centre + radius, centre + radius); if (!mIsNext) &#123; // 设置圆环的颜色 mPaint.setColor(mFirstColor); // 画出圆环 canvas.drawCircle(centre, centre, radius, mPaint); // 设置圆弧的颜色 mPaint.setColor(mSecondColor); // 根据进度画圆弧 canvas.drawArc(oval, -90, mProgress, false, mPaint); &#125; else &#123; // 设置圆环的颜色 mPaint.setColor(mSecondColor); // 画出圆环 canvas.drawCircle(centre, centre, radius, mPaint); // 设置圆弧的颜色 mPaint.setColor(mFirstColor); // 根据进度画圆弧 canvas.drawArc(oval, -90, mProgress, false, mPaint); &#125; // canvas.drawRect(oval, mPaint);&#125; 其实也没啥特别要说的，就是绘制圆环和圆弧，下面我想介绍下drawArc()函数。 `drawArc()函数的原型如下： 1public void drawArc(RectF oval, float startAngle, float sweepAngle, boolean useCenter, Paint paint) 其各个参数的含义如下： oval：指定圆弧的外轮廓矩形区域 startAngle：圆弧起始角度，单位为度 sweepAngle：圆弧扫过的角度，顺时针方向，单位为度 useCenter：当为true时，在绘制圆弧时将圆心包括在内，通常用来绘制扇形 paint：绘制圆弧的画笔 第一个参数oval我纠结了蛮久，一直没搞懂是什么意思，其实呢，就是圆弧的外切圆，比如在我们的程序中： 1RectF oval = new RectF(centre - radius, centre - radius, centre + radius, centre + radius); 绘制的矩形正好是圆弧的外切矩形，在上面这段程序中你可以取消最后一行的注释，查看绘制的矩形到底是什么样的。 总结其实我是想上一张动图的，但是尼玛使用GifCam录制动图得到的动图总是颜色凌乱，还没搞懂，等我搞懂了搞张图上来。","tags":[{"name":"Android, 自定义View","slug":"Android-自定义View","permalink":"https://glemontree.github.io/tags/Android-自定义View/"}]},{"title":"[Android] Android自定义View修炼之路(1)","date":"2017-08-11T06:29:43.000Z","path":"2017/08/11/[Android] Android自定义View修炼之路(1)/","text":"前言尼玛一直觉得自定义View好难，但是呢自定义View在Android开发过程中又是无法逃避的坎，一个App我觉得除了数据外，就属外观了，漂亮的界面总是让人心旷神怡。每每看到别人做的酷炫的控件都好羡慕，想知道他们是怎么实现的，相信很多初学者都有和我一样的苦恼。但是呢，学习是一个不断积累的过程，不能指望着一步登天，所以还是需要先打好基础，一步一步来，下面让我们跟着大神一步步学习自定义View吧（ps：我不是大神==，我也只是个菜鸟，我说的大神是洋神， 我也只是跟着他的步骤将他博客里的案例做一下，顺便做些自己的笔记）。 今天是第一课，是阅读洋神的 Android 自定义View (一) 文章做的笔记。 自定义View的步骤一般来说，自定义View需要有以下四个步骤，视实际的情况某些步骤可有可无： 自定义View的属性 在View的构造方法中获得自定义的属性 重写onMeasure 重写onDraw 自定义View的属性通常来说，我们在做自定义View的时候，都需要自定义View的属性，比如字体的大小、字体的颜色等等属性，我们希望可以像Android内置的控件一样可以在XML文件中配置这些属性，这时候就需要自定义View的属性，自定义View的属性需要在工程目录下的res/values子目录下建立一个attr.xml文件，在里面定义我们需要的属性，比如： 123456789101112&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;resources&gt; &lt;attr name=\"titleText\" format=\"string\"&gt;&lt;/attr&gt; &lt;attr name=\"titleTextColor\" format=\"color\"&gt;&lt;/attr&gt; &lt;attr name=\"titleTextSize\" format=\"dimension\"&gt;&lt;/attr&gt; &lt;declare-styleable name=\"CustomeTitleTextView\"&gt; &lt;attr name=\"titleText\"/&gt; &lt;attr name=\"titleTextColor\"/&gt; &lt;attr name=\"titleTextSize\"/&gt; &lt;/declare-styleable&gt;&lt;/resources&gt; 在这里我们定义了三个属性，分时是titleText、titleTextColor以及titleTextSize，其实还有另外一种写法如下，两者的效果是一样的： 12345678&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;resources&gt; &lt;declare-styleable name=\"CustomeTitleTextView\"&gt; &lt;attr name=\"titleText\" format=\"string\"/&gt; &lt;attr name=\"titleTextColor\" format=\"color\"/&gt; &lt;attr name=\"titleTextSize\" format=\"dimension\"/&gt; &lt;/declare-styleable&gt;&lt;/resources&gt; 相信大家也看到了，我们在声明属性时有一个format属性，format其实是该属性的取值类型，一共有string、color、dimension、integer、enum、reference、float、boolean、fraction、flag： string：取值类型为字符串 color：取值类型为颜色值，比如app:color=&quot;#ffffff&quot; dimension：取值类型为尺寸值，比如app:dimension=&quot;30dp&quot; integer：取值类型为整数，比如app:count=&quot;12&quot; enum：取值类型为枚举，比如 123456&lt;declare-styleable name=&quot;名称&quot;&gt; &lt;attr name=&quot;属性名称&quot;&gt; &lt;enum name=&quot;horizontal&quot; value=&quot;0&quot;/&gt; &lt;enum name=&quot;vertical&quot; value=&quot;1&quot;/&gt; &lt;/attr&gt;&lt;/declare-styleable&gt; 那么在xml文件中就可以这样使用： 1app:属性名称=&quot;horizontal&quot; reference：取值类型为某一资源ID，比如app:background=&quot;@drawable/picture&quot; float：取值类型为浮点数，比如app:fromAlpha=&quot;0.1&quot; boolean：取值类型为布尔值，比如app:focusable=true fraction：取值类型为百分数，比如app:pivotX=&quot;200%&quot; flag：取值类型为位或运算，比如 1234567891011121314 &lt;declare-styleable name=&quot;名称&quot;&gt; &lt;attr name=&quot;windowSoftInputMode&quot;&gt; &lt;flag name = &quot;stateUnspecified&quot; value = &quot;0&quot; /&gt; &lt;flag name = &quot;stateUnchanged&quot; value = &quot;1&quot; /&gt; &lt;flag name = &quot;stateHidden&quot; value = &quot;2&quot; /&gt; &lt;flag name = &quot;stateAlwaysHidden&quot; value = &quot;3&quot; /&gt; &lt;flag name = &quot;stateVisible&quot; value = &quot;4&quot; /&gt; &lt;flag name = &quot;stateAlwaysVisible&quot; value = &quot;5&quot; /&gt; &lt;flag name = &quot;adjustUnspecified&quot; value = &quot;0x00&quot; /&gt; &lt;flag name = &quot;adjustResize&quot; value = &quot;0x10&quot; /&gt; &lt;flag name = &quot;adjustPan&quot; value = &quot;0x20&quot; /&gt; &lt;flag name = &quot;adjustNothing&quot; value = &quot;0x30&quot; /&gt; &lt;/attr&gt; &lt;/declare-styleable&gt; 那么就可以这样使用： 123456789&lt;activity android:name = &quot;.StyleAndThemeActivity&quot; android:label = &quot;@string/app_name&quot; android:windowSoftInputMode = &quot;stateUnspecified | stateUnchanged | stateHidden&quot;&gt; &lt;intent-filter&gt; &lt;action android:name = &quot;android.intent.action.MAIN&quot; /&gt; &lt;category android:name = &quot;android.intent.category.LAUNCHER&quot; /&gt; &lt;/intent-filter&gt;&lt;/activity&gt; 接下来我们就可以在布局文件中声明我们的自定义View： 123456789101112131415&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;RelativeLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:app=\"http://schemas.android.com/apk/res-auto\" xmlns:tools=\"http://schemas.android.com/tools\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" tools:context=\"com.glemontree.customview01.MainActivity\"&gt; &lt;com.glemontree.customview01.CustomView android:layout_width=\"200dp\" android:layout_height=\"100dp\" app:titleText=\"3712\" app:titleTextSize=\"40sp\" app:titleTextColor=\"#ff0000\"/&gt;&lt;/RelativeLayout&gt; 你会发现，在使用自定义属性的时候有个前缀app，其实这个不是必须得是app，但是必须得和布局文件开始处xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;中的xmlns后面的名称相同。 在View的构造方法中获得自定义的属性接下来，我们就需要在我们自定义View的构造方法中获得自定义属性，代码实现如下： 1234567891011121314151617181920212223242526272829303132333435363738public CustomView(Context context) &#123; this(context, null);&#125;public CustomView(Context context, AttributeSet attrs) &#123; this(context, attrs, 0);&#125;public CustomView(Context context, AttributeSet attrs, int defStyle) &#123; super(context, attrs, defStyle); TypedArray a = context.obtainStyledAttributes(attrs, R.styleable.CustomeTitleTextView, defStyle, 0); int n = a.getIndexCount(); for (int i = 0; i &lt; n; i++) &#123; int attr = a.getIndex(i); switch (attr) &#123; case R.styleable.CustomeTitleTextView_titleText: mTitleText = a.getString(attr); break; case R.styleable.CustomeTitleTextView_titleTextColor: // 默认颜色设置为黑色 mTitleTextColor = a.getColor(attr, Color.BLACK); break; case R.styleable.CustomeTitleTextView_titleTextSize: // 默认设置为16sp，TypeValue也可以把sp转化为px mTitleTextSize = a.getDimensionPixelSize(attr, (int) TypedValue.applyDimension( TypedValue.COMPLEX_UNIT_SP, 16, getResources().getDisplayMetrics())); break; &#125; &#125; a.recycle(); mPaint = new Paint(); mPaint.setAntiAlias(true); mPaint.setTextSize(mTitleTextSize); mBound = new Rect(); mPaint.getTextBounds(mTitleText, 0, mTitleText.length(), mBound); 首先呢，我们发现我们在自定义View时实现了三个构造方法，那么这三个构造方法有什么区别呢（参考自文章android View的三个构造方法 简单总结）？ 其实，第一个构造方法是提供给我们在代码中生成控件使用的，比如： 12345@Overridepublic void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(new CustomView(this));&#125; 在上面的代码中，我们直接通过new CustomView(this)生成了控件，没有涉及到属性的添加，不能在布局文件中使用，如果要在布局文件中使用，必须添加第二个构造方法。 第二个方法是在XML布局文件中插入控件使用的，其中attrs参数就是我们在XML文件中自定义控件的属性，其实第二个构造函数也是调用第三个构造函数，这里我在第三个参数传入R.attr.customViewStyle。 第三个方法的第三个参数defStyleAttr的意义是从APP或者Activity的Theme中设置的该控件的属性的默认值，比如我在attr.xml文件中定义了自定义属性： 1&lt;attr name=&quot;customViewStyle&quot; format=&quot;reference&quot;&gt;&lt;/attr&gt; 然后我们在App或者Activity的Theme中设置它的值： 1234&lt;style name=&quot;AppTheme&quot; parent=&quot;AppBaseTheme&quot;&gt; &lt;!-- All customizations that are NOT specific to a particular API-level can go here. --&gt; &lt;item name=&quot;customViewStyle&quot;&gt;@style/custom_view_style&lt;/item&gt; &lt;/style&gt; 其中的custom_view_style： 123&lt;style name=&quot;custom_view_style&quot;&gt; &lt;item name=&quot;circleWidth&quot;&gt;8dp&lt;/item&gt; &lt;/style&gt; 这样当你的XML文件中没有给该控件的circleWidth定义值的时候，默认值就是8dp。需要注意的是： 1TypedArray array=context.obtainStyledAttributes(set, attrs, defStyleAttr, defStyleRes); 该方法的第四个参数defStyleRes，可以直接传入自定义的style，如果defStyleAttr为0，defStyleRes才会起作用。android控件获取属性值的优先顺序： 在XML文件中直接定义； 在XML文件引用的style; 就是从如上所说的defStyleAttr中取值； 从defStyleRes取值； 从Activity或者Application的Theme中取值； 在第三个构造方法中获取自定义属性的取值时还有另外一种方法如下： 123456789101112131415public CustomView(Context context, AttributeSet attrs, int defStyle) &#123; super(context, attrs, defStyle); TypedArray a = context.obtainStyledAttributes(attrs, R.styleable.CustomeTitleTextView, defStyle, 0); mTitleText = a.getString(R.styleable.CustomeTitleTextView_titleText); mTitleTextSize = a.getDimensionPixelSize(R.styleable.CustomeTitleTextView_titleTextSize, (int) TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_SP, 16, getResources().getDisplayMetrics())); mTitleTextColor = a.getColor(R.styleable.CustomeTitleTextView_titleTextColor, Color.BLACK); a.recycle(); mPaint = new Paint(); mPaint.setAntiAlias(true); mPaint.setTextSize(mTitleTextSize); mBound = new Rect(); mPaint.getTextBounds(mTitleText, 0, mTitleText.length(), mBound);&#125; 我个人更加倾向于后面这种方法，这里我对构造方法中的一些函数进行介绍： TypedVlaue.applyDimension(TypedValue.COMPLEX_UNIT_SP, 16, getResources.getDisplayMetrics()) 该函数的原型为TypedValue.applyDimension(int unit, float value, DisplayMetrics metrics)，用来进行单位的转换，其中第一个参数是第二个参数的单位，并将该单位的值转换为px（像素），DisplayMetrics是一个获取屏幕信息的类，density是设备密度，dp = px / density，因此该方法就是一个将各种单位的值转换为像素的方法。 getDimensionPixelSize是获取某个dimen的值，如果单位是dp或sp，则需要将其乘以density，终归来说，这个函数的返回值得到的是像素值。 onMeasure方法这里我们没有进行重写，在onMeasure方法中直接调用父类的onMeasure方法，因此这里暂时不加以介绍。下面我们看看onDraw方法! 重写onDrawonDraw方法顾名思义就是进行绘图的方法，这里我们在onDraw方法中绘制了一个矩形和一行文字，如下： 12345678@Overrideprotected void onDraw(Canvas canvas) &#123; mPaint.setColor(Color.YELLOW); canvas.drawRect(0, 0, getMeasuredWidth(), getMeasuredHeight(), mPaint); mPaint.setColor(mTitleTextColor); canvas.drawText(mTitleText, getWidth() / 2 - mBound.width() / 2, getHeight() / 2 + mBound.height() / 2, mPaint);&#125; 这里其实还有个坑，就是drawText()方法，大家有兴趣的可以去研究一下。 现在基本上已经有效果了，运行程序，结果如下： 按照洋神的思路(/捂脸)，改下布局文件中CustomView的layout_width和layout_height属性，将CustomView的layout_width和layout_height属性均改为wrap_content，此时运行程序，结果如下： 这里因为我们没有重写onMeasure方法，而是直接调用的父类的onMeasure方法，当我们在布局文件中明确设置CustomView的宽度和高度时，系统帮我们测量的结果就是我们设置的值，但是但我们设置成wrap_content或者match_parent时，系统帮我们测量的结果就是match_parent的值，因此，一般我们都需要重写onMeasure方法，并且在onMeasure方法中根据实际的情况进行不同的设定。 重写onMeasure123456789101112131415161718192021222324@Overrideprotected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123; int widthMode = MeasureSpec.getMode(widthMeasureSpec); int widthSize = MeasureSpec.getSize(widthMeasureSpec); int heightMode = MeasureSpec.getMode(heightMeasureSpec); int heightSize = MeasureSpec.getSize(heightMeasureSpec); int width = 0, height = 0; if (width == MeasureSpec.EXACTLY) &#123; width = widthSize; &#125; else &#123; mPaint.setTextSize(mTitleTextSize); mPaint.getTextBounds(mTitleText, 0, mTitleText.length(), mBound); width = getPaddingLeft() + getPaddingRight() + mBound.width(); &#125; if (height == MeasureSpec.EXACTLY) &#123; height = heightSize; &#125; else &#123; mPaint.setTextSize(mTitleTextSize); mPaint.getTextBounds(mTitleText, 0, mTitleText.length(), mBound); height = getPaddingTop() + getPaddingBottom() + mBound.height(); &#125; setMeasuredDimension(width, height);&#125; 并且修改布局文件，给CustomView添加上padding属性以及layout_centerInParent属性，运行结果如下： 总结本文是Android自定义View修炼之路的开篇，虽然大量参考了洋神的博客，但是在自己动手操作的过程中对其中自定义View的过程有了更加深刻的了解，收获还是很大的，感谢洋神的分享！","tags":[{"name":"Android, 自定义View","slug":"Android-自定义View","permalink":"https://glemontree.github.io/tags/Android-自定义View/"}]},{"title":"[Android] Android零碎知识点","date":"2017-08-04T13:56:59.000Z","path":"2017/08/04/[Android] Android零碎知识点/","text":"?android:selectableItemBackground 想要最快速度的给view加上点击效果，试试在xml中加上android:background=&quot;?android:selectableItemBackground&quot;，Android5.0以上是波纹效果，5.0以下是普通的点击效果 overridePendingTransition overridePendingTransition这个函数有两个参数，一个参数表示第一个activity进入时的动画，另外一个函数表示第二个activity退出时的动画，需要注意的是此方法需要在startActivity()或者finish()后调用，在切换或者退出时就会调用此动画 Uri结构 基本形式： [scheme:]scheme-specific-part[#fragment] 这里分为三部分，分别是：scheme、scheme-specific-part、fragment 进一步划分： [scheme:][//authority][path][?query][#fragment] path可以有多个，每个用/连接，比如：scheme:authority/path1/path2/path3?query#fragment query参数可以带有对应的值，也可以不带，如果带对应的值用=表示，如： scheme://authority/path1/path2/path3?id = 1#fragment query参数可以有多个，每个用&amp;连接 scheme://authority/path1/path2/path3?id = 1 &amp; name = mingming &amp; old#fragment 在android中，除了scheme、authority是必须的，其他的几个path、query、fragment，它们每一个都可以选择要或者不要，但顺序不能变 终极划分 其中authority又可以划分为host:port的形式： [scheme:][//host:port][path][?query][#fragment] 本章节参考自文章Uri详解之——Uri结构与代码提取 选择图片、拍照以及图片裁剪 拍照 123456789101112131415private void takePhoto() &#123; File outputImage = new File(Environment.getExternalStorageDirectory(), \"tmp.jpg\"); try &#123; if (outputImage.exists()) &#123; outputImage.delete(); &#125; outputImage.createNewFile(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; imageUri = Uri.fromFile(outputImage); Intent intent = new Intent(\"android.media.action.IMAGE_CAPTURE\"); intent.putExtra(MediaStore.EXTRA_OUTPUT, imageUri); startActivityForResult(intent, TAKE_PHOTO);&#125; 从相册选择照片 1234private void gotoPickImage() &#123; Intent intent = new Intent(Intent.ACTION_PICK, MediaStore.Images.Media.EXTERNAL_CONTENT_URI); startActivityForResult(intent, REQUEST_PICK_IMAGE);&#125; 选择一张图片并裁剪获得一个小图 1234567891011121314private void gotoPickAndCropSmallBitmap() &#123; Intent intent = new Intent(Intent.ACTION_GET_CONTENT); intent.setType(\"image/*\"); intent.putExtra(\"crop\", \"true\"); intent.putExtra(\"aspectX\", 1); intent.putExtra(\"aspectY\", 1); intent.putExtra(\"outputX\", 300); intent.putExtra(\"outputY\", 300); intent.putExtra(\"scale\", true); intent.putExtra(\"return-data\", true); intent.putExtra(\"outputFormat\", Bitmap.CompressFormat.JPEG.toString()); intent.putExtra(\"noFaceDetection\", true); // no face detection startActivityForResult(intent, REQUEST_CROP_IMAGE_SMALL);&#125; 在将return-data设为true的时候，在onActivityForResult()中可以直接通过data.getParcelableExtra(&quot;data&quot;)得到裁剪后的Bitmap对象，但是当Bitmap过大时，就不能使用这种方式了，得使用下面这种方式。 MediaStore.EXTRA_OUTPUT设置裁剪图片的输入Uri，可以通过Uri.formFile(tmpFile)获得。 选择一张图片并裁剪获得一个大图 12345678910111213141516private void gotoPickAndCropBigBitmap() &#123; imageUri = getTmpUri(); Intent intent = new Intent(Intent.ACTION_GET_CONTENT, null); intent.setType(\"image/*\"); intent.putExtra(\"crop\", \"true\"); intent.putExtra(\"aspectX\", 1); intent.putExtra(\"aspectY\", 1); intent.putExtra(\"outputX\", 2000); intent.putExtra(\"outputY\", 2000); intent.putExtra(\"scale\", true); intent.putExtra(\"return-data\", false); intent.putExtra(MediaStore.EXTRA_OUTPUT, imageUri); intent.putExtra(\"outputFormat\", Bitmap.CompressFormat.JPEG.toString()); intent.putExtra(\"noFaceDetection\", true); // no face detection startActivityForResult(intent, REQUEST_CROP_IMAGE_BIG);&#125; 这里把return-data设为false，同时向MediaStore.EXTRA_OUTPUT设置一个临时构造的Uri，这个Uri用来保存裁剪后的大图，裁剪之后，在onActivityForResult()中就可以通过MediaStore.Images.Media.getBitmap(getContentResolver(), imageUri)得到裁剪后的Bitmap大图。 拍照并裁剪 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869private void startImageCapture() &#123; String IMAGE_FILE_LOCATION = Environment.getExternalStorageDirectory() + \"/\" + \"posprint\" + \"/tmp.jpg\";//temp file imageUri = Uri.fromFile(new File(IMAGE_FILE_LOCATION));//The Uri to store the big bitmap Intent intent = new Intent(MediaStore.ACTION_IMAGE_CAPTURE); intent.putExtra(MediaStore.EXTRA_OUTPUT, imageUri); startActivityForResult(intent, REQUEST_CAPTURE_AND_CROP);&#125;//获得临时保存图片的Uri，用当前的毫秒值作为文件名private Uri getTmpUri() &#123; String IMAGE_FILE_DIR = Environment.getExternalStorageDirectory() + \"/\" + \"app_name\"; File dir = new File(IMAGE_FILE_DIR); File file = new File(IMAGE_FILE_DIR, Long.toString(System.currentTimeMillis())); //非常重要！！！如果文件夹不存在必须先手动创建 if (!dir.exists()) &#123; dir.mkdirs(); &#125; return Uri.fromFile(file);&#125;@Overrideprotected void onActivityResult(int requestCode, int resultCode, Intent data) &#123; if (resultCode == Activity.RESULT_OK) &#123; Bitmap bitmap = null; try &#123; switch (requestCode) &#123; case REQUEST_PICK_IMAGE: //选择的图片的Uri imageUri = data.getData(); bitmap = MediaStore.Images.Media.getBitmap( getContentResolver(), imageUri); case REQUEST_CROP_IMAGE_SMALL: //裁剪后的小图 bitmap = data.getParcelableExtra(\"data\"); break; case REQUEST_CROP_IMAGE_BIG: //裁剪后的大图 bitmap = MediaStore.Images.Media.getBitmap(getContentResolver(), imageUri); break; case REQUEST_CAPTURE_AND_CROP: //得到拍照后的图片并裁剪 cropImageUri(imageUri, REQUEST_CROP_IMAGE_BIG); break; &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; doSomething(bitmap);&#125;//裁剪拍照后得到的图片private void cropImageUri(Uri uri, int requestCode) &#123; Intent intent = new Intent(\"com.android.camera.action.CROP\"); intent.setDataAndType(uri, \"image/*\"); //intent.putExtra(\"crop\", \"true\"); intent.putExtra(\"aspectX\", 1); intent.putExtra(\"aspectY\", 1); intent.putExtra(\"outputX\", 500); intent.putExtra(\"outputY\", 500); intent.putExtra(\"scale\", true); intent.putExtra(MediaStore.EXTRA_OUTPUT, uri); intent.putExtra(\"return-data\", false); intent.putExtra(\"outputFormat\", Bitmap.CompressFormat.JPEG.toString()); intent.putExtra(\"noFaceDetection\", true); // no face detection intent = Intent.createChooser(intent, \"裁剪图片\"); startActivityForResult(intent, requestCode);&#125; 这一部分其实分为了两步，第一步拍照得到图片的Uri，第二步把该图片的Uri传给裁剪图片的程序处理： 这里的action变成了com.android.camera.action.CROP，并且不需要设置extra字段`crop`` `intent.setDataAndType(uri, &quot;image/*&quot;)，这里的uri指向拍照后得到的原图，intent.putExtra(MediaStore.EXTRA_OUTPUT, uri)将裁剪后的图片也保存在这个uri，所以原图就被覆盖了 本章节转载自文章。 getCahceDir()、getFilesDir()、getExternalFilesDir()和getExternalCacheDir() getCacheDir()方法获取/data/data//cache目录 getFilesDir()方法获取/data/data//files目录 通过Context.getExternalFilesDir()方法获取到SDCard/Android/data/你的应用的包名/files/目录 ，一般放一些长时间保存的数据 通过Context.getExternalCacheDir()方法获取到SDCard/Android/data/你的应用的包名/cache/目录，一般存放临时缓存数据 当使用Context.getExternalFilesDir()和Context.getExternalCacheDir()方法时，当你的应用被卸载后，SDCard/Android/data/你的应用的包名/这个目录下的所有文件都会被删除，不会留下垃圾信息。 较优秀的程序都会专门写一个方法来获取缓存地址： 123456789public String getDiskCacheDir(Context context) &#123; String cachePath = null; if (Environment.MEDIA_MOUNTED.equals(Environment.getExternalStorageState || !Environment.isExternalStorageRemovable()) &#123; cachePath = context.getExternalCacheDir().getPath(); &#125; else &#123; cachePath = context.getCacheDir().getPath(); &#125;&#125; 可以看到，当SD卡存在或者SD卡不可被移除的时候，就调用getExternalCacheDir()方法来获取缓存路径，否则就调用getCacheDir()方法来获取缓存路径。前者获取到的就是/sdcard/Android/data//cache这个路径，而后者获取到的是/data/data//cache 这个路径。 注意：这两种方式的缓存都会在卸载app的时候被系统清理到，而开发者自己在sd卡上建立的缓存文件夹，是不会跟随着app的卸载而被清除掉的。 Glide的crossFade()方法 无论你是在加载图片之前是否显示一个占位符，改变 ImageView 的图片在你的 UI 中有非常显著的变化。一个简单的选项是让它改变是更加平滑和养眼的，就是使用一个淡入淡出动画。Glide 使用标准的淡入淡出动画，这是(对于当前版本3.6.1)默认激活的。如果你想要如强制 Glide 显示一个淡入淡出动画，你必须调用另外一个建造者： 123456Glide.with(context) .load(UsageExampleListViewAdapter.eatFoodyImages[0]) .placeholder(R.mipmap.ic_launcher) // can also be a drawable .error(R.mipmap.future_studio_launcher) // will be displayed if the image cannot be loaded .crossFade() .into(imageViewFade); crossFade() 方法还有另外重载方法 crossFade(int duration)。如果你想要去减慢（或加快）动画，随时可以传一个毫秒的时间给这个方法。动画默认的持续时间是 300毫秒。 本章节转载自文章glide的基本使用以及原理 FragmentPagerAdapter和FragmentPagerStateAdapter FragmentPagerAdapter FragmentPagerAdapter继承自PagerAdapter，是专门给ViewPager进行数据适配的，FragmentPagerAdapter这个适配器是用来实现Fragment在ViewPager里面进行滑动切换的，FragmentPagerAdapter拥有自己的缓存策略，当和ViewPager配合使用的时候，会缓存当前Fragment以及左边一个、右边一个一共三个Fragment对象。 假如有三个Fragment，那么在ViewPager初始化之后，三个fragment都会加载完成，中间的Fragment在整个生命周期里只会加载一次，当最左边的Fragment处于显示状态，最右边的Fragment由于超出缓存范围，会被销毁，当再次滑到中间的Fragment时，最右边的Fragment会被再次初始化。 因此，FragmentPagerAdapter最适合来做固定的较少数量的场合，比如说一个有3个tab标签的fragment滑动界面，FragmentPagerAdapter会对我们浏览过的Fragment进行缓存，保存这些界面的临时状态，这样当我们左右滑动的时候，界面切换会更加的流畅，但是这样也会增加程序占用的内存，如果应用场景是更多的Fragment，请使用FragmentStatePagerAdapter。 FragmentPagerStateAdapter FragmentPagerStateAdapter也是PagerAdapter的子类，它的工作方式和ListView相似，当Fragment对用户不可见的时候，整个Fragment会被销毁，只会保存Fragment的保存状态，基于这样的特性，FragmentPagerStateAdapter比FragmentPagerAdapter更适合于用于很多界面之间的切换，而且消耗更少的内存资源 本章节转载自文章FragmentPagerAdapter与FragmentStatePagerAdapter使用详解与区别 CoordinatorLayout与滚动的处理 浮动操作按钮 CoordinatorLayout可以用来配合浮动操作按钮的layout_anchor和layout_gravity属性制造出浮动效果，layout_anchor指定参照物，anchorGravity指定相对于参照物的位置，设置为bottom | right则表示将FloatingActionButton放置于参照物的右下角： 12345678910111213141516171819202122&lt;android.support.design.widget.CoordinatorLayout android:id=\"@+id/main_content\" xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:app=\"http://schemas.android.com/apk/res-auto\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\"&gt; &lt;android.support.v7.widget.RecyclerView android:id=\"@+id/rvToDoList\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\"&gt; &lt;/android.support.v7.widget.RecyclerView&gt; &lt;android.support.design.widget.FloatingActionButton android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:layout_gravity=\"bottom|right\" android:layout_margin=\"16dp\" android:src=\"@mipmap/ic_launcher\" app:layout_anchor=\"@id/rvToDoList\" app:layout_anchorGravity=\"bottom|right|end\"/&gt; &lt;/android.support.design.widget.CoordinatorLayout&gt; Toolbar的扩展和收缩 12345678910111213141516171819202122&lt;android.support.design.widget.CoordinatorLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:app=\"http://schemas.android.com/apk/res-auto\" android:id=\"@+id/main_content\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:fitsSystemWindows=\"true\"&gt; &lt;android.support.design.widget.AppBarLayout android:id=\"@+id/appbar\" android:layout_width=\"match_parent\" android:layout_height=\"@dimen/detail_backdrop_height\" android:theme=\"@style/ThemeOverlay.AppCompat.Dark.ActionBar\" android:fitsSystemWindows=\"true\"&gt; &lt;android.support.v7.widget.Toolbar android:id=\"@+id/toolbar\" android:layout_width=\"match_parent\" android:layout_height=\"?attr/actionBarSize\" app:popupTheme=\"@style/ThemeOverlay.AppCompat.Light\" /&gt; &lt;/android.support.design.widget.AppBarLayout&gt; &lt;/android.support.design.widget.CoordinatorLayout&gt; 需要注意的是AppBarLayout目前必须是第一个嵌套在CoordinatorLayout里面的子View。 然后我们需要定义AppBarLayout与滚动视图之间的联系，在RecyclerView或者任意支持嵌套滚动的View比如NestedScrollView上添加app:layout_behavior，support library包含了一个特殊的字符串资源@string/appbar_scrolling_view_behavior，它的值为android.support.design.widget.AppBarLayout$ScrollingViewBehavior，指向AppBarLayout.ScrollingViewBehavior，用来通知AppBarLayout这个特殊的view何时发生了滚动事件，这个behavior需要设置在触发滚动事件的view之上。 12345&lt;android.support.v7.widget.RecyclerView android:id=\"@+id/rvToDoList\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" app:layout_behavior=\"@string/appbar_scrolling_view_behavior\"&gt; 当CoordinatorLayout发现RecyclerView中设置了这个属性，它会搜索自己所包含的其他view，看看是否有view与这个behavior相关联，AppBarLayout.ScrollingViewBehavior描述了RecyclerView与AppBarLayout之间的依赖关系，RecyclerView的任意滚动事件都将触发AppBarLayout或者AppBarLayout里面view的改变。 AppBarLayout里面定义的view只要设置了app:layout_scrollFlags属性，就可以在RecyclerView滚动事件发生时被触发： 12345678910111213&lt;android.support.design.widget.AppBarLayout android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:fitsSystemWindows=\"true\" android:theme=\"@style/ThemeOverlay.AppCompat.Dark.ActionBar\"&gt; &lt;android.support.v7.widget.Toolbar android:id=\"@+id/toolbar\" android:layout_width=\"match_parent\" android:layout_height=\"?attr/actionBarSize\" app:layout_scrollFlags=\"scroll|enterAlways\"/&gt; &lt;/android.support.design.widget.AppBarLayout&gt; app:layout_scrollFlags这个属性必须至少启动scroll这个flag，这样这个view才会滚出屏幕，否则它将一直固定在顶部，可以使用的其他flag有： enterAlways: 一旦向上滚动这个view就可见 enterAlwaysCollapsed: 这个flag定义的是何时进入（已经消失之后何时再次显示），假设你定义了一个最小高度（minHeight），同时enterAlways也定义了，那么view将在到达这个最小高度的时候开始显示，并且从这个时候开始慢慢展开，当滚动到顶部的时候展开完 exitUntilCollapsed: 这个flag定义何时退出，当你定义了一个minHeight，这个view将在滚动到这个最小高度的时候消失 制造折叠效果 如果想制造Toolbar的折叠效果，必须把ToolBar放在CollapsingToolbarLayout中： 1234567891011121314&lt;android.support.design.widget.CollapsingToolbarLayout android:id=\"@+id/collapsing_toolbar\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:fitsSystemWindows=\"true\" app:contentScrim=\"?attr/colorPrimary\" app:expandedTitleMarginEnd=\"64dp\" app:expandedTitleMarginStart=\"48dp\" app:layout_scrollFlags=\"scroll|exitUntilCollapsed\"&gt; &lt;android.support.v7.widget.Toolbar android:id=\"@+id/toolbar\" android:layout_width=\"match_parent\" android:layout_height=\"?attr/actionBarSize\" app:layout_scrollFlags=\"scroll|enterAlways\"/&gt;&lt;/android.support.design.widget.CollapsingToolbarLayout&gt; 需要注意的是通常我们都是设置ToolBar的Title，而现在，需要将title设置在CollapsingToolbarLayout上，而不是ToolBar： 123CollapsingToolbarLayout collapsingToolbar = (CollapsingToolbarLayout) findViewById(R.id.collapsing_toolbar);collapsingToolbar.setTitle(\"Title\"); 制造视觉效果 CollapsingToolbarLayout还能让我们做出更高级的动画，比如在里面放一个ImageView，然后在它折叠的时候渐渐淡出。同时在用户滚动的时候title的高度也会随着改变。 为了制造出这种效果，我们添加一个定义了app:layout_collapseMode=”parallax” 属性的ImageView。 123456789101112131415161718192021222324&lt;android.support.design.widget.CollapsingToolbarLayout android:id=\"@+id/collapsing_toolbar\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:fitsSystemWindows=\"true\" app:contentScrim=\"?attr/colorPrimary\" app:expandedTitleMarginEnd=\"64dp\" app:expandedTitleMarginStart=\"48dp\" app:layout_scrollFlags=\"scroll|exitUntilCollapsed\"&gt; &lt;android.support.v7.widget.Toolbar android:id=\"@+id/toolbar\" android:layout_width=\"match_parent\" android:layout_height=\"?attr/actionBarSize\" app:layout_scrollFlags=\"scroll|enterAlways\"&gt; &lt;/android.support.v7.widget.Toolbar&gt; &lt;ImageView android:src=\"@drawable/cheese_1\" app:layout_scrollFlags=\"scroll|enterAlways|enterAlwaysCollapsed\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:scaleType=\"centerCrop\" app:layout_collapseMode=\"parallax\" android:minHeight=\"100dp\"/&gt;&lt;/android.support.design.widget.CollapsingToolbarLayout&gt; 本章节转载自文章[CoordinatorLayout与滚动的处理(http://www.jcodecraeer.com/a/anzhuokaifa/androidkaifa/2015/0717/3196.html) 定义数组 Android中可以在res-&gt;values-&gt;array.xml文件中声明数组，例如： 123456789101112&lt;string-array name=\"news_type_cn\"&gt; &lt;item&gt;头条&lt;/item&gt; &lt;item&gt;社会&lt;/item&gt; &lt;item&gt;国内&lt;/item&gt; &lt;item&gt;国际&lt;/item&gt; &lt;item&gt;娱乐&lt;/item&gt; &lt;item&gt;体育&lt;/item&gt; &lt;item&gt;军事&lt;/item&gt; &lt;item&gt;科技&lt;/item&gt; &lt;item&gt;财经&lt;/item&gt; &lt;item&gt;时尚&lt;/item&gt;&lt;/string-array&gt; 然后在代码中就可以通过如下方式获取数组： 1types = getResources().getStringArray(R.array.news_type_en); ButterKnife的简单实用 要在代码中使用ButterKnife，首先需要在gradle中进行配置： 12compile &apos;com.jakewharton:butterknife:8.5.1&apos;annotationProcessor &apos;com.jakewharton:butterknife-compiler:8.5.1&apos; 需要注意的是加在Module:app的gradle文件中，加入之后直接同步一下即可，就可在External Libraries文件夹下看到ButterKnife 为了在代码中使用ButterKnife，需要在代码中对ButterKnife服务进行注册： 12ButterKnife.bind(this); // 在Activity中使用ButterKnife.bind(this, view); // 在非Activity中使用 绑定View控件 1234@BindView(R.id.btn_login)Button mBtn; // 单个View控件的绑定@BindViews(&#123;R.id.first_name, R.id.middle_name, R.id.last_name&#125;)List&lt;EditText&gt; nameViews; // 多个控件的绑定可以写在List或者Array中 资源绑定 12345678@BindString(R.string.title)String title;@BindDrawable(R.drawable.graphic)Drawabel graphic;@BindColor(R.color.red)int red;@BindDimen(R.dimen.spacer)Float spacer; 监听器绑定 监听器可以直接注解到方法上 1234@OnClick(R.id.submit)public void submit(View view) &#123; &#125; 多个控件可以绑定到同一个监听器 1234@OnClick(&#123;R.id.submit, R.id.login&#125;)public void sayHi(Button button) &#123; button.setText(\"Hello\");&#125; 当ButterKnife在Fragment的onCreateView()方法中进行绑定时，需要在onDestroyView()中进行解绑，ButterKnife.bind()方法提供了一个Unbinder返回值，在onDestroyView()中调用相关的unbind()方法即可： 123456789101112131415public class FancyFragment extends Fragment &#123;@BindView(R.id.button1) Button button1; @BindView(R.id.button2) Button button2;private Unbinder unbinder; @Override public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) &#123; View view = inflater.inflate(R.layout.fancy_fragment, container,false); unbinder = ButterKnife.bind(this, view); // TODO Use fields... return view; &#125; @Override public void onDestroyView() &#123; super.onDestroyView(); unbinder.unbind(); &#125;&#125; 本章节转载自文章Butterknife 使用指南 ActionBar setHomeButtonEnabled这个在小于4.0版本的默认值是true，但是在4.0及其以上是false，该方法的作用是决定左上角的图标是否可以点击，没有向左的小图标，true图标可以点击，false图标不可点击 setDisplayHomeAsUpEnabled(true)：给左上角图标的左边加上一个返回的图标，对应ActionBar.DISPLAY_HOME_AS_UP setDisplayShowHomeEnabled(true)：使左上角图标是否显示，如果设为false，则没有程序图标，仅仅就是个标题，否则，显示应用程序图标，对应id为Android.R.id.home，对应ActionBar.DISPLAY_SHOW_HOME setDispalyShowTitleEnabled(true)：对应ActionBar.DISPLAY_SHOW_TITLE setHomeButtonEnabled和setDisplayShowHomeEnabled(true)共同起作用，如果setHomeButtonEnabled设为false，即使setDisplayShowHomeEnabled(true)设为true，图标也不能点击 如果希望点击图标左侧箭头返回上一页，需要加载选项菜单后，对于菜单项的点击事项调用如下方法： 1234567public boolean onOptionsItemSelected(MenuItem item) &#123; if (item.getItemId() == android.R.id.home) &#123; finish(); return true; &#125; return super.onOptionsItemSelected(item);&#125; 本章节转载自文章 关于ActionBar中setDisplayHomeAsUpEnabled(true)等方法的问题 在实际项目开发过程中，通常为所有的Activity定义一个BaseActivity，可以在BaseActivity中定义：private Activity mActivity;，这样在onCreate()方法中定义mActivity= this，那么子类在继承BaseActivity时在onCreate()方法中通过super.onCreate()方法可以执行BaseActivity的onCreate()方法中的代码，即执行了mActivity = this，那么此时的mActivity也就代表了当前的Activity。 如果想在项目中使用CardView，需要在build.gradle文件中添加下面的代码： 12//卡片式布局compile &apos;com.android.support:cardview-v7:24.1.1&apos; 如果想在项目中使用Glide，需要在build.gradle文件中添加下面的代码： 12//图片加载框架 Glidecompile &apos;com.github.bumptech.glide:glide:3.7.0&apos; Android ListView与适配器模式 电源适配器相信大家都知道，其作用就是将插座的220V电源转换为电脑所需要的5V电源，在软件开发中，我们称之为接口不兼容，此时就需要适配器来进行接口转换。 因此，适配器模式就是把一个类的接口变成客户端所期待的另外一种接口，从而使原本因接口不匹配而无法一起工作的两个类能够在一起工作。 适配器模式通常涉及到Target、Adapter和Adaptee三部分，Target就是客户端所期望的接口，Adaptee就是需要适配的接口，而Adapter就用来将Adaptee接口转换成Target接口。 适配器模式可以分为类适配器模式和对象适配器模式。 类适配器模式 此时Adapter类需要继承Adaptee并且实现Target接口，在Adapter类中实现的Target接口方法中调用Adaptee中的方法： 12345678910111213141516171819202122// Targetpublic interface Target &#123; public void target();&#125;// Adapteepublic class Adaptee() &#123; public void adaptee() &#123; System.out.println(\"adaptee...\"); &#125;&#125;// Adapterpublic class Adapter extends Adaptee implements Target &#123; public void target() &#123; convertFromAdapteeToTarget(); &#125; private void convertFromAdapteeToTarget() &#123; &#125;&#125; 对象适配器模式 与类的适配器模式不同的是，对象的适配器模式不是使用继承关系连接到Adaptee类，而是使用代理关系连接到Adaptee类。 1234567891011121314151617181920212223242526272829// Targetpublic interface Target &#123; public void target();&#125;// Adapteepublic class Adaptee() &#123; public void adaptee() &#123; System.out.println(\"adaptee...\"); &#125;&#125;// Adapterpublic class Adapter implements Target &#123; private Adaptee adaptee; public void setAdaptee(Adaptee adaptee) &#123; this.adaptee = adaptee; &#125; public void target() &#123; convertFromAdapteeToTarget(); &#125; private void convertFromAdapteeToTarget() &#123; &#125;&#125; 建议尽量使用对象适配器的实现方式，多用合成/聚合，少用继承。 下面看看Android中的ListView是如何使用适配器模式的，首先看一下使用ListView的代码： 123456789101112131415161718192021222324252627282930313233343536373839404142ListView mListView = (ListView) findViewById(R.id.listview);mListView.setAdapter(new MyAdappter(context, datas));public class MyAdapter extends BaseAdapter &#123; private LayoutInflater inflater; List&lt;String&gt; datas; public MyAdapter(Context context, List&lt;String&gt; datas) &#123; this.inflater = LayoutInflater.from(context); this.datas = datas; &#125; @Override public int getCount() &#123; return datas.size(); &#125; @Override public String getItem(int position) &#123; return datas.get(position); &#125; @Override public long getItemId(int position) &#123; return position; &#125; @Override public View getView(int position, View convertView, ViewGroup parent) &#123; ViewHolder holder = null; // Item View的复用 if (convertView == null) &#123; holder = new ViewHolder(); convertView = mInflater.inflate(R.layout.my_listview_item, null); // 获取title holder.title = (TextView)convertView.findViewById(R.id.title); convertView.setTag(holder); &#125; else &#123; holder = (ViewHolder)convertView.getTag(); &#125; holder.title.setText(mDatas.get(position)); return convertView; &#125;&#125; 那么为什么这里需要使用Adapter模式呢？我们知道，ListView需要能够显示各种各样的视图，每个人需要的显示效果不相同，显示的数据类型、数量也各不相同，那么如何隔离这种变化就很重要！ Android中的做法是增加一个Adapter层来应对变化，将ListView需要的接口抽象到Adapter对象中，这样只要用户实现了Adapter接口，ListView就可以按照用户设定的显示效果、数量、数据来显示特定的item view。 通过代理数据集来告知ListView数据的个数( getCount函数 )以及每个数据的类型( getItem函数 )，最重要的是要解决Item View的输出。Item View千变万化，但终究它都是View类型，Adapter统一将Item View输出View ( getView函数 )，这样就很好的应对了Item View的可变性。 那么ListView是如何通过Adapter模式 ( 不止Adapter模式 )来运作的呢 ？我们一起来看一看。 ListView继承自AbsListView，Adapter定义在AbsListView中，我们看一看这个类。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970public abstract class AbsListView extends AdapterView&lt;ListAdapter&gt; implements TextWatcher, ViewTreeObserver.OnGlobalLayoutListener, Filter.FilterListener, ViewTreeObserver.OnTouchModeChangeListener, RemoteViewsAdapter.RemoteAdapterConnectionCallback &#123; ListAdapter mAdapter ; // 关联到Window时调用的函数 @Override protected void onAttachedToWindow() &#123; super.onAttachedToWindow(); // 代码省略 // 给适配器注册一个观察者,该模式下一篇介绍。 if (mAdapter != null &amp;&amp; mDataSetObserver == null) &#123; mDataSetObserver = new AdapterDataSetObserver(); mAdapter.registerDataSetObserver(mDataSetObserver); // Data may have changed while we were detached. Refresh. mDataChanged = true; mOldItemCount = mItemCount // 获取Item的数量,调用的是mAdapter的getCount方法 mItemCount = mAdapter.getCount(); &#125; mIsAttached = true; &#125; /** * 子类需要覆写layoutChildren()函数来布局child view,也就是Item View */ @Override protected void onLayout(boolean changed, int l, int t, int r, int b) &#123; super.onLayout(changed, l, t, r, b); mInLayout = true; if (changed) &#123; int childCount = getChildCount(); for (int i = 0; i &lt; childCount; i++) &#123; getChildAt(i).forceLayout(); &#125; mRecycler.markChildrenDirty(); &#125; if (mFastScroller != null &amp;&amp; mItemCount != mOldItemCount) &#123; mFastScroller.onItemCountChanged(mOldItemCount, mItemCount); &#125; // 布局Child View layoutChildren(); mInLayout = false; mOverscrollMax = (b - t) / OVERSCROLL_LIMIT_DIVISOR; &#125; // 获取一个Item View View obtainView(int position, boolean[] isScrap) &#123; isScrap[0] = false; View scrapView; // 从缓存的Item View中获取,ListView的复用机制就在这里 scrapView = mRecycler.getScrapView(position); View child; if (scrapView != null) &#123; // 代码省略 child = mAdapter.getView(position, scrapView, this); // 代码省略 &#125; else &#123; child = mAdapter.getView(position, null, this); // 代码省略 &#125; return child; &#125;&#125; AbsListView定义了集合视图的框架，比如Adapter模式的应用、复用Item View的逻辑、布局Item View的逻辑等。子类只需要覆写特定的方法即可实现集合视图的功能，例如ListView。 ListView中相关方法： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879@Overrideprotected void layoutChildren() &#123; // 代码省略 try &#123; super.layoutChildren(); invalidate(); // 代码省略 // 根据布局模式来布局Item View switch (mLayoutMode) &#123; case LAYOUT_SET_SELECTION: if (newSel != null) &#123; sel = fillFromSelection(newSel.getTop(), childrenTop, childrenBottom); &#125; else &#123; sel = fillFromMiddle(childrenTop, childrenBottom); &#125; break; case LAYOUT_SYNC: sel = fillSpecific(mSyncPosition, mSpecificTop); break; case LAYOUT_FORCE_BOTTOM: sel = fillUp(mItemCount - 1, childrenBottom); adjustViewsUpOrDown(); break; case LAYOUT_FORCE_TOP: mFirstPosition = 0; sel = fillFromTop(childrenTop); adjustViewsUpOrDown(); break; case LAYOUT_SPECIFIC: sel = fillSpecific(reconcileSelectedPosition(), mSpecificTop); break; case LAYOUT_MOVE_SELECTION: sel = moveSelection(oldSel, newSel, delta, childrenTop, childrenBottom); break; default: // 代码省略 break; &#125; &#125; // 从上到下填充Item View [ 只是其中一种填充方式 ] private View fillDown(int pos, int nextTop) &#123; View selectedView = null; int end = (mBottom - mTop); if ((mGroupFlags &amp; CLIP_TO_PADDING_MASK) == CLIP_TO_PADDING_MASK) &#123; end -= mListPadding.bottom; &#125; while (nextTop &lt; end &amp;&amp; pos &lt; mItemCount) &#123; // is this the selected item? boolean selected = pos == mSelectedPosition; View child = makeAndAddView(pos, nextTop, true, mListPadding.left, selected); nextTop = child.getBottom() + mDividerHeight; if (selected) &#123; selectedView = child; &#125; pos++; &#125; return selectedView; &#125; // 添加Item View private View makeAndAddView(int position, int y, boolean flow, int childrenLeft, boolean selected) &#123; View child; // 代码省略 // Make a new view for this position, or convert an unused view if possible child = obtainView(position, mIsScrap); // This needs to be positioned and measured setupChild(child, position, y, flow, childrenLeft, selected, mIsScrap[0]); return child; &#125; ListView覆写了AbsListView中的layoutChilden函数，在该函数中根据布局模式来布局Item View。Item View的个数、样式都通过Adapter对应的方法来获取，获取个数、Item View之后，将这些Item View布局到ListView对应的坐标上，再加上Item View的复用机制，整个ListView就基本运转起来了。 当然这里的Adapter并不是经典的适配器模式，但是却是对象适配器模式的优秀示例，也很好的体现了面向对象的一些基本原则。这里的Target角色和Adapter角色融合在一起，Adapter中的方法就是目标方法；而Adaptee角色就是ListView的数据集与Item View，Adapter代理数据集，从而获取到数据集的个数、元素。 通过增加Adapter一层来将Item View的操作抽象起来，ListView等集合视图通过Adapter对象获得Item的个数、数据元素、Item View等，从而达到适配各种数据、各种Item视图的效果。因为Item View和数据类型千变万化，android师们将这些变化的部分交给用户来处理，通过getCount、getItem、getView等几个方法抽象出来，也就是将Item View的构造过程交给用户来处理，灵活地运用了适配器模式，达到了无限适配、拥抱变化的目的。 本章节转载自文章Android源码之ListView的适配器模式。 FrameLayout的特点就是FrameLayout中的多个布局会重叠显示，看下面这段代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" android:orientation=\"vertical\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:fitsSystemWindows=\"true\"&gt; &lt;android.support.v7.widget.Toolbar android:id=\"@+id/tb_joke\" android:layout_width=\"match_parent\" android:layout_height=\"?attr/actionBarSize\" android:background=\"?attr/colorPrimary\" android:fitsSystemWindows=\"true\" android:titleTextColor=\"#fff\"&gt; &lt;ImageView android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:src=\"@drawable/ic_joke_title\"/&gt; &lt;/android.support.v7.widget.Toolbar&gt; &lt;FrameLayout android:layout_width=\"match_parent\" android:layout_height=\"match_parent\"&gt; &lt;LinearLayout android:id=\"@+id/ll_loading\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:gravity=\"center\" android:orientation=\"vertical\" android:visibility=\"visible\"&gt; &lt;TextView android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:text=\"正在加载中\"/&gt; &lt;/LinearLayout&gt; &lt;LinearLayout android:visibility=\"gone\" android:id=\"@+id/ll_error\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:gravity=\"center\" android:orientation=\"vertical\"&gt; &lt;TextView android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:text=\"加载失败\"/&gt; &lt;TextView android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:clickable=\"true\" android:id=\"@+id/tv_joke_load_again\" android:background=\"#d7d6d6\" android:padding=\"10dp\" android:text=\"重新加载\"/&gt; &lt;/LinearLayout&gt; &lt;android.support.v4.widget.SwipeRefreshLayout android:id=\"@+id/srl_joke\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\"&gt; &lt;android.support.v7.widget.RecyclerView android:id=\"@+id/rv_joke\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\"&gt; &lt;/android.support.v7.widget.RecyclerView&gt; &lt;/android.support.v4.widget.SwipeRefreshLayout&gt; &lt;/FrameLayout&gt;&lt;/LinearLayout&gt; 在FrameLayout中包含了3个子布局，即两个LinearLayout和一个SwipeRefreshLayout，三者会重叠显示，那么在代码中通过控制各个不同的布局在不同情况下的显示和消失就可以显示几种不同的布局。 android:imeOptions属性 默认情况下软键盘右下角按钮为“下一个”，点击会进入到下一个输入框，保持软键盘，设置android:imeOptions=actionDone，软键盘下方变成完成，点击后光标保持在原来的输入框中，并且软键盘关闭，设置android:imeOptions=actionSend软键盘下方变成“发送”，点击后光标移动到下一个，那么设置的imeOptions如何使用呢？一般情况下可以这样使用：让EditText实现OnEditorActionListener，在onEditActin方法中actionId就对应我们设置的imeOptions，系统默认的actionId有EditorInfo.IME_NULL、EditorInfo.IME_ACTION_SEND、EditorInfo.IME_ACTION_DONE，这样就可以根据不同的EditText实现不同的软键盘右下角功能键： 1234567891011121314// 设置软键盘的操作etInput.setImeOptions(EditorInfo.IME_ACTION_SEARCH);...@Overridepublic boolean onEditorAction(TextView v, int actionId, KeyEvent event) &#123; if (actionId == EditorInfo.IME_ACTION_SEND) &#123; ... return true; &#125; else &#123; ... &#125; closeKeyBoard(); return false;&#125; android:clipToPadding的作用 常常用于paddingTop的情况，并且默认情况下其值为true，当内部有个属性设置了paddingTop但是滑动的时候就忽视paddingTop则可以设置android:clipToPadding=&quot;false&quot;。 大家可以参考 Padding与绘制区域–android:clipToPadding和android:clipChildren这篇文章，看了图就懂了！ 另外再推荐一篇文章android:clipToPadding属性应用，这篇文章讲的蛮好的，其效果图如下： android:clipToPadding=&quot;true&quot; android:clipToPadding=&quot;false&quot; Java中indexOf方法 indexOf()方法用于在字符串中查找子串，该方法返回一个整数，指出String对象内子字符串的开始位置，如果没有找到该子串，则返回-1。 indexof()方法的函数原型如下： 12int indexOf(String str); // 返回第一次出现的指定子字符串在字符串中的索引int indexOf(String str, int startIndex); // 从指定的索引开始，返回第一次出现的指定字符串在此字符串中的索引 Android在实现界面刷新时有两种方法invalidate和postInvalidate，两者的区别在于invalidate方法不能直接在线程中调用，必须在UI线程中调用，而postInvalidate可以在工作线程中调用。 设置画笔属性 setAntiAlias(boolean aa) 打开抗锯齿，抗锯齿是依赖于算法的，算法决定抗锯齿的效率，我们在绘制棱角分明的图像时，比如一个矩形、一张位图，我们不需要打开抗锯齿 setColorFilter(ColorFilter filter) 这个方法需要传入一个ColorFilter参数同样也会返回一个ColorFilter实例，其实ColorFilter类是一个父类，其有3个子类，分别为ColorMatrixColorFilter、LightingColorFilter和PorterDuffColorFilter。 ColorMatrixColorFilter 色彩矩阵颜色过滤器，在Android中图片是以RGBA像素点的形式加载到内存中的，修改这些像素信息需要一个叫做ColorMatrix类的支持，其定义了一个4*5的float[]类型的矩阵： 123456ColorMatrix colorMatrix = new ColorMatrix(new float[]&#123; 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, &#125;); 第一行表示的R（红色）的向量，第二行表示的G（绿色）的向量，第三行表示的B（蓝色）的向量，最后一行表示A（透明度）的向量。这个矩阵不同的位置表示的RGBA值，其范围在0.0F至2.0F之间，1为保持原图的RGB值。每一行的第五列数字表示偏移值，何为偏移值？顾名思义当我们想让颜色更倾向于红色的时候就增大R向量中的偏移值，想让颜色更倾向于蓝色的时候就增大B向量中的偏移值。 通过修改ColorMatrix，我们可以修改颜色，比如： 12345678// 生成色彩矩阵 ColorMatrix colorMatrix = new ColorMatrix(new float[]&#123; 0.5F, 0, 0, 0, 0, 0, 0.5F, 0, 0, 0, 0, 0, 0.5F, 0, 0, 0, 0, 0, 1, 0, &#125;); mPaint.setColorFilter(new ColorMatrixColorFilter(colorMatrix)); 这其中的原理是这样的： LightingColorFilter 光照颜色过滤，这个方法只有一个构造方法： 1LightingColorFilter(int mul, int add); 其中mul全称是colorMultiply即色彩倍增，而add全称是colorAdd即色彩增加，这两个值都是16进制的0xAARRGGBB。 PorterDuffColorFilter PorterDuffColorFilter只有一个构造方法： 1PorterDuffColorFilter(int color, PorterDuff.Mode mode); 这个构造方法也接受两个值，一个是16进制表示的颜色值这个很好理解，而另一个是PorterDuff内部类Mode中的一个常量值，这个值表示混合模式。那么什么是混合模式呢？混合混合必定是有两种东西混才行，第一种就是我们设置的color值而第二种当然就是我们画布上的元素了！，比如这里我们把Color的值设为红色，而模式设为PorterDuff.Mode.DARKEN变暗： ViewConfiguration.getScaledTouchSlop() getScaledTouchSlop是一个距离，表示滑动的时候，手的移动要大于这个距离才开始移动控件。如果小于这个距离就不触发移动控件，如viewpager就是用这个距离来判断用户是否翻页 Android中全局Application的onCreate()方法多次调用问题 通常，一个应用的所有组件都运行在系统为这个应用所创建的默认进程中，这个默认进程是用这个应用的包名来命名的，如果声明文件中的组件或应用没有指定这个属性则默认应用和其组件将相应运行在以其包名命名的进程中。 一般来说，Application的onCreate()方法只会执行一次，如果应用中采用多进程方式，onCreate()方法会执行多次，根据不同的进程名字进行不同的初始化。 一般情况下一个服务没有自己独立的进程，它一般是作为一个线程运行于它所在的应用的进程中，但是也有例外，Android声明文件中的android:process属性却可以为任意组件包括应用指定进程，即通过在声明文件中设置android:process属性，我们可以让组件（例如Activity、Service）和应用（Application）创建并运行于我们指定的进程中，冒号（”:”）这个前缀将把这个名字附加到你的包所运行的标准进程名字的后面作为新的进程名称： 123&lt;service android:name=\"com.baidu.location.f\" android:enabled=\"true\" android:process=\":baiduMap\"&gt;&lt;/service&gt; 那么在DDMS中就可以看到这个进程：com.example.hello:baiduMap。 解决方法是在自定义的Application的onCreate方法中控制不同进程的初始化： 12345678910111213141516171819202122232425262728String processName = getProcessName(this, android.os.Process.myPid()); if (processName != null) &#123; boolean defaultProcess = processName.equals(Constants.REAL_PACKAGE_NAME); // 默认的主进程启动时初始化应用 if (defaultProcess) &#123; initAppForMainProcess(); &#125; // 其他进程启动时初始化对应内容 else if (processName.contains(\":webbrowser\")) &#123; &#125; else if (processName.contains(\":wallet\")) &#123; &#125; &#125; public static String getProcessName(Context cxt, int pid) &#123; ActivityManager am = (ActivityManager) cxt.getSystemService(Context.ACTIVITY_SERVICE); List&lt;RunningAppP.rocessInfo&gt; runningApps = am.getRunningAppProcesses(); if (runningApps == null) &#123; return null; &#125; for (RunningAppProcessInfo procInfo : runningApps) &#123; if (procInfo.pid == pid) &#123; return procInfo.processName; &#125; &#125; return null; &#125; 本小节转载自文章Android中全局Application的onCreate多次调用问题。 Java静态方法可以被重写吗？ 非静态方法属于类的实例，是可以被子类重写从而达到多态的效果，静态方法属于类，是不能被重写，故而不能实现多态。 compileSdkVersion 表示编译版本，就是运行我们这个项目的SDK版本号，也就是API Level，例如API-19、API-20等 buildToolVersion 表示构建工具的版本，其中包含了打包工具aapt、dx等等，这个工具的目录位于..your_sdk_path/build_tools/xx.xx.xx minSdkVersion 指定应用程序所需的最小API Level，如果不指明的话默认为1，也就是说该应用兼容所有的android版本，我们应该总是声明这个属性。 如果系统的API Level低于minSdkVersion，那么android系统会阻止用户安装这个应用。 如果指明了这个属性，并且在项目中使用了高于这个API Levle的API，那么在编译时就会报错。 因此，minSdkVersion不仅在安装程序时起作用，也会在项目构建时起作用。 targetSdkVersion targetSdkVersion是Android系统提供向前兼容的主要手段，随着Android系统的升级，某个系统的API或者模块的行为可能会发生变化，但是为了保证老APK的行为还是和以前兼容，只要targetSdkVersion不变，即使这个APK安装在新Android系统上，其行为还是保持老的系统上的行为，这样就保证了系统对老应用的向前兼容性。 在 Android 4.4 (API 19）以后，AlarmManager 的 set() 和 setRepeat() 这两个 API 的行为发生了变化。在 Android 4.4 以前，这两个 API 设置的都是精确的时间，系统能保证在 API 设置的时间点上唤醒 Alarm。因为省电原因 Android 4.4 系统实现了 AlarmManager 的对齐唤醒，这两个 API 设置唤醒的时间，系统都对待成不精确的时间，系统只能保证在你设置的时间点之后某个时间唤醒。 这时，虽然 API 没有任何变化，但是实际上 API 的行为却发生了变化，如果老的 APK 中使用了此 API，并且在应用中的行为非常依赖 AlarmManager 在精确的时间唤醒，例如闹钟应用。如果 Android 系统不能保证兼容，老的 APK 安装在新的系统上，就会出现问题。 Android 系统是怎么保证这种兼容性的呢？这时候 targetSdkVersion 就起作用了。APK 在调用系统 AlarmManager 的 set() 或者 setRepeat() 的时候，系统首先会查一下调用的 APK 的 targetSdkVersion 信息，如果小于 19，就还是按照老的行为，即精确设置唤醒时间，否者执行新的行为。 本小节转载自文章Android targetSdkVersion 原理。 ​","tags":[{"name":"Android","slug":"Android","permalink":"https://glemontree.github.io/tags/Android/"}]},{"title":"[Android] Build.VERSION_CODES类下面的版本信息","date":"2017-08-03T03:52:07.000Z","path":"2017/08/03/[Android] Build.VERSION_CODES类下面的版本信息/","text":"获取手机版本号：Build.VERSION.SDK_INT Build.VERSION_CODES类下面的版本信息： 123456789101112131415161718static int BASE //October 2008: The original, first, version of Android. static int BASE_1_1 //February 2009: First Android update, officially called 1.1. static int CUPCAKE //May 2009: Android 1.5. static int CUR_DEVELOPMENT //Magic version number for a current development build, which has not yet turned into an official release. static int DONUT //September 2009: Android 1.6. static int ECLAIR //November 2009: Android 2.0 static int ECLAIR_0_1 //December 2009: Android 2.0.1 static int ECLAIR_MR1 //January 2010: Android 2.1 static int FROYO June //2010: Android 2.2 static int GINGERBREAD //November 2010: Android 2.3 static int GINGERBREAD_MR1 //February 2011: Android 2.3.3. static int HONEYCOMB //February 2011: Android 3.0. static int HONEYCOMB_MR1 //May 2011: Android 3.1. static int HONEYCOMB_MR2 //June 2011: Android 3.2. static int ICE_CREAM_SANDWICH //October 2011: Android 4.0. static int ICE_CREAM_SANDWICH_MR1 //December 2011: Android 4.0.3. static int JELLY_BEAN //June 2012: Android 4.1. static int JELLY_BEAN_MR1 //Android 4.2: Moar jelly beans! 在实际应用中可以这样判断： 123if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.ICE_CREAM_SANDWICH) &#123; &#125;","tags":[{"name":"Android, SDK版本号","slug":"Android-SDK版本号","permalink":"https://glemontree.github.io/tags/Android-SDK版本号/"}]},{"title":"[算法] 海量数据处理","date":"2017-07-23T08:50:24.000Z","path":"2017/07/23/[算法] 海量数据处理/","text":"海量数据处理.","tags":[{"name":"C++ boost","slug":"C-boost","permalink":"https://glemontree.github.io/tags/C-boost/"}]},{"title":"[Java] 匿名内部类访问外部类的局部变量为什么一定得是final类型","date":"2017-07-22T07:52:50.000Z","path":"2017/07/22/[Java] 内部类访问外部类的变量为什么外部类的变量一定得是final类型/","text":"说在前面对这个问题困扰我很久，一直没真正理解，今天写篇博客记录以下。 到底为什么呢？内部类通常都含有回调，引用那个匿名内部类的函数执行完了就没了，所以内部类中引用外面的局部变量需要是final的，这样在回调的时候才能找到那个变量，而如果是外围类的成员变量就不需要是final的，因为内部类本身都会含有一个外围了的引用（外围类.this），所以回调的时候一定可以访问到。例如： 12345678910private Animator createAnimatorView(final View view, final int position) &#123; MyAnimator animator = new MyAnimator(); animator.addListener(new AnimatorListener() &#123; @Override public void onAnimationEnd(Animator arg0) &#123; Log.d(TAG, \"position=\" + position); &#125; &#125;); return animator;&#125; 内部类回调里访问position的时候createAnimatorView()早就执行完了，position如果不是final的，回调的时候肯定就无法拿到它的值了，因为局部变量在函数执行完了以后就被回收了。 参考资料本文参考自匿名内部类为什么访问外部类局部变量必须是final的？。","tags":[{"name":"Java, 内部类, final","slug":"Java-内部类-final","permalink":"https://glemontree.github.io/tags/Java-内部类-final/"}]},{"title":"[Struts2] 拦截器和过滤器","date":"2017-07-18T10:18:47.000Z","path":"2017/07/18/[Struts2] 拦截器和过滤器/","text":"本文转载自博客过滤器和拦截器的区别。","tags":[{"name":"Struts2, 拦截器, 过滤器","slug":"Struts2-拦截器-过滤器","permalink":"https://glemontree.github.io/tags/Struts2-拦截器-过滤器/"}]},{"title":"[Struts2] 日期类型转换","date":"2017-07-18T09:51:51.000Z","path":"2017/07/18/[Struts2] 日期类型转换/","text":"我们在进行web开发时经常会用到Date类型的数据，比如有一个员工类，其含有一个Date类型的birthday和joinDate，当我们在页面上通过&lt;input&gt;标签输入日期时，由于输入的类型是String类型，而员工类的成员变量是Date类型，那么就会抛出异常java.text.ParseException: Unparseable date: &quot;2014-06-10&quot;，此时需要定义了日期类型转换器，用于将String类型的日期转换为Date类型的日期，具体操作可参考下面这篇博文：Struts2日期类型转换。","tags":[{"name":"Struts2, 自定义日期类型转换","slug":"Struts2-自定义日期类型转换","permalink":"https://glemontree.github.io/tags/Struts2-自定义日期类型转换/"}]},{"title":"[Struts2] pageContext.request.contextPath","date":"2017-07-15T05:53:56.000Z","path":"2017/07/15/[Struts2] pageContext.request.contextPath/","text":"为了解决不同部署方式的差别，在所有非struts标签的路径前面加${pageContext.request.contextPath}，如原路径为”/images/title.gif“，改为”${pageContext.request.contextPath}/images/title.gif“，代码${pageContext.request.contextPath}的作用是取出部署的应用程序名，这样不管如何部署，所有路径都是正确的。","tags":[{"name":"Struts2, 路径","slug":"Struts2-路径","permalink":"https://glemontree.github.io/tags/Struts2-路径/"}]},{"title":"[Struts2] Struts2接受参数的几种类型和接受复杂类型参数","date":"2017-07-12T03:39:20.000Z","path":"2017/07/12/[Struts2] Struts2接受参数的几种类型和接受复杂类型参数/","text":"【转载】Struts2接受参数的几种类型和接受复杂类型参数","tags":[{"name":"Struts2, 复杂参数","slug":"Struts2-复杂参数","permalink":"https://glemontree.github.io/tags/Struts2-复杂参数/"}]},{"title":"[Android] 百度地图API Android相关配置教程（包含获取包名、发布版SHA1和开发版SHA1）","date":"2017-07-10T09:51:38.000Z","path":"2017/07/10/[Android] 百度地图API Android相关配置教程（包含获取包名、发布版SHA1和 开发版SHA1）/","text":"声明本篇文章转载自Moment__格调的博客，作者写的十分详细，对于进行Android的百度地图开发很有帮助，感谢作者的分享！ 主要内容本篇相较于当前（2017.6.18）百度地图开放平台上的开发指南更为全面 新版百度地图API相较于旧版增加了发布版SHA1， 开发版SHA1按官方教程操作即可，本篇来仔细介绍一下发布版SHA1、开发版SHA1和包名的获取方法。本文基于Android Studio来获取 登录百度账号 登录百度开发者平台登陆百度开发者平台后，点击页面上的”申请密钥” 然后会跳转到API控制台服务，具体如下图： 创建应用点击”创建应用”，进入创建AK页面，输入应用名称，将应用类型改为：“Android SDK”： 配置应用在应用类型选为“Android SDK”后，需要配置应用的安全码，如下图所示： 获取安全码安全码的组成规则为：Android签名证书的sha1值+packagename例如： SHA1：BB:0D:AC:74:D3:21:E1:43:67:71:9B:62:91:AF:A1:66:6E:44:5D:75包名：com.baidumap.demoAndroid应用获取包名packagename，根据开发工具不同，获取位置有所不同1、使用 eclipse 开发包名是Android应用程序本身在AndroidManifest.xml 中定义的名称，例如： 2、使用 Android studio 创建一个新的包名包名的获取首先在存储盘中创建一个文件夹用来保存后面所要创建的相关内容 打开Android Studio软件，创建一个新的工程：File&gt;New&gt;New Project 然后一直默认点击 Next ，最后是点击Fisish。点击完Fisish后等待两秒后会出现如下界面： 直接点击OK，应用就创建完成了，然后按下图来选择包名： 复制所获取的包名到“百度地图开放平台”创建应用列表下的包名输入框内。 Android签名证书的发布版sha1值获取方式：（1）：为apk签名，生成keystore文件（如果已经有keystore文件，跳过此步骤）第一步： Build —&gt;&gt; Generate Signed APK 第二步：Create New 第三步：填写相关信息，里面内容什么含义自行Google （填写方法） Paste_Image.png 填写完成后点击0K,然后就会发现如下图中Key store path已经选择完成： 然后按下图所示填写其他内容 第四步：输入密码 第五步：选择发布app的路径默认即可 选择release方式发布（其实这一步我没有完成，因为点击Build Type后下拉列表中什么选项都没有，所有没有办法点击Finish按钮,不过这没有什么影响，因为我们所要创建的.jks文件已经创建完成） 以上步骤完成后，运行进入控制台程序 输入cd .android，定位文件夹到.andorid下，默认路径是users/用户名/.[Android] (http://lib.csdn.net/base/android)输入keytool -list -v -keystore .jks，.jks为keystore文件路径，例如我的keystore文件路径是H:\\myTest\\myText.jks，那么我输入的是keytool -list -v -keystore H:\\myTest\\myText.jks 上图中SHA1就是所有获取的发布版SHA1。Android签名证书的开发版sha1值获取方式有两种：第一种方法：使用keytool第1步：运行进入控制台 第2步：定位到.android文件夹下，输入cd .android 第3步：输入keytool -list -v -keystore debug.keystore，会得到三种指纹证书，选取SHA1类型的证书（密钥口令是android），例如：其中keytool为jdk自带工具；keystorefile为Android 签名证书文件 第二种方法：在eclipse中，在adt 22中直接查看如果使用adt 22，可以在eclipse中直接查看：windows -&gt; preferance -&gt; android -&gt; build。 如下图示： 其中“SHA1 fingerprint”值即为Android签名证书的开发版sha1值。 将以上获取到的“包名”、“开发版SHA1”、“发布版SHA1”填入百度开放平台就可以了","tags":[{"name":"Android, 百度地图","slug":"Android-百度地图","permalink":"https://glemontree.github.io/tags/Android-百度地图/"}]},{"title":"[Struts2] 值栈","date":"2017-07-10T03:51:01.000Z","path":"2017/07/10/[Struts2] 值栈/","text":"ValueStack（值栈） 贯穿整个Action的生命周期，每个Action类的对象实例都拥有一个ValueStack对象，相当于一个数据的中转站，在其中保存当前Action对象和其他相关对象 Struts框架把ValueStack对象保存在名为”struts.valueStack”的请求属性中 在ValueStack对象的内部有两个逻辑部分： context：ContextMap（Map栈实际上是OgnlContext类型，是一个Map，也是对ActionContext的一个引用） Struts把各种各样的映射关系（一些Map类型的对象）压入ContextMap中，实际上是对ActionContext的一个引用。Struts会把下面这些映射压入到ContextMap中： parameters：该Map中包含当前请求的请求参数 request：该Map中包含当前request对象中的所有属性 session：该Map中包含当前session对象的所有属性 application：该Map中包含当前application对象中的所有属性 attr：该Map按如下顺序检索某个属性：request、session、application root：ObjectStack（对象栈，实际上是CompoundRoot类型，是一个使用ArrayList定义的栈，里面保存各种和当前Action实例相关的对象，是一个数据结构意义的栈） Struts把Action和相关对象压入ObjectStack中。 在JSP页面上可以使用OGNL（Object-Graph-Navigation-Language：对象-图导航语言）访问到值栈中的对象属性 若希望访问到ContextMap中的数据，需要给OGNL表达式加上一个前缀字符#，如果没有前缀字符，搜索将在ObjectStack里进行 可以从ActionContext中获取值栈对象","tags":[{"name":"Struts2, 值栈","slug":"Struts2-值栈","permalink":"https://glemontree.github.io/tags/Struts2-值栈/"}]},{"title":"[Struts2] page、request、session、application的区别","date":"2017-07-10T03:49:44.000Z","path":"2017/07/10/[Struts2] page、request、session、application的区别/","text":"page page指当前页面，在一个jsp页面中有效 request request值从http请求到服务器处理结束，返回响应的整个过程，在这个过程中使用forward方式跳转多个jsp，在这些页面里都可以使用这个变量 session 当前会话中有效，从浏览器打开到浏览器关闭这个过程，每个用户都有唯一的一个 application 它的有效范围是整个应用，作用域里的变量它们的存活时间是最长的，如果不进行手工删除，它们就一直可以使用。","tags":[{"name":"Struts2","slug":"Struts2","permalink":"https://glemontree.github.io/tags/Struts2/"}]},{"title":"[Struts2] 配置Struts可以受理的请求的扩展名","date":"2017-07-10T03:45:57.000Z","path":"2017/07/10/[Struts2] 配置Struts可以受理的请求的扩展名/","text":"在工程目录的Web App Libraries目录下的struts2-core-2.3.15.jar下的org.apache.struts2下的default.properties文件下定义了Struts可以受理的请求的扩展名：struts.action.extension=action,,，表示Struts可以受理扩展名为.action和没有扩展名的请求 若想更改Struts可以受理的请求的扩展名可以在struts.xml文件中添加下面这行代码： 12&lt;!-- 配置Struts可以受理的请求的扩展名 --&gt;&lt;constant name=\"struts.action.extension\" value=\"action,do,\"&gt;&lt;/constant&gt; 此时struts可以受理扩展名为.action，.do和不加扩展名的请求。","tags":[{"name":"Struts2, 扩展名","slug":"Struts2-扩展名","permalink":"https://glemontree.github.io/tags/Struts2-扩展名/"}]},{"title":"[Spring] Spring配置文件头部xmlns配置","date":"2017-07-06T11:41:32.000Z","path":"2017/07/06/[Spring] Spring配置文件头部xmlns配置/","text":"刚开始学习Spring或许都对其配置文件头部的各种配置表示困惑，先贴出一个比较常见的头部文件 1234567891011&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:aop=\"http://www.springframework.org/schema/aop\" xmlns:tx=\"http://www.springframework.org/schema/tx\" xmlns:context=\"http://www.springframework.org/schema/context\" xsi:schemaLocation=\" http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-3.0.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-3.0.xsd http://www.springframework.org/schema/context &lt;a href=\"http://www.springframework.org/schema/context/spring-context-3.0.xsd\"&gt;http://www.springframework.org/schema/context/spring-context-3.0.xsd&lt;/a&gt;\" &gt; 对于使用spring的朋友，对这些应该再熟悉不过了，使用spring1年多了，今天偶尔间总算知道这些配置文件是干什么的了，spring2.0以前的版本是基于dtd的配置方式，之后的版本开始支持schema的配置，dtd的配置当bean属性太多或者复杂的时候，就会显得臃肿，这时就可以采用schema来精简一下了。 要使用schema就要引入相关的schema了，而上述的头部配置，观察下相应大家应该明白都引入了什么了，分别是aop tx context的引入，没错，头部这么一大串其实就是引入要使用的schema配置 文件。 本文转载自文章。","tags":[{"name":"Spring","slug":"Spring","permalink":"https://glemontree.github.io/tags/Spring/"}]},{"title":"[Struts2] 国际化","date":"2017-07-06T09:08:51.000Z","path":"2017/07/06/[Struts2] 国际化/","text":"概述在程序设计领域，把在无需改写源代码即可让开发出来的程序能够支持多种语言和数据格式的技术称为国际化。 与国际化对应的是本地化，指让一个具备国际化支持的应用程序支持某个特定的地区。 Struts2国际化是建立在Java国际化基础上的： 为不同国家/地区提供对应的消息资源文件 Struts2框架会根据请求中包含的Locale加载对应的资源文件 通过程序代码取得资源文件中指定key对应的消息 国际化目标 配置国际化资源文件 Action范围资源文件：在Action类文件所在的路径建立名为ActionName_language_country.properties的文件 包范围资源文件：在包的根路径下建立文件名为package_language_country.properties的属性文件，一旦建立，处于该包下的所有Action都可以访问该资源文件，注意：包范围资源文件的baseName就是package，不是Action所在的包名 全局资源文件 命名方式：basename_language_country.properties struts.xml：&lt;constant name=&quot;struts.custom.i18n.resources&quot; value=&quot;basename&quot;/&gt; 国际化资源文件加载的顺序：离当前Action较近的将被优先加载 一个项目中通常只要一个国际化资源文件，因此推荐使用全局资源文件 在页面上和Action类中访问国际化资源文件的value值 在Action类中，若Action类实现了TextProvider接口，则可以调用其getText()方法获取value值 通过继承ActionSupport的方式 页面上可以使用s:text标签，对于表单标签，可以使用表单标签的key属性值 若有占位符，则可以使用s:text标签的s:param子标签来填充占位符 可以利用标签和OGNL表达式直接访问值栈中的属性值，包括对象栈和Map栈 实现通过超链接切换语言 国际化举例JSP中国际化的使用 使用xhtml主题 1234567891011121314151617181920212223242526&lt;%@ page language=\"java\" contentType=\"text/html; charset=GB18030\" pageEncoding=\"GB18030\"%&gt; &lt;%@taglib uri=\"/struts-tags\" prefix=\"s\"%&gt;&lt;!DOCTYPE html PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\" \"http://www.w3.org/TR/html4/loose.dtd\"&gt;&lt;html&gt;&lt;head&gt;&lt;meta http-equiv=\"Content-Type\" content=\"text/html; charset=GB18030\"&gt;&lt;title&gt;Insert title here&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;s:debug&gt;&lt;/s:debug&gt; &lt;s:form action=\"\" &gt; &lt;!-- 若label标签使用%&#123;getText('username')&#125;的方式就也可以从国际化资源文件中获取value值 因为此时在对象栈中有defaultTextProvider的一个实例，该对象中提供了访问国际化资源文件的 getText()方法 同时还需要通知Struts2框架label中放入的不再是一个普通的字符串，而是一个OGNL表达式 --&gt; &lt;s:textfield name=\"username\" label=\"%&#123;getText('username')&#125;\"&gt;&lt;/s:textfield&gt; &lt;!-- key的方式是直接上国际化资源文件中获取value值 --&gt; &lt;s:textfield name=\"username\" key=\"username\"&gt;&lt;/s:textfield&gt; &lt;s:password name=\"password\" key=\"password\"&gt;&lt;/s:password&gt; &lt;s:submit key=\"submit\"&gt;&lt;/s:submit&gt; &lt;/s:form&gt;&lt;/body&gt;&lt;/html&gt; 当然，对于全局资源文件，需要在struts.xml文件中进行配置，如下： 12&lt;!-- 配置国际化资源文件 --&gt;&lt;constant name=\"struts.custom.i18n.resources\" value=\"i18n\"&gt;&lt;/constant&gt; 使用simple主题 123456789101112131415161718192021222324252627&lt;%@ page language=\"java\" contentType=\"text/html; charset=GB18030\" pageEncoding=\"GB18030\"%&gt; &lt;%@taglib uri=\"/struts-tags\" prefix=\"s\"%&gt;&lt;!DOCTYPE html PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\" \"http://www.w3.org/TR/html4/loose.dtd\"&gt;&lt;html&gt;&lt;head&gt;&lt;meta http-equiv=\"Content-Type\" content=\"text/html; charset=GB18030\"&gt;&lt;title&gt;Insert title here&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;s:debug&gt;&lt;/s:debug&gt; &lt;s:form action=\"\" theme=\"simple\"&gt; &lt;!-- 若label标签使用%&#123;getText('username')&#125;的方式就也可以从国际化资源文件中获取value值 因为此时在对象栈中有defaultTextProvider的一个实例，该对象中提供了访问国际化资源文件的getText()方法 同时还需要通知Struts2框架label中放入的不再是一个普通的字符串，而是一个OGNL表达式 --&gt; &lt;!--页面上可以直接使用&lt;s:text name=\"\" /&gt;来访问国际化资源文件里的value值--&gt; &lt;s:text name=\"username\"/&gt;:&lt;s:textfield name=\"username\" label=\"%&#123;getText('username')&#125;\"&gt;&lt;/s:textfield&gt; &lt;!-- key的方式是直接上国际化资源文件中获取value值 --&gt; &lt;s:text name=\"username\"/&gt;:&lt;s:textfield name=\"username\" key=\"username\"&gt;&lt;/s:textfield&gt; &lt;s:text name=\"password\"/&gt;:&lt;s:password name=\"password\" key=\"password\"&gt;&lt;/s:password&gt; &lt;s:submit key=\"submit\" value=\"%&#123;getText('submit')&#125;\"&gt;&lt;/s:submit&gt; &lt;/s:form&gt;&lt;/body&gt;&lt;/html&gt; 唯一的区别就是当使用simple主题时，表单标签的key属性不起作用，此时需要使用&lt;s:text&gt; 标签，其name属性为国际化资源文件中key的名字。 Action中国际化的使用123456789101112131415161718192021222324252627282930313233package com.glemontree.struts;import java.util.Arrays;import java.util.Date;import com.opensymphony.xwork2.ActionSupport;// 继承自ActionSupport就间接实现了TextProvider接口，可以调用getText()方法public class TestI18NAction extends ActionSupport &#123; private static final long serialVersionUID = 1L; private Date date = null; public Date getDate() &#123; return date; &#125; public void setDate(Date date) &#123; this.date = date; &#125; @Override public String execute() throws Exception &#123; date = new Date(); // 在Action中访问国际化资源文件的value值 String username = getText(\"username\"); System.out.println(username); // 带占位符 String time = getText(\"time\", Arrays.asList(date)); System.out.println(time); return super.execute(); &#125;&#125; 通过上面的代码知道，在Action中访问国际化资源的方式是使用getText()方法，当然，前提是Action需要继承自ActionSupport，因为ActionSupport实现了TextProvider接口。 上面的程序中也示范了怎么在Action中访问国际化资源文件中带占位符的资源，那么如何在JSP文件中访问国际化资源文件中带占位符的资源呢？ 123&lt;s:text name=\"time\"&gt; &lt;s:param value=\"date\"&gt;&lt;/s:param&gt;&lt;/s:text&gt; 正如上面所述，需要在&lt;s:text&gt;中通过子标签&lt;s:param&gt; 指定占位符的取值，当然这里的date是值栈中的值。 利用超链接实现动态加载国际化资源文件 Struts2使用i18n拦截器处理国际化，并且将其注册在默认的拦截器栈中 i18n拦截器在执行Action方法前，自动查找请求中一个名为request_locale的参数，如果该参数存在，拦截器就将其作为参数，转换成Locale对象，并将其设为用户默认的Locale，并将其设置为session的WW_TRANS_I18N_LOCALE属性 若request没有名为request_locale的参数，则i18n拦截器会从Session中获取WW_TRANS_I18N_LOCALE的属性值，若该值不为空，则将该属性值设置为浏览器的默认Locale 若session中的WW_TRANS_I18N_LOCALE的属性值为空，则从ActionContext中获取Locale对象 具体实现如下： 12&lt;a href=\"testI18N.action?request_locale=en_US\"&gt;English&lt;/a&gt;&lt;a href=\"testI18N.action?request_locale=zh_CN\"&gt;中文&lt;/a&gt; 注意：超链接必须是一个Struts的请求，即使我们的i18n拦截器工作！错误代码如下： 12&lt;a href=\"i18n.jsp?request_locale=en_US\"&gt;English&lt;/a&gt;&lt;a href=\"i18n.jsp?request_locale=zh_CN\"&gt;中文&lt;/a&gt; 此时请求不会进入Action，自然也不会经过i18n拦截器，i18n拦截器不会工作。","tags":[{"name":"Struts2, 国际化","slug":"Struts2-国际化","permalink":"https://glemontree.github.io/tags/Struts2-国际化/"}]},{"title":"[Struts2] ModelDriven和Preparable拦截器","date":"2017-07-05T14:11:08.000Z","path":"2017/07/05/[Struts2] ModelDriven和Preparable拦截器/","text":"Struts2运行流程 ActionProxy是Action的一个代理类，也就是说Action的调用时通过ActionProxy实现的，其实就是调用了ActionProxy.execute()方法，而该方法又调用了ActionInvocation.invoke()方法 ActonInvocation就是Action的调用者，ActonInvocation在Action的执行过程中，负责Interceptor、Action和Result等一系列元素的调度 拦截器的调用顺序是在struts-default.xml文件中的defaultStack中进行定义的 Params拦截器Parameters拦截器将把表单字段映射到ValueStack栈的栈顶对象（此时栈顶对象即为Action）的各个属性中，如果某个字段在模型里没有匹配的属性，Param拦截器将尝试ValueStack栈的下一个对象。 把Action和Model隔开Action作为Controller，应当与Model隔离开，这才是MVC设计模式。 如果Action类实现了ModelDriven接口，该拦截器将把ModelDriven接口的getModel()方法返回的对象置于栈顶。 Action实现ModelDriven接口后的运行流程： 先会执行ModelDrivenInterceptor的intercept方法 123456789101112131415161718192021222324252627282930public String intercept(ActionInvocation invocation) throws Exception &#123; // 获取Action对象，即EmpolyeeAction对象，此时该Action已经实现了ModelDriven接口 // public class EmployeeAction implements RequestAware, ModelDriven&lt;Employee&gt; Object action = invocation.getAction(); // 判断Action是否是ModelDriven的实例 if (action instanceof ModelDriven) &#123; // 强制转换为ModelDriven类型 ModelDriven modelDriven = (ModelDriven) action; // 获取值栈 ValueStack stack = invocation.getStack(); // 调用ModelDriven接口的getModel()方法，即调用EmployeeAction的getModel()方法 /* @Override public Employee getModel() &#123; // TODO Auto-generated method stub employee = new Employee(); return employee; &#125; */ Object model = modelDriven.getModel(); if (model != null) &#123; // 把getModel()方法的返回值压入到值栈的栈顶，实际压入的是EmployeeAction的employee成员变量 stack.push(model); &#125; if (refreshModelBeforeResult) &#123; invocation.addPreResultListener(new RefreshModelBeforeResult(modelDriven, model)); &#125; &#125; return invocation.invoke();&#125; 执行ParametersInterceptor的intercept方法：把请求参数的值赋给栈顶对象对应的属性，若栈顶对象没有对应的属性，则查询值栈中下一个对象对应的属性 注意：getModel()方法不能提供以下实现，的确会返回一个Employee对象到值栈的栈顶，但当前Action的employee成员变量却是null： 12345@Overridepublic Employee getModel() &#123; // TODO Auto-generated method stub return new Employee();&#125; ​","tags":[{"name":"Struts2, ModelDriven, Preparable","slug":"Struts2-ModelDriven-Preparable","permalink":"https://glemontree.github.io/tags/Struts2-ModelDriven-Preparable/"}]},{"title":"[Struts2] 文件上传和下载","date":"2017-07-05T10:04:38.000Z","path":"2017/07/05/[Struts2] 文件上传和下载/","text":"表单准备要想使用HTML表单上传一个或多个文件： 需把HTML表单的enctype属性设置为multipart/form-data 需把HTML表单的method属性设置为post 需添加&lt;input type=&quot;file&quot;&gt;字段 Struts对文件上传的支持在Struts应用程序里，FileUpload拦截器和Commons FileUpload组件可以完成文件的上传。 步骤： 在jsp页面的文件上传表单里使用file标签，如果需要一次上传多个标签，就必须使用多个file标签，但他们的名字必须是相同的 在Action中新添加3个和文件上传相关的属性，提供对应的getter和setter方法，这3个属性的名字必须是以下格式： [FileName]：File-被上传的文件，例如data [FileName]ContentType：String-上传文件的文件类型，例如dataContentType [FileName]FileName：String-上传文件的文件名，例如dataFileName 如果上传多个文件，可以使用List 文件上传主要有以下一些知识点： Struts2的文件上传实际上使用的是Commons FileUpload组件，所以需要导入： commons-fileupload-1.3.jar commons-io-2.0.1.jar Struts2进行文件上传需要使用FileUpload拦截器 使用IO流进行文件的上传即可 12345678910111213141516171819202122@Overridepublic String execute() throws Exception &#123; // TODO Auto-generated method stub System.out.println(ppt); System.out.println(pptContentType); System.out.println(pptFileName); System.out.println(pptDesc); ServletContext servletContext = ServletActionContext.getServletContext(); String dir = servletContext.getRealPath(\"./\" + pptFileName); System.out.println(dir); FileOutputStream out = new FileOutputStream(dir); FileInputStream in = new FileInputStream(ppt); byte[] buffer = new byte[1024]; int len = 0; while ((len = in.read(buffer)) != -1) &#123; out.write(buffer, 0, len); &#125; out.close(); in.close(); return super.execute();&#125; 一次传多个文件 若传递多个文件，则上述的3个属性可以改为List类型，多个文件域的name属性值需要一致。 upload.jsp 12345678910111213141516171819202122&lt;%@ page language=\"java\" contentType=\"text/html; charset=GB18030\" pageEncoding=\"GB18030\"%&gt;&lt;%@taglib uri=\"/struts-tags\" prefix=\"s\" %&gt;&lt;!DOCTYPE html PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\" \"http://www.w3.org/TR/html4/loose.dtd\"&gt;&lt;html&gt;&lt;head&gt;&lt;meta http-equiv=\"Content-Type\" content=\"text/html; charset=GB18030\"&gt;&lt;title&gt;Insert title here&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;s:form action=\"testUpload\" method=\"post\" enctype=\"multipart/form-data\"&gt; &lt;s:file name=\"ppt\" label=\"PPTFile\"&gt;&lt;/s:file&gt; &lt;!--为了使得textField回显不出问题，这里需要使用下标，因为pptDesc是List类型--&gt; &lt;s:textfield name=\"pptDesc[0]\" label=\"PPTDesc\"&gt;&lt;/s:textfield&gt; &lt;s:file name=\"ppt\" label=\"PPTFile\"&gt;&lt;/s:file&gt; &lt;s:textfield name=\"pptDesc[1]\" label=\"PPTDesc\"&gt;&lt;/s:textfield&gt; &lt;s:file name=\"ppt\" label=\"PPTFile\"&gt;&lt;/s:file&gt; &lt;s:textfield name=\"pptDesc[2]\" label=\"PPTDesc\"&gt;&lt;/s:textfield&gt; &lt;s:submit&gt;&lt;/s:submit&gt; &lt;/s:form&gt;&lt;/body&gt;&lt;/html&gt; struts.xml 123456789101112131415&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE struts PUBLIC \"-//Apache Software Foundation//DTD Struts Configuration 2.3//EN\" \"http://struts.apache.org/dtds/struts-2.3.dtd\"&gt;&lt;struts&gt;&lt;!-- 打开静态方法的限制 --&gt; &lt;package name=\"default\" namespace=\"/\" extends=\"struts-default\"&gt; &lt;action name=\"testUpload\" class=\"com.glemontree.struts.UploadAction\" method=\"execute\"&gt; &lt;result&gt;/success.jsp&lt;/result&gt; &lt;!-- 回显 --&gt; &lt;result name=\"input\"&gt;/upload.jsp&lt;/result&gt; &lt;/action&gt; &lt;/package&gt;&lt;/struts&gt; 可以对文件的大小、类型、扩展名等进行限制，可以通过配置FileUploadInterceptor拦截器的参数的方式来进行限制，有以下几个参数： maximumSize（上传的单个文件的大小，单位是字节，默认最大值为2M） allowedTypes（允许的类型，使用逗号分隔） allowedExtensions（允许的上传文件扩展名，多个使用逗号分隔） 123456789101112131415161718192021222324&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE struts PUBLIC \"-//Apache Software Foundation//DTD Struts Configuration 2.3//EN\" \"http://struts.apache.org/dtds/struts-2.3.dtd\"&gt;&lt;struts&gt; &lt;package name=\"default\" namespace=\"/\" extends=\"struts-default\"&gt; &lt;interceptors&gt; &lt;interceptor-stack name=\"glemontreestack\"&gt; &lt;interceptor-ref name=\"defaultStack\"&gt; &lt;param name=\"fileUpload.maximumSize\"&gt;2000&lt;/param&gt; &lt;param name=\"fileUpload.allowedTypes\"&gt;text/html,text/xml&lt;/param&gt; &lt;param name=\"fileUpload.allowedExtensions\"&gt;html,dtd,xml&lt;/param&gt; &lt;/interceptor-ref&gt; &lt;/interceptor-stack&gt; &lt;/interceptors&gt; &lt;!-- 配置使用这个拦截器栈 --&gt; &lt;default-interceptor-ref name=\"glemontreestack\"&gt;&lt;/default-interceptor-ref&gt; &lt;action name=\"testUpload\" class=\"com.glemontree.struts.UploadAction\" method=\"execute\"&gt; &lt;result&gt;/success.jsp&lt;/result&gt; &lt;result name=\"input\"&gt;/upload.jsp&lt;/result&gt; &lt;/action&gt; &lt;/package&gt;&lt;/struts&gt; Struts文件下载 Struts2中使用type=”stream”的result进行下载即可 具体使用细节请查看Struts2文档 可以为stream的result设定如下参数： contentType - the stream mime-type as sent to the web browser (default = text/plain). contentLength - the stream length in bytes (the browser displays a progress bar). contentDisposition - the content disposition header value for specifing the file name (default = inline, values are typically attachment;filename=”document.pdf”.(设定Content-Disposition响应头，该响应头指定是一个文件下载类型，一般取值为attachment;filename=”document.pdf”) inputName - the name of the InputStream property from the chained action (default = inputStream).(指定文件输入流的getter定义的那个属性的名字，默认为inputStream) bufferSize - the size of the buffer to copy from input to output (default = 1024). allowCaching if set to ‘false’ it will set the headers ‘Pragma’ and ‘Cache-Control’ to ‘no-cahce’, and prevent client from caching the content. (default = true) contentCharSet if set to a string, ‘;charset=value’ will be added to the content-type header, where value is the string set. If set to an expression, the result of evaluating the expression will be used. If not set, then no charset will be set on the header 前面三个成员的值可以通过在Action中动态指定，后面三个的值可以在struts.xml文件中静态指定。 以上参数可以在Action中以getter方法的方式提供，动态指定参数的值 举例 struts.xml 12345&lt;action name=\"testDownload\" class=\"com.glemontree.struts.DownLoadAction\"&gt; &lt;result type=\"stream\"&gt; &lt;param name=\"bufferSize\"&gt;2048&lt;/param&gt; &lt;/result&gt;&lt;/action&gt; DownloadAction.java 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152package com.glemontree.struts;import java.io.FileInputStream;import java.io.InputStream;import javax.servlet.ServletContext;import org.apache.struts2.ServletActionContext;import com.opensymphony.xwork2.ActionSupport;public class DownLoadAction extends ActionSupport &#123; /** * */ private static final long serialVersionUID = 1L; private String contentType; private long contentLength; private String contentDisposition; private InputStream inputStream; public String getContentType() &#123; return contentType; &#125; public long getContentLength() &#123; return contentLength; &#125; public String getContentDisposition() &#123; return contentDisposition; &#125; public InputStream getInputStream() &#123; return inputStream; &#125; @Override public String execute() throws Exception &#123; // TODO Auto-generated method stub // 确定各个成员变量的值 contentType = \"text/html\"; contentDisposition = \"attachment;filename=hidden.html\"; ServletContext servletContext = ServletActionContext.getServletContext(); String fileName = servletContext.getRealPath(\"/hidden.html\"); inputStream = new FileInputStream(fileName); contentLength = inputStream.available(); return super.execute(); &#125;&#125; ​","tags":[{"name":"Struts2, 文件上传, 文件下载","slug":"Struts2-文件上传-文件下载","permalink":"https://glemontree.github.io/tags/Struts2-文件上传-文件下载/"}]},{"title":"[Struts2] OGNL s:iterator标签的使用","date":"2017-07-04T10:50:07.000Z","path":"2017/07/04/[Struts2] OGNL siterator标签的使用/","text":"简介iterator标签用来遍历一个数组、Collection或一个Map，并把这个可遍历对象的每一个元素一次压入和弹出。 例子为了搞清楚OGNL中s:iteraor标签的使用方法，这里举了一个例子： User.java 12345678910111213141516171819202122232425262728293031323334package com.glemontree.struts;public class User &#123; private String userName; private String password; private Integer age; public String getUserName() &#123; return userName; &#125; public void setUserName(String userName) &#123; this.userName = userName; &#125; public String getPassword() &#123; return password; &#125; public void setPassword(String password) &#123; this.password = password; &#125; public Integer getAge() &#123; return age; &#125; public void setAge(Integer age) &#123; this.age = age; &#125; public User() &#123; // TODO Auto-generated constructor stub &#125; public User(String userName, String password, Integer age) &#123; super(); this.userName = userName; this.password = password; this.age = age; &#125;&#125; IteratorTestAction.java 123456789101112131415161718192021222324package com.glemontree.struts;import java.util.ArrayList;import java.util.List;public class IteratorTestAction &#123; User user; public User getUser() &#123; return user; &#125; public void setUser(User user) &#123; this.user = user; &#125; public String execute() &#123; user = new User(); user.setUserName(\"aaa\"); user.setPassword(\"123\"); user.setAge(23); return \"success\"; &#125;&#125; 这是一个Action类，类中含有一个User对象。 index.jsp 123456789101112&lt;%@ page language=\"java\" contentType=\"text/html; charset=GB18030\" pageEncoding=\"GB18030\"%&gt;&lt;!DOCTYPE html PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\" \"http://www.w3.org/TR/html4/loose.dtd\"&gt;&lt;html&gt; &lt;head&gt; &lt;meta http-equiv=\"Content-Type\" content=\"text/html; charset=GB18030\"&gt; &lt;title&gt;Insert title here&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;a href=\"IteratorTestAction.action\"&gt; Iterator Test &lt;/a&gt; &lt;/body&gt;&lt;/html&gt; struts.xml 12345678910111213&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE struts PUBLIC \"-//Apache Software Foundation//DTD Struts Configuration 2.3//EN\" \"http://struts.apache.org/dtds/struts-2.3.dtd\"&gt;&lt;struts&gt; &lt;!-- 打开静态方法的限制 --&gt; &lt;package name=\"default\" namespace=\"/\" extends=\"struts-default\"&gt; &lt;action name=\"IteratorTestAction\" class=\"com.glemontree.struts.IteratorTestAction\"&gt; &lt;result&gt;/details.jsp&lt;/result&gt; &lt;/action&gt; &lt;/package&gt;&lt;/struts&gt; details.jsp 测试一 12OGNL：&lt;s:property value=\"user.age\"/&gt;&lt;br&gt;EL表达式：$&#123;user.age &#125; 因为IteratorTestAction.java类中含有一个User对象，因此值栈中也含有user对象，因此既可以通过OGNL，也可以通过EL表达式获取到user.age属性。 该测试结果为： 123测试一：OGNL：23 EL表达式：23 测试二 1234567891011121314&lt;% List&lt;User&gt; users = new ArrayList&lt;User&gt;(); users.add(new User(\"aaa\",\"123\",12)); users.add(new User(\"bbb\",\"456\",13)); users.add(new User(\"ccc\",\"789\",14)); users.add(new User(\"ddd\",\"130\",15)); users.add(new User(\"eee\",\"458\",16)); request.setAttribute(\"users\", users);%&gt;&lt;s:iterator value=\"#request.users\"&gt; &lt;s:debug&gt;&lt;/s:debug&gt; $&#123;userName &#125;&lt;br&gt; &lt;s:property value=\"userName\"/&gt;&lt;/s:iterator&gt; 首先定义了一个List类型的对象users，并且王users里面添加了几个值，紧接着使用&lt;s:iterator&gt;标签对List进行操作，&lt;s:iterator&gt;的value属性表示集合。 这里为了看清每次遍历过程中值栈的状态，在&lt;s:iterator&gt;中加入了&lt;s:debug&gt;标签，运行结果如下： 12345678910111213141516171819[Debug] aaa [Debug] bbb [Debug] ccc [Debug] ddd [Debug] eee 点击其中一个[Debug]标签，结果如下： 可见正如上面所说，在每次迭代过程中都会将当前的元素压入值栈。 ​ ​","tags":[{"name":"Struts2, OGNL","slug":"Struts2-OGNL","permalink":"https://glemontree.github.io/tags/Struts2-OGNL/"}]},{"title":"[Servlet] Java Web乱码","date":"2017-07-01T06:21:31.000Z","path":"2017/07/01/[Servlet] Java Web乱码/","text":"乱码先看一个简单的例子： 12345protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; OutputStream out = response.getOutputStream(); String data = \"中文\"; out.write(data.getBytes(\"utf-8\"));&#125; 当访问时界面输出乱码，这主要是因为程序用UTF-8编码，而浏览器默认采用GBK解码。 其实乱码问题出现的根本原因也就是编码和解码不一致产生的。 常见的编码 UTF-8：国际编码 GBK：中文编码，是GB2312的扩展，除了兼容GB2312外，还能显示繁体中文、还有日文的假名 ISO8859-1：tomcat默认，不支持中文 通过浏览器调用Servlet，页面显示乱码response乱码解决方法：response.setContentType(&quot;text/html;charset=utf-8&quot;);或者response.setHeader(&quot;content-type&quot;, &quot;text/html;charset=utf-8&quot;); 原理：告诉浏览器用utf-8进行解析。 看下面两种情况： 情况一 问题代码如下： 123OutputStream out = response.getOutputStream();String data = \"博客\";out.write(data.getBytes(\"UTF-8\")); 乱码流程图 解决方案流程图 情况二 问题代码如下： 12345protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; PrintWriter out = response.getWriter(); String data = \"博客\"; out.println(data);&#125; 浏览器输出的结果为？？ 这是因为“博客”首先被封装在response对象中，因为IE和WEB服务器之间不能传输文本，然后就通过ISO-8859-1编码进行编码，但是ISO-8859-1中没有“博客”的编码，因此输出“？？”，表示没有编码。 错误代码流程图 解决方案流程图 request乱码问题 POST请求 乱码流程图 解决方案 ​ GET请求 问题本质是get方式传递的参数内容默认编码方式为ISO-8895-1，而且使用request.setCharacterEncoding(“utf-8”)也无法解决问题，现提供一种解决方法如下： 1String usernameString = new String(username.getBytes(\"ISO-8859-1\"),\"UTF-8\"); 即先将字符串用ISO-8859-1编码成字节数组，然后用UTF-8编码将字节数组转换成字符串输出。 流程图如下： 参考本文主要图片和内容来自博客。","tags":[{"name":"Java, Servlet, 乱码","slug":"Java-Servlet-乱码","permalink":"https://glemontree.github.io/tags/Java-Servlet-乱码/"}]},{"title":"[Servlet] HttpServletRequest","date":"2017-06-30T12:39:30.000Z","path":"2017/06/30/[Servlet] HttpServletRequest/","text":"HTTP请求消息和HTTP响应消息一样，也分为三部分，分别是请求行、请求消息头、消息正文。 获取请求行消息HTTP请求信息中的第一行为请求行，格式如下： GET /webdemo/servlet/HelloWorld?name=bill&amp;age=52 HTTP/1/1 上面的请求行分为三部分，分别是请求方式（GET、POST、HEAD等）、资源路径和HTTP协议版本。 HttpServletRequest接口中定义了很多方法获取请求行中各部分的消息： 方法名 功能 值 getMethod 返回请求行中的请求方法（GET、POST、HEAD、PUT、DELETE） GET getRequestURI 返回请求行中的资源部分（不包含参数） /webdemo/servlet/HelloWorld getQueryString 返回请求行中的参数部分，也就是资源路径后面的“？”以后的所有内容，如果没有参数部分，返回null name=bill&amp;age=52 getProtocol 返回请求行中的协议部分 HTTP/1.1 getContextPath 返回Web应用程序的上下文路径 /webdemo getServletPath 返回web.xml中&lt;url-pattern&gt;标签定义的Servlet映射路径 /servlet/HelloWorld getParameter 返回某一个参数的值，如获得name参数值得代码是getParameter(“name”) bill 获取网络连接消息为了获取客户端和服务器与网络连接有关的信息，主要有以下一些方法： 方法名 功能 返回值 getRemoteAddr 返回客户机用于发送请求的IP地址 192.168.18.10 getRemoteHost 返回发出请求的客户机的主机名，如果Servlet无法解析，则返回客户机的IP 192.168.181.0 getRemotePort 返回客户机所使用的网络接口的端口号（这个值是由客户机的网络接口随机分配的） 1065 getLocalAddr 返回Web服务器上接收请求的网络接口使用的IP地址 192.168.18.254 getLocalName 返回Web服务器上接收请求的网络接口使用的IP地址对应的主机名 webserver getLocalPort 返回Web服务器上接收请求的网络接口的端口号 8080 getServerName 返回HTTP请求消息的Host字段的值的主机名部分 localhost getServerPort 返回HTTP请求消息的Host字段的值的端口号部分 8080 getScheme 返回请求的协议名，如http、https http getRequestURL 返回完整的请求URL（不包含参数部分），这个方法返回的是StringBuffer类型，而不是String类型 http://localhost:8080/webdemo/servlet/HelloWorld","tags":[{"name":"Servlet HttpServletRequest","slug":"Servlet-HttpServletRequest","permalink":"https://glemontree.github.io/tags/Servlet-HttpServletRequest/"}]},{"title":"[Servlet] HttpServletResponse","date":"2017-06-30T11:57:21.000Z","path":"2017/06/30/[Servlet] HttpServletResponse/","text":"产生状态响应码当客户端浏览器请求服务器时，该服务器就会将返回消息封装到HttpServletResponse里进行响应，返回消息中的第一行为状态行：HTTP/1.1 200 OK。 上面的状态行分为三部分，分别是HTTP版本（HTTP/1.1）、状态响应码（200）以及状态消息（OK），HTTP协议的状态响应码为3位正整数： 100-199：表示服务器成功接收请求，但要求客户端继续提交下一次请求才能完成全部处理过程 200-299：表示服务器已成功接收请求，并完成了全部处理过程 300-399：表示客户端请求的资源已经移到了别的位置，并向客户端提供了一个新的地址，一般这个新地址由HTTP响应消息头的Location字段指定 400-499：表示客户端的请求有错误 500-599：表示服务端有错误 设置状态响应码有以下几种方法： 设置状态响应码setStatus方法 setStatus()方法可以设置HTTP响应消息的任何状态响应码，并生成响应状态行，由于响应状态行中的协议版本和状态消息是由服务端决定的，因此只要设置响应状态码即可： 1public void setStatus(int sc); 其中sc表示状态响应码，它可以直接使用整数表示，也可以使用HttpServletRequest中定义的常量，如200的常量为HttpServletRequest.SC_OK 302状态响应码的具体应用sendRedirect方法 该状态码可以实现客户端重定向到URL（由HTTP响应消息头的Location字段指定的地址），sendRedirect方法如下： 1public void sendRedirect(String location) throws IOException; 通过sendRedirect方法可以将当前的Servlet重定向到其他的URL上，这个URL可以是绝对的，也可以是相对的。 400-599状态响应码的具体应用sendError方法 sendError方法用于发送表示错误信息的状态响应码，而且还可以设置状态消息： 12public void sendError(int sc) throws IOException;public void sendError(int sc, String msg) throws IOException; 设置响应消息头返回信息中状态行下面的内容就是响应消息头，响应消息头由字段和字段值组成，在HttpServletReponse中有很多设置响应消息头的方法，比如addHeader()、setHeader()等等。addHeader()、setHeader()的不同点在于如果name所指的字段名已经存在，setHeader()方法会用value来覆盖旧的字段值，而addHeader()方法会增加一个同名的字段，因为HTTP响应消息头是允许同时存在多个同名的字段的。","tags":[{"name":"Servlet HttpServletResponse","slug":"Servlet-HttpServletResponse","permalink":"https://glemontree.github.io/tags/Servlet-HttpServletResponse/"}]},{"title":"[Struts2] Action类","date":"2017-06-29T11:22:10.000Z","path":"2017/06/29/[Struts2] Struts配置文件/","text":"action与Action类 action 代表一个Struts2请求 Action类 能够处理Struts2请求的类就是Action类，Action类具有以下特点： 属性的名字必须遵守与JavaBean属性名相同的命名规则，属性的类型可以是任意类型，属性名字(get set方法对应的属性名字)应当与表单发请求时对应的参数名字相对应 必须有一个不带参的构造函数（反射） 至少有一个供struts在执行这个action时调用的方法 同一个Action类可以包含多个action方法 Struts为每一个Http请求创建一个新的Action实例，即Action不是单例的，是线程安全的 Action中访问WEB资源 什么是WEB资源 HttpServletRequest、HttpSession、ServletContext等原生的Servlet API 为什么需要访问WEB资源 B/S应用的Controller中必然需要访问WEB资源，比如向域对象中读写属性，读写cookie，获取realPath… 如何访问 和Servlet API解耦的方式 只能访问有限的Servlet API对象，只能访问其有限的方法（读取请求参数，读写域对象的属性，使session失效…）。 Struts2对HttpServletRequest、HttpSession、ServletContext进行了封装，构造了3个Map对象来替代这3个对象，在Action中可以直接调用HttpServletRequest、HttpServletSession、ServletContext对应的Map对应来保存和读取数据。 使用ActionContext ActionContext是Action执行的上下文对象，在ActionContext中保存了Action执行所需要的所有对象，包括parameters、request、session、application等 获取HttpSession对应的Map对象 public Map getSession() 获取ServletContext对应的Map对象 public Map getApplication() 获取请求参数对应的Map对象 public Map getParameters() 获取HttpServletRequest对应的Map对象 public Object get(Object key)：ActionContext类中没有提供类似getRequest()这样的方法获取HttpServletRequest对应的Map对象，要得到HttpServletRequest对应的Map对象，可以通过get()方法传递”request”参数实现 举例如下： 12345678910111213141516171819202122232425262728293031323334353637383940package com.glemontree.struts2;import java.util.Map;import com.opensymphony.xwork2.ActionContext;public class TestActionContextAction &#123; public String execute() &#123; // 获取ActionContext对象 ActionContext actionContext = ActionContext.getContext(); // 1.获取Application对应的Map，并向其中添加一个属性 // 通过调用ActionContext的getApplication方法来获取application对应的Map对象 Map&lt;String, Object&gt; applicationMap = actionContext.getApplication(); // 设置属性 applicationMap.put(\"applicationkey\", \"applicationValue\"); // 获取属性 Object date = applicationMap.get(\"date\"); System.out.println(\"date: \" + date); // 2.获取Session对应的Map，并向其中添加一个属性 Map&lt;String, Object&gt; sessionMap = actionContext.getSession(); sessionMap.put(\"sessionKey\", \"sessionValue\"); // 3.获取Request对应的Map，并向其中添加一个属性 // ActionContext中并没有提供getRequest()方法来获取request对应的Map，需要手工调用get()方法，传入request字符串来获取 Map&lt;String, Object&gt; requestMap = (Map&lt;String, Object&gt;) actionContext.get(\"request\"); requestMap.put(\"requestKey\", \"requestValue\"); // 4.获取请求参数对应的Map，并获取指定的参数值 // 键：请求参数的名字 值：请求参数的值对应的字符串数组 // 注意：getParameteres()的返回值为Map&lt;String, Object&gt;，而不是Map&lt;String, String[]&gt; // 另外，parameters这个Map只能读，不能写入数据，如果写入，但不会报错，但也不起作用 Map&lt;String, Object&gt; parameters = actionContext.getParameters(); System.out.println(((String[])parameters.get(\"name\"))[0]); parameters.put(\"age\", 100); return \"success\"; &#125;&#125; 上面这段代码主要有以下一些注意点： 为了在Action中获取ActionContext，需要通过ActionContext的静态方法getContext()来获取 对于applicationMap、sessionMap以及parameters均可以通过对应的getXXX方法获取Map对象，唯独requestMap不可以直接通过getRequest()方法来获得，而必须通过get(“request”)方法来获得requestMap applicationMap、sessionMap以及requestMap均可以向其中写入数据，然后从jsp中读取出来，但是parameters只能读取而不能写入数据 在jsp中读取前面写入的值的方法如下： 12345678910111213141516171819&lt;%@ page language=\"java\" contentType=\"text/html; charset=GB18030\" pageEncoding=\"GB18030\"%&gt;&lt;!DOCTYPE html PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\" \"http://www.w3.org/TR/html4/loose.dtd\"&gt;&lt;html&gt; &lt;head&gt; &lt;meta http-equiv=\"Content-Type\" content=\"text/html; charset=GB18030\"&gt; &lt;title&gt;Insert title here&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h4&gt; Test ActionContext Page&lt;/h4&gt; application: $&#123;applicationScope.applicationkey &#125; &lt;br&gt;&lt;br&gt; session: $&#123;sessionScope.sessionKey &#125; &lt;br&gt;&lt;br&gt; request: $&#123;requestScope.requestKey &#125; &lt;br&gt;&lt;br&gt; age: $&#123;parameters.age &#125; &lt;/body&gt;&lt;/html&gt; 注意：与范围相关的EL隐含对象包含4个：pageScope、requestScope、sessionScope以及applicationScope 实现XXXAware接口 TestAwareAction.java 1234567891011121314151617181920212223242526272829303132333435363738394041424344package com.glemontree.struts2;import java.util.Map;import org.apache.struts2.interceptor.ApplicationAware;import org.apache.struts2.interceptor.ParameterAware;import org.apache.struts2.interceptor.RequestAware;import org.apache.struts2.interceptor.SessionAware;public class TestAwareAction implements ApplicationAware, SessionAware, RequestAware, ParameterAware&#123; public String execute() &#123; //1.向application中加入一个属性：applicationKey2 - applicationValue2 application.put(\"applicationKey2\", \"applicationValue2\"); System.out.println(application.get(\"date\")); //2.从application中读取一个属性date并打印 return \"success\"; &#125; private Map&lt;String, Object&gt; application; @Override public void setApplication(Map&lt;String, Object&gt; application) &#123; // TODO Auto-generated method stub this.application = application; &#125; @Override public void setParameters(Map&lt;String, String[]&gt; arg0) &#123; // TODO Auto-generated method stub &#125; @Override public void setRequest(Map&lt;String, Object&gt; arg0) &#123; // TODO Auto-generated method stub &#125; @Override public void setSession(Map&lt;String, Object&gt; arg0) &#123; // TODO Auto-generated method stub &#125;&#125; index.jsp 123456789101112131415161718192021&lt;%@page import=\"java.util.Date\"%&gt;&lt;%@ page language=\"java\" contentType=\"text/html; charset=GB18030\" pageEncoding=\"GB18030\"%&gt;&lt;!DOCTYPE html PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\" \"http://www.w3.org/TR/html4/loose.dtd\"&gt;&lt;html&gt; &lt;head&gt; &lt;meta http-equiv=\"Content-Type\" content=\"text/html; charset=GB18030\"&gt; &lt;title&gt;Insert title here&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;a href=\"TestActionContext.action?name=glemontree\"&gt;Test ActionContext&lt;/a&gt; &lt;br&gt;&lt;br&gt; &lt;a href=\"TestAware.action?name=glemontree\"&gt;Test Aware&lt;/a&gt; &lt;% if (application.getAttribute(\"date\") == null) &#123; application.setAttribute(\"date\", new Date()); &#125;%&gt; &lt;/body&gt;&lt;/html&gt; test-aware.jsp 12345678910111213&lt;%@ page language=\"java\" contentType=\"text/html; charset=GB18030\" pageEncoding=\"GB18030\"%&gt;&lt;!DOCTYPE html PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\" \"http://www.w3.org/TR/html4/loose.dtd\"&gt;&lt;html&gt; &lt;head&gt; &lt;meta http-equiv=\"Content-Type\" content=\"text/html; charset=GB18030\"&gt; &lt;title&gt;Insert title here&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h4&gt;Test Aware Page&lt;/h4&gt; application: $&#123;applicationScope.applicationKey2 &#125; &lt;/body&gt;&lt;/html&gt; 和Servlet API耦合的方式 可以访问更多的Servlet API对象且可以调用其原生的方法 使用ServletActionContext 实现ServletXXXAware接口","tags":[{"name":"Struts2, 配置文件","slug":"Struts2-配置文件","permalink":"https://glemontree.github.io/tags/Struts2-配置文件/"}]},{"title":"[Struts2] URL、URI以及ServletPath之间的区别","date":"2017-06-29T02:37:46.000Z","path":"2017/06/29/[Struts2] URL、URI以及ServletPath之间的区别/","text":"一直没弄明白URL、URI以及ServletPath之间的区别，今天看到了一篇博客，所以转载过来记录一下。 假设现在有一个名为JavaWeb的项目，其中有一个名为TestServlet的serlvet，其doGet方法为： 12345protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; System.out.println(\"URL:\"+request.getRequestURL().toString()); System.out.println(\"URI:\"+request.getRequestURI()); System.out.println(\"ServletPath:\"+request.getServletPath()); &#125; 现在在浏览器中发送到TestServlet的请求，发现控制台输出如下： 123URL: http://localhost:8080/JavaWeb/TestServletURI: /JavaWeb/TestServletServletPath: /TestServlet 通过上面的三个输出相信你能理解三者的区别了！","tags":[{"name":"Struts2, ServletPath","slug":"Struts2-ServletPath","permalink":"https://glemontree.github.io/tags/Struts2-ServletPath/"}]},{"title":"[C++] ACE书籍推荐","date":"2017-06-28T10:26:30.000Z","path":"2017/06/28/[C++] ACE书籍推荐/","text":"《ACE程序员指南：网络与系统编程的使用设计模式》（简称：APG）《C++网络编程：运用ACE和模式消除复杂性 卷1》（简称：C++NPv1）《C++网络编程：基于ACE和框架的系统化复用 卷2》（简称：C++NPv2）","tags":[{"name":"C++, ACE, 网络","slug":"C-ACE-网络","permalink":"https://glemontree.github.io/tags/C-ACE-网络/"}]},{"title":"[Android] Android assets目录下资源使用","date":"2017-06-28T10:25:19.000Z","path":"2017/06/28/[Android] Android assets目录下资源使用/","text":"第一种方法String path = &quot;file:///android_assert/文件名&quot; 第二种方法​InputStream abPath = getClass().getResourceAsStream(&quot;asserts/文件名&quot;); 若想要转换成String类型： 123456789101112131415161718192021String path = new String (InputStreamToByte(abpath)); private byte[] InputStreamToByte(InputStream is) throws IOException &#123; ByteArrayOutputStream bytesStream = new ByteArrayOutputStream(); int ch; while ((ch = is.read()) != -1) &#123; byteStream.write(ch); &#125; byte[] imgData = byteStream.toByteArray(); byteStream.close(); return imgData; &#125;","tags":[{"name":"Android, assets","slug":"Android-assets","permalink":"https://glemontree.github.io/tags/Android-assets/"}]},{"title":"[Android] ProgressDialog与耗时操作","date":"2017-06-28T10:24:14.000Z","path":"2017/06/28/[Android] ProgressDialog与耗时操作/","text":"ProgressDialog与耗时操作今天来研究一下ProgressDialog与耗时操作，相信大家平时经常会看到在执行耗时操作时界面会有一个圆圈一直转，常见的比如网络请求时就经常会出现，虽然很简单，但是还是想亲自尝试一下！ 这其中会涉及到单个知识点，一个是ProgressDialog的使用，一个是Handler的使用，还有一个就是线程的使用，具体ProgressDialog怎么使用，Handler的用法以及内部实现原理，大家可以去Google查找相关资料以加深理解。 代码分析 activity_main.xml 123456789101112131415&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:app=\"http://schemas.android.com/apk/res-auto\" xmlns:tools=\"http://schemas.android.com/tools\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" tools:context=\"com.glemontree.progressdialogtest.MainActivity\"&gt; &lt;Button android:id=\"@+id/download\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:text=\"开始下载\" /&gt;&lt;/LinearLayout&gt; 布局文件不要太简单。。就放置了一个Button，没什么好说的。。 MainActivity.class 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253package com.glemontree.progressdialogtest;import android.app.ProgressDialog;import android.os.Handler;import android.os.Message;import android.support.v7.app.AppCompatActivity;import android.os.Bundle;import android.view.View;import android.widget.Button;public class MainActivity extends AppCompatActivity &#123; private Button mDownloadButton; private static final int SHOW = 1; private static final int HIDE = 0; private ProgressDialog mProgressDialog = null; private Handler handler = new Handler() &#123; @Override public void handleMessage(Message msg) &#123; switch (msg.what) &#123; case SHOW: mProgressDialog = ProgressDialog.show(MainActivity.this, \"test\", \"This is a test\"); break; case HIDE: mProgressDialog.dismiss(); &#125; &#125; &#125;; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); mDownloadButton = (Button) findViewById(R.id.download); mDownloadButton.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; handler.sendEmptyMessage(SHOW); new Thread() &#123; public void run() &#123; try &#123; Thread.sleep(3000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; handler.sendEmptyMessage(HIDE); &#125; &#125;.start(); &#125; &#125;); &#125;&#125; 大家都知道更新UI只能在主线程中进行更新，因此如果将耗时操作放置在另外一个线程中完成，当耗时操作执行完成后若要更新UI，其实有两种方法： runOnUiThread Handler 我这里使用的是Handler机制，主要是在主线程中建立Handler，在建立Handler的同时需要实现其handleMessage(Message msg)方法，该方法由用户实现，可以根据不同的msg实现不同的操作，在上面的程序中，主要是根据msg的内容实现ProgressDialog的显示和消失。 在Button的点击事件中，首先通过Handler发送SHOW消息，然后消息到达handlerMessage(Message msg)方法中后由于是SHOW消息所以会显示ProgressDialog；然后会开启一个线程，在线程中睡眠3S用来模拟耗时操作的执行，当耗时操作执行完成后再发送HIDE消息，消息到达handlerMessage(Message msg)方法中后由于是HIDE消息所以ProgressDialog消息。这就是整个程序的功能！ 后续工作 研究一下Handler的实现机制","tags":[{"name":"Android, ProgressDialog， 耗时操作","slug":"Android-ProgressDialog，-耗时操作","permalink":"https://glemontree.github.io/tags/Android-ProgressDialog，-耗时操作/"}]},{"title":"[Android] Android_监听电池电量","date":"2017-06-28T10:23:12.000Z","path":"2017/06/28/[Android] Android_监听电池电量/","text":"监听电池变化的方法Battert Manager会通过一个Intent广播所有电池和充电详情，包含充电状态。Android开发者可以利用BroadcastReceiver机制获取电池电量的变化，通过监听电池电量的变化包含以下几个步骤： 创建一个监听ACTION_BATTERY_CHAGRED事件的 intentFilter 创建一个BroadcastReceiver对象，该对象可以接收broadcase intent 注册BroadcastReceiver对象来监听ACTION_BATTERY_CHANGED事件 在BroadcastReceiver对象中，重写onReceive方法，在onReceive方法的传入参数intent中获取电池的状态 切记的是在生命周期结束时，及时取消BroadcastReceiver的注册，否则出现内存泄漏 具体实现通常有两种思路，第一种就是自定义一个BroadcastReceiver继承自BroadcastReceiver，并且重写onReceive()方法，在onReceive()方法中根据方法传入的Intent来判断电池的状态，这种方法需要主要的是需要在Manifest文件中注册广播接收器，添加过滤条件；还有一种方法是直接在Activity中定义一个BroadcastReceiver对象并重写onReceive()方法，并且需要定义IntentFilter，同时需要调用registerReceiver方法来将BroadcastReceiver和IntentFilter进行绑定。 这里就第二种方法给出一个例子，代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889package com.glemontree.batterymonitor;import android.content.BroadcastReceiver;import android.content.Context;import android.content.Intent;import android.content.IntentFilter;import android.os.BatteryManager;import android.support.v7.app.AppCompatActivity;import android.os.Bundle;import android.widget.TextView;public class MainActivity extends AppCompatActivity &#123; private TextView batteryLevel; private BroadcastReceiver batteryLevelReceiver; private IntentFilter batteryLevelFilter; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); batteryLevel = (TextView) findViewById(R.id.batteryLevel); monitorBatteryState(); &#125; @Override protected void onDestroy() &#123; super.onDestroy(); unregisterReceiver(batteryLevelReceiver); &#125; private void monitorBatteryState() &#123; batteryLevelReceiver = new BroadcastReceiver() &#123; @Override public void onReceive(Context context, Intent intent) &#123; StringBuilder sb = new StringBuilder(); int rawLevel = intent.getIntExtra(\"level\", -1); int scale = intent.getIntExtra(\"scale\", -1); int status = intent.getIntExtra(\"status\", -1); int health = intent.getIntExtra(\"health\", -1); int level = -1; if (rawLevel &gt;= 0 &amp;&amp; scale &gt; 0) &#123; level = (rawLevel * 100) / scale; &#125; sb.append(\"The phone \"); if (BatteryManager.BATTERY_HEALTH_OVERHEAT == health) &#123; sb.append(\"s battery feels very hot!\"); &#125; else &#123; switch (status) &#123; case BatteryManager.BATTERY_STATUS_UNKNOWN: sb.append(\"no battery.\"); break; case BatteryManager.BATTERY_STATUS_CHARGING: sb.append(\"s battery\"); if (level &lt;= 33) &#123; sb.append(\"is charging, battery level is low\" + \"[\" + level + \"]\"); &#125; else if (level &lt;= 84) &#123; sb.append(\"is charging.\" + \"[\" + level + \"]\"); &#125; else &#123; sb.append(\"will be fully charged.\"); &#125; break; case BatteryManager.BATTERY_STATUS_DISCHARGING: case BatteryManager.BATTERY_STATUS_NOT_CHARGING: if (level == 0) &#123; sb.append(\"needs charging right away.\"); &#125; else if (level &gt; 0 &amp;&amp; level &lt;= 33) &#123; sb.append(\"is about ready to be recharged, battery level is low\" + \"[\" + level + \"]\"); &#125; else &#123; sb.append(\"s battery level is\" + \"[\" + level + \"]\"); &#125; break; case BatteryManager.BATTERY_STATUS_FULL: sb.append(\"is fully charged.\"); break; default: sb.append(\"s battery is indescribable!\"); break; &#125; &#125; sb.append(\"\"); batteryLevel.setText(sb.toString()); &#125; &#125;; batteryLevelFilter = new IntentFilter(Intent.ACTION_BATTERY_CHANGED); registerReceiver(batteryLevelReceiver, batteryLevelFilter); &#125;&#125; 代码分析上面这段代码中，首先在onCreate()方法中定义了一个BroadcastReceiver，并且重写了其onReceive方法，在onReceive()方法中根据传入的Intent，获得电池的一些信息： 1234int rawLevel = intent.getIntExtra(\"level\", -1);int scale = intent.getIntExtra(\"scale\", -1);int status = intent.getIntExtra(\"status\", -1);int health = intent.getIntExtra(\"health\", -1); 其中，level表示电池的当前剩余电量，scale表示电池的最大值，status表示电池的状态，health则表示电池的健康状态。 在方法的最后定义了IntentFilter用来定义消息过滤，这里过滤的是Intent.ACTION_BATTERY_CHANGED，表示BroadcastReceiver监听电池电量的变化，最后通过registerReceiver方法将BroadcastReceiver和IntentFilter进行绑定。 需要注意的是一定在Activity的onDestroy()方法中调用unRegisterReceiver()方法来取消注册Receiver，当然本例子是在onCreate()方法中调用registerReceiver()来绑定BroadcastReceiver和IntentFilter，你也可以在onResume()方法中进行绑定，甚至于在View中在onAttatchedWindow()方法中进行绑定！ 总结本文主要对Android中电池电量的监听进行了简短的介绍，更加详细的介绍可以上网查询，这里仅仅了做个笔记，以便后面查询回忆！ 说明本文转自博客","tags":[{"name":"Android, 监听电池电量","slug":"Android-监听电池电量","permalink":"https://glemontree.github.io/tags/Android-监听电池电量/"}]},{"title":"[Android] Android中xml tools属性详解","date":"2017-06-28T10:22:09.000Z","path":"2017/06/28/[Android] Android中xml tools属性详解/","text":"预览效果有些效果必须在运行之后才能看见，比如TextView在xml中没有设置任何字符，在activity中设置了text，因此为了在AS中预览效果，你可能会在xml中设置android:text属性来预览效果： 12345&lt;TextView android:id=\"@+id/text_main\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:text=\"Hello\"/&gt; 一般这样做之后在最终发布之前你仍然需要将android:text=&quot;Hello&quot;这行代码删除，但是存在的问题就是你很可能会忘记，而且如果代码中存在很多这样的代码，删除也是个很大的工作量，这时候你应该想到tools，我们只需要用如下的方法即可解决： 1xmlns:tools=\"http://schemas.android.com/tools\" tools可以告诉AS，哪些属性在运行的时候是被忽略的，只在设计的时候可以看到，在运行的时候tools本身也是被忽略的，不会被带进APK中。 tools属性的种类tools属性可以分为两类，一种是影响Lint提示的，一种是关于xml布局设计的。 Lint相关的属性lint相关的属性主要有以下三个： 123tools:ignoretools:targetApitools:locale tools:ignore ignore属性时告诉lint忽略xml中的某些警告，假设我们有个ImageView如下： 12345&lt;ImageView android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:scaleType=\"center\" android:src=\"@drawable/divider\"/&gt; Lint会提示ImageView缺少android:contentDescription属性，我们可以使用tools:ignore来忽略这个警告： 123456&lt;ImageView android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:scaleType=\"center\" android:src=\"@drawable/divider\" tools:ignore=\"contentDescription\"/&gt; tools:targetApi 假设minSdkLevel 为15，而你使用了api21中的控件如RippleDrawable 12&lt;ripple xmlns:android=\"http://schemas.android.com/apk/res/android\" android:color=\"@color/accent_color\"/&gt; 那么Lint会提示警告，为了不显示这个警告，可以这样： 1234&lt;ripple xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:tools=\"http://schemas.android.com/tools\" android:color=\"@color/accent_color\" tools:targetApi=\"LOLLIPOP\"/&gt; tools:locale属性 默认情况下res/values/strings.xml中的字符串会执行拼写检查，如果不是英语，会提示拼写错误，通过以下代码来告诉AS本地语言不是英语： 12345&lt;resources xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:tools=\"http://schemas.android.com/tools\" tools:locale=\"it\"&gt;&lt;/resources&gt; xml布局相关的属性xml布局相关的属性主要有以下几个： tools:context tools:menu tools:actionBarNavMode tools:listitem/listheader/listfooter tools:showIn tools:layout tools:context该属性的值通常是activity的完整包名，例如： 123456789&lt;LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:tools=\"http://schemas.adnroid.com/tools\" android:id=\"@+id/container\" android:layout_width=\"match_parent\" android:lauouy_height=\"match_parent\" android:orientation=\"vertical\" tools:context=\"com.android.example.MainActivity\"&gt;&lt;/LinearLayout&gt; tools:menu告诉AS在预览窗口中使用哪个菜单，这个菜单将显示在layout的根结点上（actionbar的位置）。 其实预览窗口非常智能，如果布局和一个activity关联（tools:context进行关联），它将会自动查询相关activity的onCreateOptionsMenu方法中的代码，以显示菜单，而menu属性可以覆盖这种行为。 还以可以在menu属性中定义多个菜单资源，不同的菜单资源之间用逗号隔开。 1tools:menu=\"menu_main,menu_edit\" 如果不希望在预览图中显示菜单则： 1tools:menu=&quot;&quot; 需要注意的是：当主题为Theme.AppCompat时，这个属性不起作用 tools:actionBarNavMode这个属性告诉AS，app bar的显示模式，其值可以是： standard tabs list 同样的，当主题为Theme.AppCompat或者Theme.Material该属性不起作用，只有holo主题才有效。 listitem，listheader，listfooter属性指在ListView或ExpandableListView等的预览效果中添加头部、尾部以及子item的预览布局。 1234567&lt;GridView android:id=\"@+id/list\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" tools:listheader=\"@layout/list_header\" tools:listitem=\"@layout/list_item\" tools:listfooter=\"@layout/list_footer\" /&gt; layout属性tools:layout告诉AS，fragment在程序预览的时候该显示什么样： 123456789&lt;fragment xmlns=\"http://schemas.android.com/apk/res/android\" xmlns:tools=\"http://schemas.android.com/tools\" android:id=\"@+id/item_list\" android:name=\"com.example.fragmenttwopanel.ItemListFragment\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:layout_marginLeft=\"16dp\" android:layout_marginRight=\"16dp\" tools:layout=\"@android:layout/list_content\" /&gt; tools:showIn该属性设置与一个被其他布局&lt;include&gt;的布局的根元素上，这样可以指向包含此布局的其中一个布局，在设计时这个被包含的布局会带着周围的外部布局被渲染。 总结本文摘录自speedboy007的博客，需要了解更多的可以去详细阅读！","tags":[{"name":"Android, xml-tools","slug":"Android-xml-tools","permalink":"https://glemontree.github.io/tags/Android-xml-tools/"}]},{"title":"[C++] assert用法","date":"2017-06-28T10:21:09.000Z","path":"2017/06/28/[C++] assert用法/","text":"assert()函数用法总结 assert宏的原型定义在&lt;assert.h&gt;中，如果它的条件返回错误，则终止程序执行： 12#include &lt;assert.h&gt;void assert(int expression); assert的作用是计算表达式expression，如果其值为假（0），那么向stderr打印出一条出错信息，然后调用abort来终止程序执行。 在调试结束后，可以通过在包含#include&lt;assert.h&gt; 的语句之前插入#define NDEBUG来禁用assert调用 一个非常简单的使用assert的规律就是：在方法或者函数的最开始使用，如果在方法的中间使用则需要慎重考虑是否是应该的，方法的最开始还没有开始一个功能过程，在一个功能过程执行中出现的问题几乎都是异常。","tags":[{"name":"C++, assert","slug":"C-assert","permalink":"https://glemontree.github.io/tags/C-assert/"}]},{"title":"[C++] boost::function boost::bind 与 回调","date":"2017-06-28T10:20:01.000Z","path":"2017/06/28/[C++] boostfunction boostbind 与 回调/","text":"boost::function 和 boost::bindboost::function是对函数指针的对象化封装，是一个函数对象的容器，在概念上与回调函数类似，先看一个例子： 123456789101112131415161718192021222324252627282930313233#include &lt;boost/function.hpp&gt;#include &lt;boost/bind.hpp&gt;#include &lt;iostream&gt;class TestA &#123;public: void method() &#123; std::cout &lt;&lt; \"TestA: method: no arguments\" &lt;&lt; std::endl; &#125; void method(int a, int b) &#123; std::cout &lt;&lt; \"TestA: method: with arguments\" &lt;&lt; \"value of a is:\" &lt;&lt; a &lt;&lt; \"value of b is:\" &lt;&lt; b &lt;&lt; std::endl; &#125;&#125;;void sum(int a, int b) &#123; int sum = a + b; std::cout &lt;&lt; \"sum: \" &lt;&lt; sum &lt;&lt; std::endl;&#125;int main() &#123; boost::function&lt;void()&gt; f; TestA test; f = boost::bind(&amp;TestA::method, &amp;test); f(); f = boost::bind(&amp;TestA::method, &amp;test, 1, 2); f();&#125; boost::function通常结合boost::bind一起使用，这是因为bind返回的正好是一个函数对象。","tags":[{"name":"C++, bind, 回调","slug":"C-bind-回调","permalink":"https://glemontree.github.io/tags/C-bind-回调/"}]},{"title":"[C++] boost::less_than_comparable","date":"2017-06-28T10:18:51.000Z","path":"2017/06/28/[C++] boostless_than_comparable/","text":"boost::less_than_comparable前言很多操作符都是可以从其他操作符自动推导出来，例如a != b可以从!(a == b)推导出来，因此原则上只需要定义少量的基本操作符，其他的操作符就可以 通过逻辑组合推导出来。 std::rel::ops在C++98标准的std::rel_ops中定义了四个模板比较操作符!=、&gt;、&lt;=、&gt;=，只需要为类定义==和&lt;操作符，那么这四个操作符就可以自动实现。 123456789101112131415161718192021222324252627#include &lt;iostream&gt;#include &lt;assert.h&gt;#include &lt;boost/logic/tribool.hpp&gt;#include &lt;boost/logic/tribool_io.hpp&gt;#include &lt;utility&gt;class demo_class &#123;public: demo_class(int n) : x(n) &#123; &#125; private: int x; public: friend bool operator&lt;(const demo_class&amp; lhs, const demo_class&amp; rhs) &#123; return lhs.x &lt; rhs.x; &#125;&#125;;int main() &#123; demo_class a(10), b(20); using namespace std::rel_ops; // 打开命名空间 std::cout &lt;&lt; (a &lt; b) &lt;&lt; std::endl; std::cout &lt;&lt; (b &gt;= a) &lt;&lt; std::endl; return 0;&#125; boost.opeartors库同样地，boost.opeartors库允许用户在自己的类里仅定义少量的操作符（如&lt;）就可以方便的自动生成其他操作符重载。 operators库由多个类组成，分别用来实现不同的运算概念，比如less_than_comparable定义了&lt;系列操作符，left_shiftable定义了&lt;&lt;系列操作符。 equality_comparable： 要求提供==，可自动实现!=，相等语义； less_than_comparable：要求提供&lt;，可自动实现&gt;，&lt;=，&gt;=； addable：要求提供+=，自动实现+； subtractable：要求提供-=，可自动实现-； incrementable：要求提供前置++，可自动实现后置++； decrementable：要求提供前置–，可自动实现后置–； equivalent：要求提供&lt;，可自动实现==； 这些概念在库中以同名类的形式提供，用户需要以继承的方式来使用它们，继承的修饰符并不重要(private，public都可以),因为operator库里的类都是空类，没有成员变量和成员函数，仅定义了数个友元操作符函数。 1234567891011121314151617181920212223#include &lt;iostream&gt;#include &lt;assert.h&gt;#include &lt;boost/operators.hpp&gt;class Point : public boost::less_than_comparable&lt;Point&gt; &#123;public: explicit Point(int a = 0, int b = 0, int c = 0) : x(a), y(b), z(c) &#123; &#125;public: void print() const &#123; std::cout &lt;&lt; x &lt;&lt; \",\" &lt;&lt; y &lt;&lt; \",\" &lt;&lt; z &lt;&lt; std::endl; &#125; public: friend bool operator&lt;(const Point&amp; l, const Point&amp; r) &#123; return (l.x * l.x + l.y * l.y + l.z * l.z &lt; r.x * r.x + r.y * r.y + r.z * r.z); &#125;private: int x, y, z;&#125;; 在上面这段代码中，Point类中仅定义了一个友元operator&lt;函数，其余的&gt;、&lt;=、&gt;=均由less_than_comparable自动生成。 在使用operators库时需要注意，模板类型参数必须是子类本身，，特别是当子类本身也是个模板类的时候，不要错写成子类的模板参数或者子类不带模板参数的名称，否则会造成编译错误。在上面代码中，less_than_comparable的模板类型参数必须是Point类。","tags":[{"name":"C++ boost","slug":"C-boost","permalink":"https://glemontree.github.io/tags/C-boost/"}]},{"title":"[C++] BOOST_STATIC_ASSERT和assert的区别","date":"2017-06-28T10:17:37.000Z","path":"2017/06/28/[C++] BOOST_STATIC_ASSERT和assert的区别/","text":"BOOST_STATIC_ASSERT和assert的区别assert是运行期断言，也就是编译期出现的错误，它不会提示；相反，BOOST_STATIC_ASSERT是编译期的断言，在编译的时候就可以断言出错误。 需要注意的是BOOST_STATIC_ASSERT是放在全局命名空间中的，所以使用的时候不要加上boost::限定名","tags":[{"name":"C++ boost","slug":"C-boost","permalink":"https://glemontree.github.io/tags/C-boost/"}]},{"title":"[C++] C++11 bind 的用法","date":"2017-06-28T10:16:33.000Z","path":"2017/06/28/[C++] C++11 bind 的用法/","text":"BindBind可用于绑定函数、成员函数、函数对象、成员变量，bind函数支持最多10个自定义参数 1234int f(int a, int b) &#123; return a + b;&#125;std::bind(f, 5, std::placeholders::_1)(x); // 相当于执行了f(5, x); 在上面这段代码中： std::bind函数返回绑定对象，后面跟的(x)表示传参x并执行; std::placeholders::_1是占位符，表示调用时的第一个参数，这段代码里表示x; 如果代码是std::bind(f, std::placeholders::_2, std::placeholders::_1)(x, y)则表示执行f(y, x) 调用前传入的函数参数会被复制并保存在std::bind返回的对象中，比如之前的std::bind(f, 5, std::placeholders::_1)中的5就被存储在了返回的对象中，所以为了性能上考虑，建议传入的类型为引用或指针，避免结构复制 Bind和类成员函数此时需要注意的是成员函数绑定的第二个参数必须是类实例： 12345678910struct X &#123; bool f(int a);&#125;;X x;std::shared_ptr&lt;X&gt; p(new X);int i = 5;std::bind(&amp;X::f, ref(x), std::placeholders::_1)(i); //相当于执行了x.f(i)std::bind(&amp;X::f, &amp;x, std::placeholders::_1)(i); // 相当于执行了(&amp;x)-&gt;f(i)std::bind(&amp;X::f, x, std::placeholders::_1)(i); // 复制x，并执行（复制的x）.f(i)std::bind(&amp;X::f, p, std::placeholders::_1)(i); //复制智能指针p，并执行（复制的p）-&gt;f(i) 由于第二个参数的类实例的保存方式与参数一致，所以也建议传入类引用或类指针，或者智能指针 bind举例123456789101112131415161718192021222324252627282930313233#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;memory&gt;#include &lt;functional&gt;class Button &#123;public: std::function&lt;void(int)&gt; onClick;&#125;;class Player&#123;public: void play(void* sender, int param) &#123; printf(\"Play: %d =&gt; %d\\n\", (int)sender, param); &#125; void stop(void* sender, int param) &#123; printf(\"Play: %d =&gt; %d\\n\", (int)sender, param); &#125;&#125;;Button playButton, stopButton;Player thePlayer;void connect() &#123; playButton.onClick = std::Bind(&amp;Player::play, &amp;thePlayer, &amp;playButton, std::placeholders::_1); stopButton.onClick = std::Bind(&amp;Player::stop, &amp;thePlayer, &amp;stopButton, std::placeholders::_1);&#125;int main() &#123; connect(); playButton.onClick(0); return 0;&#125; 上面这段程序其实就是bind在回调函数中的用法，Button类中有一个回调函数onClick()，需要根据不同的场合实现不同的功能，使用bind函数为playButton绑定了play()函数，而为stopButton绑定了stop()函数，这是bind()函数在回调这方面的一个典型用法。","tags":[{"name":"C++11, Bind","slug":"C-11-Bind","permalink":"https://glemontree.github.io/tags/C-11-Bind/"}]},{"title":"[C++] C++中boost::any的使用","date":"2017-06-28T10:15:17.000Z","path":"2017/06/28/[C++] C++中boostany的使用/","text":"boost::any库是个很短小的类，它的主要作用是定义一个变量来存放任意类型的数据，我们首先来看下boost::any的使用方法。 boost::any最常见的用法12345678910111213141516171819202122232425#include &lt;iostream&gt;#include &lt;list&gt;#include &lt;boost/any.hpp&gt;typedef std::list&lt;boost::any&gt; list_any; // 类型定义void fill_list(list_any&amp; la) &#123; la.push_back(10); // 存放整数 la.push_back(std::string(\"glemontree\")); // 存放字符串对象，不能是la.push_back(\"glemontree\")，否则会被当做字符串数组&#125;void show_list(list_any&amp; la) &#123; list_any::iterator it; boost::any anyone; for (it = la.begin; it!= la.end(); ++it) &#123; anyone = *it; // C++中，typeid用于返回指针或引用所指对象的实际类型，typeid是操作符，不是函数 if (anyone.type() == typeid(int)) &#123; std::cout &lt;&lt; boost::any_cast&lt;int&gt;(*it) &lt;&lt; std::endl; &#125; else if (anyone.type() == typeid(std::string)) &#123; // c_str()函数返回一个指向正规C字符串的指针，内容与本string相同 std::cout &lt;&lt; boost::any_cast&lt;std::string&gt;(*it).c_str() &lt;&lt; std::endl; &#125; &#125;&#125; boost::any可以表示任意类型，因此list_any可以存放任意类型的对象，也正因为boost::any可以表示任意类型，因此用不了多态的特性，因为没有统一的接口，因此在show_list()函数中获取容器中的元素时需要判别元素的真正类型，这增加了程序员的负担。 boost::any源码实现any的功能主要由三部分组成： any类 真正保存数据的holder类和其基类placeholder 获取真正数据的模板函数any_cast，类型转换的功能 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#include &lt;iostream&gt;#include &lt;list&gt;#include &lt;cassert&gt;class any &#123;public: class placeholder &#123; public: virtual ~placeholder() &#123; &#125; public: virtual const std::type_info&amp; type() const = 0; virtual placeholder* clone() const = 0; &#125;; template&lt;typename ValueType&gt; class holder : public placeholder &#123; public: holder(const ValueType&amp; value): held(value) &#123; &#125; public: virtual const std::type_info&amp; type() const &#123; return typeid(ValueType); &#125; virtual placeholder* clone() const &#123; return new holder(held); &#125; public: ValueType held; &#125;; public: any(): content(NULL) &#123; &#125; //模板构造函数，参数可以是任意类型，真正的数据保存在content中 template&lt;typename ValueType&gt; any(const ValueType&amp; value): content(new holder&lt;ValueType&gt;(value)) &#123; &#125; //拷贝构造函数 any(const any&amp; other): content(other.content ? other.content-&gt;clone() : 0) &#123; &#125; ~any() &#123; if (NULL != content) &#123; delete content; &#125; &#125; private: placeholder* content; template&lt;typename ValueType&gt; friend ValueType any_cast(const any* operand); public: const std::type_info&amp; type() const &#123; return content ? content-&gt;type() : typeif(void); &#125;&#125;;template&lt;typename ValueType&gt;ValueType any_cast(const any&amp; operand) &#123; assert(operand.type() == typeid(ValueType)); return static_cast&lt;any::holder&lt;ValueType&gt;*&gt;(operand.content)-&gt;held;&#125; 参考资料 boost::any的用法、优点和缺点以及源代码分析 浅尝boost之any ​","tags":[{"name":"C++, Boost","slug":"C-Boost","permalink":"https://glemontree.github.io/tags/C-Boost/"}]},{"title":"[CMake] CMake的使用","date":"2017-06-28T10:14:17.000Z","path":"2017/06/28/[CMake] CMake的使用/","text":"VS环境下，CMake出来的ALL_BUILD项目和ZERO_CHECK项目的作用CMake是 跨平台软件开发和维护过程的 工程构建工具。“在每个系统构建你的工程，而无须关心创建可执行文件和动态库的具体方法”。 CMake 相对于其他类似工具（shell脚本、Makefiles、Jam文件、基于复杂的脚本的工程像Autoconf和Automake），CMake 对底层系统做更少的假设。CMake使用标准C++实现，所以他可以在大多数现代操作系统上运行。它不使用除了系统的本地构建工具外的其他的工具。 一般CMake 在Vision studio2008 上 构建的工程（.sln “solution”）包含 三个工程（project），分别是：ALL_BUILD； 工程本身如：HelloCMake；ZERO_CHECK。HelloCMake就不用说了，自己要建立的那个工程；ALL_BUILD是管理整个项目的工程；ZERO_CHECK是实时监视CMakeLists.txt文件变化的工程，一旦CMakeLists.txt里的内容发生了任何变化，ZERO_CHECK就会告诉编译器要重新构建整个工程环境。 本文转载自文章。","tags":[{"name":"CMake, VS","slug":"CMake-VS","permalink":"https://glemontree.github.io/tags/CMake-VS/"}]},{"title":"[C++] effective_C++_条款02","date":"2017-06-28T10:13:17.000Z","path":"2017/06/28/[C++] effective_C++_条款02/","text":"条款02：尽量用const, enum, inline代替#define 该原则言下之意是说使用编译器替换预处理器 假设你使用下面的表达式： 1#define ASPECT_RATIO 1.653 记号名称ASPECT_RATIO也许从未被编译器看到，也许在编译器开始处理源代码之前它就被预处理器移走了，于是ASPECT_RATIO可能从来没进入记号表中，于是当你运用此常量但获得一个编译错误信息时，你可能不知道这个1.653是什么意思，这就是#define的坏处。 因此你可以使用一个常量来替换上述的宏： 1const double AspectRatio = 1.653; 作为一个语言常量，AspectRatio肯定会被编译器看到，当然会进入记号表中 在定义常量指针时，由于常量定义通常被放在头文件中，以便被不同的源码包含，因此有必要将指针声明为const，例如若要在头文件内定义一个常量的char*字符串，需要些const两次： 1const char* const authorName = \"Scott Meyers\"; class专属常量。为了将常量的作用域限制于class内，你必须让它成为class的一个成员，而为确保此常量至多只有一份实体，必须让它成为一个static成员: 12345class GamePlayer &#123;private: static const int NumTurns = 5; // 常量声明式 int scores[NumTurns]; // 使用该常量&#125; 通常C++要求所使用的任何变量均需提供定义式，但如果它是一个class专属常量又是static且为整数类型(integral types, ints, chars, bools)，则需特殊处理，只要不取它们的地址，可以只声明并使用它们而无需提供定义式；但如果你取某个class专属常量的地址，你就必须提供下面的定义式： 1const int GamePlayer::NumTurns; // 定义 在C++中，在默认情况下，全局变量的链接性是外部的，但const全部变量的链接性是内部的，也就是说，在C++看来，全局const定义就像使用了static说明符一样。 全局变量在多线程中容易出问题， 一份优秀的代码是几乎不出现全局变量的 一个属于枚举类型的数值可当做ints使用，即”the enum hack” 1234class GamePlayer&#123; enum &#123;NumTurns = 5&#125;; int scores[NumTurns];&#125;; the enum hack 技术的好处： 当你不想让别人获得一个pointer或reference指向你的某个整数常量时，enum可以实现 enum和#define不会导致非必要的内存分配","tags":[{"name":"C++","slug":"C","permalink":"https://glemontree.github.io/tags/C/"}]},{"title":"[C++] effective_C++_条款03","date":"2017-06-28T10:12:05.000Z","path":"2017/06/28/[C++] effective_C++_条款03/","text":"条款03：尽可能使用const 修饰变量，使其不可改变 1const int var = 3; 此时var的值就不能改变了，因为这个特性，所以在声明的时候就要初始化，这样是不行的： 1const int var; 修饰指针 可分为两种情况，指向常量的指针和常量指针 1const int* p = &amp;a; 修饰迭代器 C++的STL中既有vector&lt;T&gt;::iterator，也有vector&lt;T&gt;::const_iterator，而vector&lt;T&gt;::const_iterator即表示指向常量的迭代器，而另一种形式const vector&lt;T&gt;::iterator则表示这个迭代器的指向不可改变，即常量迭代器 修饰类的成员函数 有无const是可以构成成员函数的重载的 如果某个类中有一个指针，如果在某个函数中确实改动了p所指向的内容，那么最好就不要加上const，反过来，如果加上了const就不要改变成员变量，包括它所指向的值 在const成员函数和非const成员函数中避免重复 有没有加const是构成函数重载的，但通常这种重载的相似度很高： 1234567891011121314class TestBlock &#123;private: string text;public: ... const char&amp; operator[](size_t position) const &#123; ... return text[position]; &#125; char&amp; operator[](size_t position) &#123; ... return text[position]; &#125;&#125; 一个好的方法就是在非const版本的成员函数中调用const版本的成员函数： 123char&amp; operator[](size_t position) &#123; return const_cast&lt;char&amp;&gt;(static_cast&lt;const TestBlock&amp;&gt; (*this)[position]);&#125; 正如上面代码所示，进行了两次转换，一次是把非const对象转成const对象，使用static_cast&lt;const TestBlock&amp;&gt;，另一次是在返回值时，将const char&amp;通过const_cast&lt;char&amp;&gt;转换成char&amp;。","tags":[{"name":"C++","slug":"C","permalink":"https://glemontree.github.io/tags/C/"}]},{"title":"[C++] effective_C++_条款05","date":"2017-06-28T10:10:57.000Z","path":"2017/06/28/[C++] effective_C++_条款05/","text":"条款05：了解C++默默编写并调用哪些函数 一个空类为了区分不同的对象，其通占有1个字节 编译器为空类默认生成拷贝函数、析构函数、拷贝构造函数以及赋值运算符 假设有下面这个空类： 123class EmptyClass &#123; &#125;; 编译器会为EmptyClass生成下面4个函数： 123456789101112131415class EmptyClass &#123;public: EmptyClass() &#123; &#125; ~EmptyClass() &#123; &#125; EmptyClass(const EmptyClass&amp; obj) &#123; &#125; EmptyClass&amp; operator= (const EmptyClass&amp; obj) &#123; &#125;&#125;; 当然，拷贝构造函数和赋值运算符函数体的内容由成员变量决定，假设有成员变量var1和var2，那么拷贝构造函数和赋值运算符的函数体如下： 123456789EmptyClass(const EmptyClass&amp; obj) : var1(obj.var1), var2(obj.var2)&#123; &#125;EmptyClass&amp; operator= (const EmptyClass&amp; obj) &#123; var1 = obj.var1; var2 = obj.var2; return *this;&#125; 当成员变量含有const或引用时，比如： 12345class SampleClass &#123;private: const int var1; double&amp; var2;&#125;; 这时候编译器会报错，告诉你无法提供合适的构造函数，因为对于const变量以及引用变量，需要在声明的时候初始化，而编译器提供的默认构造函数无法做到，可以改成下面的形式： 123456789class SampleClass &#123;private: const int var1; double&amp; var2;public: SampleClass(const int a = 0, double b = 0) : var1(a), var2(b)&#123; &#125;&#125;; 这样编译器就不会报错了，但是如果你使用赋值运算： 123SamleClass obj1;SamleClass obj2;obj2 = obj1; 编译器会提示”operator=”函数在SampleClass中不可用，这说明编译器没有为SampleClass生成赋值运算函数，因为var1和var2在初始化后，值不会再改变。但是拷贝构造是可以执行的，如: 12SampleClass obj1;SampleClass obj2(obj1); 上面这段代码是可以编译通过的，这是因为编译器会为SampleClass生成默认的拷贝构造函数： 123SampleClass(const SampleClass&amp; s) : var1(s.var1), var2(s.var2) &#123; &#125; 这种方法并不会破坏const和reference的特性。 总之，编译器会尽量去生成这4个成员函数，但如果成员变量出现了const和reference的成员变量，则编译器拒绝生成默认的构造函数和赋值运算符重载函数。","tags":[{"name":"C++","slug":"C","permalink":"https://glemontree.github.io/tags/C/"}]},{"title":"[C++] Effective_C++_条款06","date":"2017-06-28T10:09:52.000Z","path":"2017/06/28/[C++] Effective_C++_条款06/","text":"条款06：若不想使用编译器自动生成的函数，就应该明确拒绝 总有些情况，我们不希望编译器为我们生成拷贝构造函数和赋值函数，这时候我们就应该明确告诉编译器不要生成。 为了解决这个问题，我们可以自己写拷贝构造函数和赋值函数，这样编译器就不会为我们生成，但不能写在public里，因为public里的函数可以被外界调用，一种好的方法就是将其写在private或protected里： 123456789class HomeForSale &#123;private: HomeForSale(const HomeForSale&amp; house) &#123; ... &#125; HomeForSale&amp; operator= (const HomeForSale&amp; house) &#123; ... &#125;&#125;; 这样做的话编译器就不会为我们生成默认的拷贝构造函数和赋值函数了，又因为我们定义的两个函数是private属性，所以不用担心会在外部会被调用，下面的两条语句是无法编译的： 12HomeForSale house3(house1);house2 = house1; 另一方面，如果像上面这种写法，如果类中出现了友元函数或者友元类，它们也可以访问到private下的函数，此时可以将定义换成声明： 12345class HomeForSale &#123;private: HomeForSale(const HomeForSale&amp; house); HomeForSale&amp; operator= (const HomeForSale&amp; house);&#125;; 这样即使通过编译，链接器也会报错，因为只有声明而没有具体的实现。那么能不能直接把拷贝构造函数和赋值函数声明在public下，只是不实现？这样也是可以的，因为链接器不会放过这个只有空架子的声明而没有具体的实现，但这不是一种好的解决方法，因为编程的一个原则是：错误越早被发现越好，编译要早于链接，所以在编译阶段能发现的错误就不要拖到链接阶段。 总结一下，为了驳回编译器自动生成的函数，有以下两种做法： 将相应的成员函数声明为private且不实现 继承Uncopyable","tags":[{"name":"C++","slug":"C","permalink":"https://glemontree.github.io/tags/C/"}]},{"title":"[Qt] file:///的作用","date":"2017-06-28T10:08:22.000Z","path":"2017/06/28/[Qt] file的作用/","text":"本地文件传输协议，File协议主要用于访问本地计算机上的的文件，就如同在Windows资源管理器中打开文件一样。 要使用File协议，基本的格式如下：file:///文件路径。","tags":[{"name":"Qt, file:///","slug":"Qt-file","permalink":"https://glemontree.github.io/tags/Qt-file/"}]},{"title":"[Hexo] Hexo更换主题","date":"2017-06-28T10:07:25.000Z","path":"2017/06/28/[Hexo] Hexo更换主题/","text":"当更换主题后，若想让更换后的主题生效，可以执行下面这条命令：hexo d -g。","tags":[{"name":"Hexo, 主题","slug":"Hexo-主题","permalink":"https://glemontree.github.io/tags/Hexo-主题/"}]},{"title":"[html] div标签","date":"2017-06-28T10:06:31.000Z","path":"2017/06/28/[html] div标签/","text":"实例文档中的一个部分会显示绿色： 1234&lt;div style=\"color:#00FF00\"&gt; &lt;h3&gt;This is a header&lt;/h3&gt; &lt;p&gt;This is a paragraph.&lt;/p&gt;&lt;/div&gt; 定义和用法标签可定义文档中的分区或节(division/section) 标签可以把文档分隔为独立的、不同的部分 是一个块级元素，这意味着它的内容会自动的开始一个新行 案例分析123456789101112131415161718&lt;body&gt; &lt;h1&gt;NEWS WEBSITE&lt;/h1&gt; &lt;p&gt;some text. some text. some text...&lt;/p&gt; ... &lt;div class=\"news\"&gt; &lt;h2&gt;News headline 1&lt;/h2&gt; &lt;p&gt;some text, some text. some text...&lt;/p&gt; ... &lt;/div&gt; &lt;div class=\"news\"&gt; &lt;h2&gt;News headline 2&lt;/h2&gt; &lt;p&gt;some text, some text. some text...&lt;/p&gt; ... &lt;/div&gt; ...&lt;/body&gt; 例子解释上面这段HTML模拟了 新闻网站的结构，其中的每个div把每条新闻的标题和摘要组合在一起，也就是说，div为文档提供了额外的结构。同时，由于这些div属于同一类元素，所以可以使用class=”news”对这些div进行标识。","tags":[{"name":"html, div标签","slug":"html-div标签","permalink":"https://glemontree.github.io/tags/html-div标签/"}]},{"title":"[html] h标签","date":"2017-06-28T10:05:33.000Z","path":"2017/06/28/[html] h标签/","text":"实例六个不同的HTML标题 123456&lt;h1&gt;这是标题1&lt;/h1&gt;&lt;h2&gt;这是标题2&lt;/h2&gt;&lt;h3&gt;这是标题3&lt;/h3&gt;&lt;h4&gt;这是标题4&lt;/h4&gt;&lt;h5&gt;这是标题5&lt;/h5&gt;&lt;h6&gt;这是标题6&lt;/h6&gt; 定义和用法&lt;h&gt;标签可定义标题。&lt;h1&gt;定义最大的标题。&lt;h6&gt; 定义最小的标题。 标准属性1id, class, title, style, dir, lang, xml:lang 事件属性12onclick, ondblclick, onmousedown, onmouseup, onmouseover, onmousemove, onmouseout, onkeypress, onkeydown, onkeyup 例子例子112345678910111213141516&lt;html&gt;&lt;body&gt;&lt;h1&gt;This is heading 1&lt;/h1&gt;&lt;h2&gt;This is heading 2&lt;/h2&gt;&lt;h3&gt;This is heading 3&lt;/h3&gt;&lt;h4&gt;This is heading 4&lt;/h4&gt;&lt;h5&gt;This is heading 5&lt;/h5&gt;&lt;h6&gt;This is heading 6&lt;/h6&gt;&lt;p&gt;请仅仅把标题标签用于标题文本。不要仅仅为了产生粗体文本而使用它们。请使用其它标签或 CSS 代替。&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 运行结果如下： 12345678910111213This is heading 1This is heading 2This is heading 3This is heading 4This is heading 5This is heading 6请仅仅把标题标签用于标题文本。不要仅仅为了产生粗体文本而使用它们。请使用其它标签或 CSS 代替。 例子212345678910111213&lt;!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\"\"http://www.w3.org/TR/html4/loose.dtd\"&gt;&lt;html&gt;&lt;body&gt;&lt;h1 align=\"center\"&gt;This is heading 1&lt;/h1&gt;&lt;p&gt;上面的标题在页面中进行了居中排列。上面的标题在页面中进行了居中排列。上面的标题在页面中进行了居中排列。&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 运行结果如下： 123 This is heading 1上面的标题在页面中进行了居中排列。上面的标题在页面中进行了居中排列。上面的标题在页面中进行了居中排列。","tags":[{"name":"html, h标签","slug":"html-h标签","permalink":"https://glemontree.github.io/tags/html-h标签/"}]},{"title":"[html] img标签的alt属性","date":"2017-06-28T10:04:39.000Z","path":"2017/06/28/[html] img标签的alt属性/","text":"实例1&lt;img src=\"/i/eg_tulip.jpg\" alt=\"上海郁金香 - 郁金香\"/&gt; 如果无法显示图像，浏览器将显示替代文本： 此外，当用户把鼠标移到图像上方，最新的浏览器会在一个文本框中显示描述性文本。 定义和用法alt 属性是一个必需的属性，它规定在图像无法显示时的替代文本。 假设由于下列原因用户无法查看图像，alt 属性可以为图像提供替代的信息： 网速太慢 src 属性中的错误 浏览器禁用图像 用户使用的是屏幕阅读器 &lt;img&gt;标签的 alt 属性指定了替代文本，用于在图像无法显示或者用户禁用图像显示时，代替图像显示在浏览器中的内容。 我们强烈推荐您在文档的每个图像中都使用这个属性。这样即使图像无法显示，用户还是可以看到关于丢失了什么东西的一些信息。而且对于残疾人来说，alt 属性通常是他们了解图像内容的唯一方式。 语法1&lt;a alt=\"value\"&gt;","tags":[{"name":"html, img标签","slug":"html-img标签","permalink":"https://glemontree.github.io/tags/html-img标签/"}]},{"title":"[html] link标签","date":"2017-06-28T10:03:18.000Z","path":"2017/06/28/[html] link标签/","text":"概述link标签，当在文档中声明使用外接资源（比如CSS）时使用此标签，link是单独出现的 属性 href – 指定需要加载的资源(CSS文件)的地址URI media – 媒体类型 rel – 指定链接类型,设定是指对象和链接目标的关系,可选值, link还可以用Shortcut Icon等 rev – 指定链接类型 type – 指定所连接文档的MIME类型，css的MIME是type/css,一般使用type=”text/css” rel属性link标签中的rel属性，定义了文档和链接的关系，rel属性通常出现在a，link标签中，其通常具有下列属性值： Alternate – 定义交替出现的链接 Stylesheet – 定义一个外部加载的样式表 Start – 通知搜索引擎，文档的开始 … 实例链接一个外部样式表 123&lt;head&gt; &lt;link rel=\"stylesheet\" type=\"text/css\" href=\"theme.css\"/&gt;&lt;/head&gt; 其中，href用于指定需要加载的资源（比如CSS）的地址URI 定义和用法&lt;link&gt;标签定义文档与外部资源的关系 &lt;link&gt;标签最常见的用途是链接样式表 提示和注释此元素只能存在于head部分，不过它可以出现任意次","tags":[{"name":"html, link标签","slug":"html-link标签","permalink":"https://glemontree.github.io/tags/html-link标签/"}]},{"title":"[html] p标签","date":"2017-06-28T10:02:18.000Z","path":"2017/06/28/[html] p标签/","text":"实例以下代码标记了一个段落： 1&lt;p&gt;This is some text in a very short paragraph&lt;/p&gt; 定义和用法&lt;p&gt;标签定义段落 p元素会自动在其前后创建一些空白 例子例子11234567891011&lt;html&gt;&lt;body&gt;&lt;p&gt;这是段落。&lt;/p&gt;&lt;p&gt;这是段落。&lt;/p&gt;&lt;p&gt;这是段落。&lt;/p&gt;&lt;p&gt;段落元素由 p 标签定义。&lt;/p&gt; &lt;/body&gt;&lt;/html&gt; 运行结果如下： 1234567这是段落。这是段落。这是段落。段落元素由 p 标签定义。 例子2123456789101112131415161718&lt;html&gt;&lt;body&gt;&lt;h1&gt;春晓&lt;/h1&gt;&lt;p&gt; 春眠不觉晓， 处处闻啼鸟。 夜来风雨声， 花落知多少。&lt;/p&gt;&lt;p&gt;注意，浏览器忽略了源代码中的排版（省略了多余的空格和换行）。&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 运行结果如下： 12345春晓春眠不觉晓， 处处闻啼鸟。 夜来风雨声， 花落知多少。注意，浏览器忽略了源代码中的排版（省略了多余的空格和换行）。","tags":[{"name":"html","slug":"html","permalink":"https://glemontree.github.io/tags/html/"},{"name":"p标签","slug":"p标签","permalink":"https://glemontree.github.io/tags/p标签/"}]},{"title":"[html] span元素","date":"2017-06-28T10:01:27.000Z","path":"2017/06/28/[html] span元素/","text":"实例使用&lt;span&gt;元素对文本中的一部分进行着色： 1&lt;p&gt;我的母亲有&lt;span style=\"color:blue\"&gt;蓝色&lt;/span&gt;的眼睛。&lt;/p&gt; 标签定义及使用说明&lt;span&gt;用于对文档中的行内元素进行组合。 &lt;span&gt;标签没有固定的格式表现。当对它应用样式时，它才会产生视觉上的变化。如果不对&lt;span&gt;应用样式，那么 &lt;span&gt;元素中的文本与其他文本不会任何视觉上的差异。 &lt;span&gt; 标签提供了一种将文本的一部分或者文档的一部分独立出来的方式。","tags":[{"name":"html, span","slug":"html-span","permalink":"https://glemontree.github.io/tags/html-span/"}]},{"title":"[网络编程] IO多路复用","date":"2017-06-28T10:00:26.000Z","path":"2017/06/28/[网络编程] IO多路复用/","text":"阻塞IO和非阻塞IO常见的IO操作有read和write，通常IO操作都是阻塞I/O，即当前调用read时如果没有数据收到，那么线程或者进行就会被挂起，直到收到数据。 对于非阻塞I/O，通过fcntl（POSIX）或ioctl（UNIX）设为非阻塞模式，这时当你调用read时，如果有数据收到，就返回数据，如果没有数据收到，就立刻返回。 I/O多路复用多路复用是指使用一个线程来检查多个文件描述符（Socket）的就绪状态，比如调用select和poll函数，传入多个文件描述符，如果有一个文件描述符就绪，则返回，否则阻塞直到超时。得到就绪状态后进行真正的操作可以在同一个线程里执行，也可以启动线程执行（比如使用线程池）。 I/O多路复用又被称为事件驱动，操作系统提供了一个功能，当某个socket可读或者可写的时候，可以给你一个通知，这样当配合非阻塞的socket使用时，只有当系统通知我哪个描述符可读了，我才去执行read操作，可以保证每次read都能读到有效数据而不做纯返回-1和EAGAIN的无用功。 Poll介绍poll的机制与select类似，管理多个描述符也是进行轮询，根据描述符的状态进行处理，但是poll没有最大文件描述符数量的限制。poll和select的共同缺点就是包含大量文件描述符的数组被整体复制于用户态和内核的地址空间之间，而 不论这些文件描述符是否就绪，它的开销随着文件描述符数量的增加而线性增大。poll的函数原型如下： 12#include &lt;poll.h&gt;int poll(struct pollfd* fds, unsigned int fds, int timeout); 其中，pollfd结构体的定义如下： 12345struct pollfd &#123; int fd; // 文件描述符 short events; // 等待的事件 short revents; // 实际发生了的事件&#125;; 每一个pollfd结构体指定了一个被监视的文件描述符，可以传递多个结构体，指示poll()监视多个文件描述符，每个结构体的events域是监视该文件描述符的事件掩码，由用户设置。revents域是文件描述符的操作结果事件掩码，内核在调用返回时设置这个域，常见的事件如下： 12345678POLLIN 有数据可读POLLRDNORM 有普通数据可读POLLRDBAND 有优先数据可读POLLPRI 有紧迫数据可读POLLOUT 写数据不会导致阻塞POLLWRNORM 写普通数据不会导致阻塞POLLWRBAND 写优先数据不会导致阻塞POLLMSGSIGPOLL 消息可用 POLLIN | POLLPRI等价于select()的读事件，POLLOUT | POLLWRBAND等价于select()的写事件。如果要监视一个文件描述符是否可读和可写，我们可以设置events为POLLIN | POLLOUT。在poll返回时，我们可以检查revents中的标识，对应于文件描述符请求的events结构体。如果POLLIN事件被设置，则该文件描述符可以被读取而不阻塞；如果POLLOUT被设置，则文件描述符可以写入而不导致阻塞。 timeout参数指定等待的毫秒数，无论I/O是否准备好，poll都会返回。timeout指定为负数则表示无限超时，使poll()一直挂起直到一个指定事件发生；timeout为0则表示poll调用立即返回并列出准备好的I/O文件描述符，但并不等待其他的事件。 poll调用成功时，返回结构体的revents域不为0的文件描述符的个数；如果在超时前没有任何事件发生，poll()返回0；失败时返回-1。 Poll举例编写一个echo server程序，功能是客户端向服务器发送信息，服务器接收输出并原样返回给客户端，客户端接收到输出到终端。 服务端代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;errno.h&gt;#include &lt;netinet/in.h&gt;#include &lt;sys/socket.h&gt;#include &lt;poll.h&gt;#include &lt;unistd.h&gt;#include &lt;sys/types.h&gt;#define IPADDRESS \"127.0.0.1\"#define PORT 8787#define MAXLINE 1024#define LISTENQ 5#define OPEN_MAX 1000#define INFTIM -1static int socket_bind(const char* ip, int port);static void do_poll(int listenfd);static void handle_connection(struct pollfd* connfds, int num);int main(int argc, char** argv) &#123; int listenfd, connfd, sockfd; struct sockaddr_in cliaddr; socklen_t cliaddrlen; listenfd = socket_bind(IPADDRESS, PORT); listen(listenfd, LISTENQ); do_poll(listenfd); return 0;&#125;static int socket_bind(const char* ip, int port) &#123; int listenfd; struct sockaddr_in servaddr; listenfd = socket(AF_INET, SOCK_STREAM, 0); if (listenfd == -1) &#123; perror(\"socket error:\"); exit(1); &#125; bzero(&amp;servaddr, sizeof(servaddr)); servaddr.sin_family = AF_INET; inet_pton(AF_INET, ip, &amp;servaddr.sin_addr); servaddr.sin_port = htons(port); if (bind(listenfd, (struct sockaddr*)&amp;servaddr, sizeof(servaddr)) == -1) &#123; perror(\"bind error: \"); exit(1); &#125; return listenfd;&#125;static void do_poll(int listenfd) &#123; int connfd, sockfd; struct sockaddr_in cliaddr; socklen_t cliaddrlen; struct pollfd clientfds[OPEN_MAX]; int maxi; int i; int nready; clientfds[0].fd = listenfd; clientfds[0].events = POLLIN; for (i = 1; i &lt; OPEN_MAX; i++) &#123; clientfds[i].fd = -1; &#125; maxi = 0; for (; ;) &#123; nready = poll(clientfds, maxi + 1, INFTIM); if (nready == -1) &#123; perror(\"poll error: \"); exit(1); &#125; if (clientfds[0].revents &amp; POLLIN) &#123; cliaddrlen = sizeof(cliaddr); if ((connfd = accept(listenfd, (struct sockaddr*)&amp;cliaddr, &amp;cliaddrlen)) == -1) &#123; if (errno == EINTR) &#123; continue; &#125; else &#123; perror(\"accept error: \"); exit(1); &#125; &#125; fprintf(stdout, \"accept a new client: %s:%d\\n\", inet_ntoa(cliaddr.sin_addr), cliaddr.sin_port); for (i = 1; i &lt; OPEN_MAX; i++) &#123; if (clientfds[i].fd &lt; 0) &#123; clientfds[i].fd = connfd; break; &#125; &#125; if (i == OPEN_MAX) &#123; fprintf(stderr, \"too many clients.\\n\"); exit(1); &#125; clientfds[i].events = POLLIN; maxi = (i &gt; maxi ? i : maxi); if (--nready &lt;= 0) &#123; continue; &#125; &#125; handle_connection(clientfds, maxi); &#125;&#125;static void handle_connection(struct pollfd* connfds, int num) &#123; int i, n; char buf[MAXLINE]; memset(buf, 0, MAXLINE); for (i = 1; i &lt;= num; i++) &#123; if (connfds[i].fd &lt; 0) &#123; continue; &#125; if (connfds[i].revents &amp; POLLIN) &#123; n = read(connfds[i], fd, buf, MAXLINE); if (n == 0) &#123; close(connfds[i].fd); connfds[i].fd = -1; continue; &#125; write(STDOUT_FILENO, buf, n); write(connfds[i], fd, buf, n); &#125; &#125;&#125; 客户端代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include &lt;netinet/in.h&gt;#include &lt;sys/socket.h&gt;#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;stdlib.h&gt;#include &lt;poll.h&gt;#include &lt;time.h&gt;#include &lt;unistd.h&gt;#include &lt;sys/types.h&gt;#define MAXLINE 1024#define IPADDRESS \"127.0.0.1\"#define SERV_PORT 8787#define max(a, b) (a &gt; b) ? a : bstatic void handle_connection(int sockfd);int main(int argc, char* argv[]) &#123; int sockfd; struct sockaddr_in servaddr; sockfd = socket(AF_INET, SOCK_STREAM, 0); bzero(&amp;servaddr, sizeof(servaddr)); servaddr.sin_family = AF_INET; servaddr.sin_port = htons(SERV_PORT); inet_pton(AF_INET, IPADDRESS, &amp;servaddr.sin_addr); connect(sockfd, (struct sockaddr*)&amp;servaddr, sizeof(servaddr)); handle_connection(sockfd); return 0;&#125;static void handle_connection(int sockfd) &#123; char sendline[MAXLINE], recvline[MAXLINE]; int maxfdp, stdineof; struct pollfd pfds[2]; pfds[0].fd = sockfd; pfds[0].events = POLLIN; pfds[1].fd = STDIN_FILENO; pfds[1].events = POLLIN; for (; ;) &#123; poll(pfds, 2, -1); if (pfds[0].revents &amp; POLLIN) &#123; n = read(sockfd, recvline, MAXLINE); if (n == 0) &#123; fprintf(stderr,\"client: server is closed.\\n\"); close(sockfd); &#125; write(STDOUT_FILENO, recvline, n); &#125; //测试标准输入是否准备好 if (pfds[1].revents &amp; POLLIN) &#123; n = read(STDIN_FILENO, sendline, MAXLINE); if (n == 0) &#123; shutdown(sockfd, SHUT_WR); continue; &#125; write(sockfd, sendline, n); &#125; &#125;&#125;","tags":[{"name":"Linux, IO, 多路复用","slug":"Linux-IO-多路复用","permalink":"https://glemontree.github.io/tags/Linux-IO-多路复用/"}]},{"title":"[Java] Java反射为什么需要无参构造函数","date":"2017-06-28T09:59:14.000Z","path":"2017/06/28/[Java] Java反射为什么需要无参构造函数/","text":"Java反射为什么需要无参构造函数最近在学习Spring，Spring有个关键的技术就是IOC，即控制反转，其中用到得一个重要的技术就是反射，在学习的过程中发现如果不提供一个无参的构造函数程序会报错，查了一些资料后对Java反射为什么需要无参构造函数这一知识点进行记录。 一般来说反射是这样实现的： 12Class class = Class.forName(className);Object object = class.newInstance(); 因此，需要一个无参的构造器来生成对象。","tags":[{"name":"Java, 反射, 无参构造函数","slug":"Java-反射-无参构造函数","permalink":"https://glemontree.github.io/tags/Java-反射-无参构造函数/"}]},{"title":"[Linux] Linux epoll的用法","date":"2017-06-28T09:57:39.000Z","path":"2017/06/28/[Linux] Linux epoll的用法/","text":"Epoll的用法select与epoll在旧的Linux中，通常都在使用select来做事件触发，而在新的Linux内核中，开始使用epoll来代替。相比于select，epoll最大的好处就是不会随着监听fd数目的增长而降低效率。 当使用select时，它是采用轮询来处理的，轮询的fd数目越多，耗时越长，而且select同时监听的fd数目有限，通常为1024个，当然，这可以通过修改相关头文件然后对内核进行重新编译来解决。 epoll接口1. 创建epoll句柄1int epfd = epoll_create(int size); 创建一个epoll句柄，size用来告诉内核这个监听的数目一共多大。需要注意的是，当创建好epoll句柄后，它就是会占用一个fd值，在linux下如果查看/proc/进程ID/fd是能够看到这个fd的，所以在使用完epoll后，必须调用close()函数进行关闭，否则可能导致fd被耗尽。 该函数生成一个epoll专用的文件描述符，它其实是在内核申请一空间，用来存放你想关注的socket fd上是否发生以及发生了什么事件，size就是你在这个epoll fd上能关注的最大socket fd数目。 2. 将被监听的描述符添加到epoll句柄或从epoll句柄中删除 或者对监听事件进行修改1int epoll_ctl(int epfd, int op, int fd, struct epoll_event* event); 该函数用来控制某个epoll文件描述符上的事件，可以注册事件、修改事件和删除事件。其中，epfd为由epoll_create生成的epoll专用的文件描述符；op为要进行的操作注册事件，可能的取值有EPOLL_CTL_ADD注册、EPOLL_CTL_MOD修改、EPOLL_CTL_DEL删除；fd为关联的文件描述符；event为指向epoll_event的指针。 epoll和select的一个不同点就是select()是在监听事件时告诉内核要监听什么类型的事件，而epoll是先注册要监听的事件类型。 这里epoll_ctl的第四个参数为epoll_event类型，其定义如下： 1234567891011typedef union epoll_data &#123; void* ptr; int fd; __uint32_t u32; __uint64_t u64;&#125; epoll_data_t;struct epoll_event &#123; __uint32_t events; // Epoll events epoll_data_t data; // User data variable&#125;; events可以是以下几个宏的集合： 1234567EPOLLIN 触发该事件，表示对应的文件描述符上有可读数据EPOLLOUT 触发该事件，表示对应的文件描述符上可以写数据EPOLLPRI 表示对应的文件描述符有紧急的数据可读EPOLLERR 表示对应的文件描述符发生错误EPOLLHUP 表示对应的文件描述符被挂断EPOLLET 将EPOLL设置为边缘触发模式（Edge Triggered）EPOLLONESHOT 只监听一次事件，当监听完这次事件之后，如果还需要监听这个socket的话，需要再把这个 socket加入到EPOLL队列里 举个例子： 1234struct epoll_event ev;ev.data.fd = listenfd; // 设置与要处理的事件相关的文件描述符ev.events = EPOLLIN | EPOLLET; // 设置要处理的事件类型epoll_ctl(epfd, EPOLL_CTL_ADD, listenfd, &amp;ev); // 注册epoll事件 3. 等待事件触发，当超过timeout还没有事件触发时，就超时1int epoll_wait(int epfd, struct epoll_event* events, int maxevents, int timeout); 等待事件的产生，类似于select()调用，参数events用来从内核得到事件的集合，maxevents告诉内核这个events有多大（数组成员的个数），这个maxevents的值不能大于创建epoll_create()时的size，参数timeout是超时时间（毫秒，0会立即返回，-1将不确定）。 该函数返回需要处理的事件数目，如返回0表示已超时；返回的事件集合在events数组中，数组中实际存放的成员个数是函数的返回值。 epoll_wait运行的原理是：等待注册在epfd上的socket fd事件的发生，如果发生则将发生的socket fd和事件类型放入到events数组中，并且将注册在epfd上的 socket fd的事件类型清空，所以如果下一个循环你还要关注这个socket fd的话，则需要使用epoll_ctl(epfd, EPOLL_CTL_MOD, listenfd, &amp;ev)来重新设置socket fd的事件类型，这时不用EPOLL_CTL_ADD，因为socket fd并未清空，只是事件类型清空。","tags":[{"name":"Linux, EPoll","slug":"Linux-EPoll","permalink":"https://glemontree.github.io/tags/Linux-EPoll/"}]},{"title":"[Linux] Linux网络编程","date":"2017-06-28T09:56:40.000Z","path":"2017/06/28/[Linux] Linux网络编程/","text":"EPoll的两种工作模式本文主要包含两个方面： Linux中的EAGAIN错误码 EPoll的两种工作模式 一、EAGAIN从字面上来看，表示再试一次的意思，这个错误经常出现在当应用程序进行一些非阻塞操作（对文件或socket）的时候，例如以O_NONBLOCKING的标志打开文件/socket/FIFO，如果连续做read操作而没有数据可读，此时程序不会阻塞起来等待数据准备就绪返回，read函数会返回一个EAGAIN错误，提示你的应用程序现在没有数据可读请稍后再试。 二、EPoll的两种工作模式我们都知道EPoll有两种工作模式： ET（边沿触发） LT（水平触发） 其中，ET工作模式是高速工作模式，只支持no-block socket，在这种模式下，当描述符从未就绪变为就绪时，内核通过epoll通知，然后它会假设你知道文件描述符已经就绪，并且不再为这个文件描述符发送更多的就绪通知，等到下次有新的数据进来的时候才会再次再次通知你；而LT工作模式是默认的工作模式，并且同时支持block 和no-block socket，在这种工作模式下，内核告诉你一个文件描述符准备就绪了，然后你可以对这个就绪的fd进行IO操作，如果你不进行任何操作，内核还是会继续通知你的。 LT工作模式对代码编写要求比较低，并且不容易出现问题，但是它的问题就是它的效率低于ET工作模式，尤其在大并发、大流量的情况下。 ET工作模式效率非常高，在并发大流量的情况下，会比LT少很多的epoll的系统调用，但是对编程要求高，需要细致的处理每个请求，否则容易出现丢失事件的情况。 那么为什么ET工作模式只能使用非阻塞的socket呢？下面我以EPOLLIN事件为例进行说明：EPOLLIN事件只有当对端有数据写入时才会触发，所以触发一次后需要不断读取所有数据直到读完EAGAIN为止，否则剩下的数据只有在下次对端有写入时才能一起取出来了。并且EPOLLIN事件只有对端有新数据写入时才会触发一次，对于EPOLLIN事件，必须要将该文件描述符一直读到空，让error返回EAGAIN为止。 如果你的文件描述符不是非阻塞的，对于读，由于需要一直读直到把数据读完，所以大家在编写程序的时候一般会用一个循环一直读取socket，那么这个循环势必在最后一次阻塞，即没有数据可读的情况下，阻塞式socket会在据读完之后一直阻塞下去，而非阻塞式的socket则返回&lt;0，并让errno返回EAGAIN。 三、参考链接 EPoll的两种模式 使用epoll时需要将socket设为非阻塞吗？ epoll的两种模式详解 ​","tags":[{"name":"Linux, 网络编程, EPoll","slug":"Linux-网络编程-EPoll","permalink":"https://glemontree.github.io/tags/Linux-网络编程-EPoll/"}]},{"title":"[Linux] Linux中eventfd的使用","date":"2017-06-28T09:55:37.000Z","path":"2017/06/28/[Linux] Linux中eventfd的使用/","text":"Linux中eventfd的使用eventfd简介eventfd是用来实现多进程或多线程之间的事件通知的，常见的事件通知机制除了eventfd外，还有条件变量和管道等 方式。 条件变量必须和互斥锁相结合使用，使用起来较麻烦，并且条件变量不能像eventfd一样为I/O事件驱动。 管道可以和I/O复用很好的融合，但是管道比eventfd多用了一个文件描述符，而且 管道内核还得给其管理的缓冲区，eventfd则不需要。 event的主要接口 eventfd的接口形式如下： 1int eventfd(unsigned int initval, int flags); eventfd()创建一个文件描述符，这个文件描述符用户可以通过等待其可读来实现事件通知，该通知靠内核来响应用户空间的应用事件。上述接口的第一个参数是由内核来保持的64位计数器，这个计算器由参数initval来初始化，一般设为0。 第二个参数flags可以为EFD_NONBLOCK或EFD_CLOEXEC。 实例1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;sys/eventfd.h&gt;#include &lt;stdio.h&gt;#include &lt;pthread.h&gt;#include &lt;unistd.h&gt;int fd;uint64_t buffer;void threadFunc(void) &#123; int t; while (1) &#123; t = read(fd, &amp;buffer, sizeof(buffer)); if (sizeof(buffer) &lt; 8) &#123; printf(\"buffer错误\\n\"); &#125; printf(\"t = %11u buffer = %11u\\n\", t, buffer); if (t == 8) &#123; printf(\"唤醒成功\\n\"); &#125; &#125;&#125;int main() &#123; uint64_t buf = 1; int ret; pthread_t tid; if ((fd = eventfd(0, 0)) == -1) &#123; printf(\"创建失败\\n\"); &#125; if (pthread_create(&amp;tid, NULL, threadFunc, NULL) &lt; 0) &#123; printf(\"线程创建失败\\n\"); &#125; while (1) &#123; ret = write(fd, &amp;buf, sizeof(buf)); if (ret != 8) &#123; printf(\"写错误\\n\"); &#125; sleep(2); &#125; return 0;&#125;","tags":[{"name":"Linux, eventfd","slug":"Linux-eventfd","permalink":"https://glemontree.github.io/tags/Linux-eventfd/"}]},{"title":"[DB] MySQL UPDATE查询","date":"2017-06-28T09:54:26.000Z","path":"2017/06/28/[DB] MySQL UPDATE查询/","text":"语法1UPDATE table_name SET field1=new-value1, field2=new-value2 [WHERE Clause]; 可以同时更新一个或多个字段 可以在WHERE字句中指定任何条件 可以在一个单独表中同时更新数据 当需要更新数据表中指定行的数据时，WHERE字句是很有用的 实例1UPDATE runoob_tbl SET runoob_title=&apos;学习 C++&apos; WHERE runoob_id=3;","tags":[{"name":"MySQL UPDATE","slug":"MySQL-UPDATE","permalink":"https://glemontree.github.io/tags/MySQL-UPDATE/"}]},{"title":"[Qt] Qt中processEvents函数","date":"2017-06-28T09:53:28.000Z","path":"2017/06/28/[Qt] Qt中processEvents函数/","text":"什么情况下需要使用processEvents函数当我们在同一个线程中同时处理界面以及一些非常耗时的操作时，可能会出现界面无法响应，处于”假死“状态。通常解决这种现象的一种方法就是使用多线程，主线程专门负责界面，另开线程处理耗时的操作。在Qt中还有一种方法就是在耗时操作执行的过程中频繁调用QApplication::processEvents()函数，该函数的作用是让程序处理那些还没有处理的事件，然后再把使用权返回给调用者。 怎么使用processEvents函数下面举个简单的例子： 12345678910111213141516171819202122232425262728293031bool MyApp::writeFile(const QString &amp;filename)&#123; QFile file(filename); ... QApplication::setOverrideCursor(Qt::WaitCursor); QProgressDialog progress; progress.setWindowTitle(tableData-&gt;sNameCH); progress.setLabelText(QStringLiteral(\"数据保存中，请稍候...\")); //progress.setCancelButton(0);//不显示“取消”按钮 progress.setCancelButtonText(\"取消\"); progress.setRange(0,rowCount ); progress.setModal(true); //此处没有调用show()来显示，是因为QProgressDialog会自动决定是否显示 //如果时间过短，就不会显示。 for(int r = 0; r != rowCount; ++r) &#123; progress.setValue(row); //如果用户单击了“取消”,就取消保存文件，并删除该文件。 if(progress.wasCanceled) &#123; file.remov(); return false; &#125; for(int c = 0; c != colCount; ++c) &#123; out &lt;&lt; table(r,c); qApp.processEvents(); &#125; &#125; QApplication::restoreOverrideCursor();&#125; 参考资料本文参考自文章。","tags":[{"name":"Qt, processEvents","slug":"Qt-processEvents","permalink":"https://glemontree.github.io/tags/Qt-processEvents/"}]},{"title":"[Spring] Spring AOP编程理解","date":"2017-06-28T09:52:20.000Z","path":"2017/06/28/[Spring] Spring AOP编程理解/","text":"Spring AOP 编程理解一、AOP的理解最近在学习Spring，理解涉及到Spring的两大核心部分，一个是IOC（控制反转），另一个就是AOP（面向切面编程），今天主要讲一下什么是面向切面编程？ 在知乎上看到别人的回答，有句话觉得特别的有道理，“这种在运行时，动态地将代码切入到类的指定方法、指定位置上的编程思想就是面向切面的编程”。 到底什么是AOP呢？就是把逻辑代码和处理繁琐事务的代码分离开，以便能够分离复杂度，让人在同一时间只用思考代码逻辑，或者琐碎事务，代码逻辑比如插入一条数据，那么琐碎事务就包括获取连接和关闭连接，事务开始，事务提交。 一般而言，我们将切入到指定类指定方法的代码片称为切面，而切入到哪些类、哪些方法则叫切入点，有了AOP，就可以将几个类共有的代码抽取到一个切片中，等到需要的时候再切入到对象中取，从而改变原有的行为。 举个例子： 先假设你有一段逻辑代码要写，在这段代码之前要写log，代码完成之后要写log，结局就是一大堆的log淹没了逻辑代码，而AOP的思想就是将非逻辑部分的代码抽离出来，只考虑逻辑代码就行了。 和AOP对应的是OOP，对于OOP，其为从横向上区分出一个个的类，而AOP从纵向上向对象中加入特定的代码。 Spring实现的AOP是代理模式（后面会介绍一下代理模式），给调用者实际使用的是已经加工过的对象。 二、动态代理假设有这样几个类： ArithmeticCalculator.java 1234567// ArithmeticCalculator接口public interface ArithmeticCalculator &#123; int add(int i, int j); int sub(int i, int j); int mul(int i, int j); int div(int i, int j);&#125; 其有一个实现类： ArithmeticCalculatorImpl.java 1234567891011121314151617181920212223public class ArithmeticCalculatorImpl implements ArithmeticCalculator &#123; public int add(int i, int j) &#123; int result = i + j; return result; &#125; public int sub(int i, int j) &#123; int result = i - j; return result; &#125; public int mul(int i, int j) &#123; int result = i * j; return result; &#125; public int div(int i, int j) &#123; int result = i / j; return result; &#125;&#125; 若现在想实现这样的功能：在程序执行期间追踪正在发生的活动，此时代码将变为： ArithmeticCalculatorLoggingImpl.java 12345678910111213141516171819202122232425262728293031public class ArithmeticCalculatorLoggingImpl implements ArithmeticCalculator &#123; public int add(int i, int j) &#123; System.out.println(\"The method add begins with[\" + i + \",\" + j + \"]\"); int result = i + j; System.out.println(\"The method add ends with \" + result); return result; &#125; public int sub(int i, int j) &#123; System.out.println(\"The method sub begins with[\" + i + \",\" + j + \"]\"); int result = i - j; System.out.println(\"The method sub ends with \" + result); return result; &#125; public int mul(int i, int j) &#123; System.out.println(\"The method mul begins with[\" + i + \",\" + j + \"]\"); int result = i * j; System.out.println(\"The method mul ends with \" + result); return result; &#125; public int div(int i, int j) &#123; System.out.println(\"The method div begins with[\" + i + \",\" + j + \"]\"); int result = i / j; System.out.println(\"The method div ends with \" + result); return result; &#125;&#125; 这样大量的log就淹没了业务逻辑代码，并且代码存在大量的重复，且如果要修改日志，此必须对每一处进行修改，显然这不是一种好的解决方法。 这时候动态代理就可以粉墨登场了！！！ ArithmeticCalculatorLoggingProxy.java 1234567891011121314151617181920212223242526272829303132333435363738public class ArithmeticCalculatorLoggingProxy &#123; // 要代理的对象 private ArithmeticCalculator target; public ArithmeticCalculatorLoggingProxy(ArithmeticCalculator target) &#123; this.target = target; &#125; // 获取代码对象 public ArithmeticCalculator getLoggingProxy() &#123; ArithmeticCalculator proxy = null; // 因为此时的代理对象proxy并不是像普通的对象一样是通过new得到的，此时java虚拟机有默认的类加载器，而现在这个对象是通过Proxy.newProxyInstance()方法得到的，因此必须告诉java虚拟机这个代理对象是由哪个类加载期进行加载 ClassLoader loader = target.getClass().getClassLoader(); // 实际的代理类使用的哪个接口，即代理类是什么类型 Class[] interfaces = new Class[]&#123;ArithmeticCalculator.class&#125;; // 当调用代理对象其中的方法时，该执行的代码 InvocationHandler h = new InvocationHandler() &#123; /** * proxy: 正在返回的那个代理对象，一般情况下，在invoke方法中不使用该对象 * method：正在被调用的方法 * args: 调用方法时传入的参数 */ public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; String methodName = method.getName(); System.out.println(\"The method \" + methodName + \"begins with \" + Arrays.asList(args)); Object result = method.invoke(target, args); System.out.println(\"The method \" + methodName + \"ends with \" + result); return result; &#125; &#125;; proxy = (ArithmeticCalculator) Proxy.newProxyInstance(loader, interfaces, h); return proxy; &#125;&#125; 而此时的main函数如下： 1234567891011public class Main &#123; public static void main(String[] args) &#123; ArithmeticCalculator target = new ArithmeticCalculatorImpl(); ArithmeticCalculator proxy = new ArithmeticCalculatorLoggingProxy(target).getLoggingProxy(); int result = proxy.add(1, 2); System.out.println(\"--&gt;\" + result); result = proxy.div(4, 2); System.out.println(\"--&gt;\" + result); &#125;&#125; 此时，ArithmeticCalculatorImpl中的函数全部都是业务逻辑，而与业务逻辑无关的代码均在代理中，若想修改业务逻辑无关代码，只需要在ArithmeticCalculatorLoggingProxy中进行修改即可，而无需修改ArithmeticCalculatorImpl中的代码！","tags":[{"name":"Spring, AOP","slug":"Spring-AOP","permalink":"https://glemontree.github.io/tags/Spring-AOP/"}]},{"title":"[Spring] Spring JDBCTemplate","date":"2017-06-28T09:51:21.000Z","path":"2017/06/28/[Spring] Spring JDBCTemplate/","text":"JdbcTemplate简介 为了使JDBC更加易于使用，Spring在JDBC API定义了一个抽象层，以此建立一个JDBC存取框架 作为Spring JDBC框架的核心，JDBC模板的设计目的是为不同类型的JDBC操作提供模板方法，每个模板方法都能控制整个过程，并允许覆盖过程中的特定任务 JdbcTemplate的使用 加入jar包 c3p0-0.9.1.2.jar com.springsource.net.sf.cglib-2.2.0.jar com.springsource.org.aopalliance-1.0.0.jar com.springsource.org.aspectj.weaver-1.6.8.RELEASE.jar commons-logging-1.1.3.jar mysql-connector-java-5.1.7-bin.jar spring-aop-4.0.0.RELEASE.jar spring-aspects-4.0.0.RELEASE.jar spring-beans-4.0.0.RELEASE.jar spring-context-4.0.0.RELEASE.jar spring-core-4.0.0.RELEASE.jar spring-expression-4.0.0.RELEASE.jar spring-jdbc-4.0.0.RELEASE.jar spring-orm-4.0.0.RELEASE.jar spring-tx-4.0.0.RELEASE.jar spring-web-4.0.0.RELEASE.jar spring-webmvc-4.0.0.RELEASE.jar 建立DB属性文件db.properties（将数据库配置信息放置在Spring配置文件之外） 123456jdbc.user=xxxxjdbc.password=xxxxjdbc.driverClass=com.mysql.jdbc.Driverjdbc.jdbcUrl=jdbc:mysql:///xxxxjdbc.initPoolSize=xjdbc.maxPoolSize=x 创建applicationContext.xml文件 12345678910111213141516171819202122232425&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.0.xsd\"&gt; &lt;!--指定数据库配置文件的存放位置--&gt; &lt;context:property-placeholder location=\"classpath:db.properties\"/&gt; &lt;!--配置C3P0数据源--&gt; &lt;bean id=\"dataSource\" class=\"com.mchange.v2.c3p0.ComboPooledDataSource\"&gt; &lt;!--EL表达式获取--&gt; &lt;property name=\"user\" value=\"$&#123;jdbc.user&#125;\"&gt;&lt;/property&gt; &lt;property name=\"password\" value=\"$&#123;jdbc.password&#125;\"&gt;&lt;/property&gt; &lt;property name=\"jdbcUrl\" value=\"$&#123;jdbc.jdbcUrl&#125;\"&gt;&lt;/property&gt; &lt;property name=\"driverClass\" value=\"$&#123;jdbc.driverClass&#125;\"&gt;&lt;/property&gt; &lt;property name=\"initialPoolSize\" value=\"$&#123;jdbc.initPoolSize&#125;\"&gt;&lt;/property&gt; &lt;property name=\"maxPoolSize\" value=\"$&#123;jdbc.maxPoolSize&#125;\"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- 配置Spring的JdbcTemplate --&gt; &lt;bean id=\"jdbcTemplate\" class=\"org.springframework.jdbc.core.JdbcTemplate\"&gt; &lt;property name=\"dataSource\" ref=\"dataSource\"&gt;&lt;/property&gt; &lt;/bean&gt;&lt;/beans&gt; 建立实体类 Employee.java 1234567891011121314151617181920212223242526272829303132333435package com.glemontree.spring.jdbc;public class Employee &#123; private Integer id; private String lastName; private String email; private Department department; public Integer getId() &#123; return id; &#125; public void setId(Integer id) &#123; this.id = id; &#125; public String getLastName() &#123; return lastName; &#125; public void setLastName(String lastName) &#123; this.lastName = lastName; &#125; public String getEmail() &#123; return email; &#125; public void setEmail(String email) &#123; this.email = email; &#125; public Department getDepartment() &#123; return department; &#125; public void setDepartment(Department department) &#123; this.department = department; &#125; @Override public String toString() &#123; return \"Employee [id=\" + id + \", lastName=\" + lastName + \", email=\"+ email + \", department=\" + department + \"]\"; 1&#125; } 12345678910111213141516171819202122232425- Department.java ```java package com.glemontree.spring.jdbc; public class Department &#123; private Integer id; private String name; public Integer getId() &#123; return id; &#125; public void setId(Integer id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; @Override public String toString() &#123; return &quot;Department [id=&quot; + id + &quot;, name=&quot; + name + &quot;]&quot;; &#125; &#125; 建立单元测试类 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899 package com.glemontree.spring.jdbc; import java.nio.channels.SelectableChannel; import java.sql.SQLException; import java.util.ArrayList; import java.util.List; import javax.sql.DataSource; import javax.swing.text.DefaultEditorKit.InsertBreakAction; import org.junit.Test; import org.springframework.context.ApplicationContext; import org.springframework.context.support.ClassPathXmlApplicationContext; import org.springframework.jdbc.core.BeanPropertyRowMapper; import org.springframework.jdbc.core.JdbcTemplate; import org.springframework.jdbc.core.RowMapper; public class JdbcTest &#123; private ApplicationContext ctx = null; private JdbcTemplate jdbcTemplate; &#123; ctx = new ClassPathXmlApplicationContext(\"applicationContext.xml\"); jdbcTemplate = (JdbcTemplate) ctx.getBean(\"jdbcTemplate\"); &#125; @Test public void test() &#123; DataSource dataSource = ctx.getBean(DataSource.class); try &#123; System.out.println(dataSource.getConnection()); &#125; catch (SQLException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125; @Test public void testUpdate() &#123; String sql = \"UPDATE employees SET last_name = ? WHERE ID = ?\"; jdbcTemplate.update(sql, \"Jack\", 5); &#125; /*** 执行批量更新：批量INSERT，UPDAET，DELETE * 最后一个参数是Object[]的List类型，因为修改一条记录需要一个Object[]，那么多条就需要多个Object[]，即List&lt;Object[]&gt; */ @Test public void testBatchUpdate() &#123; String sql = \"INSERT INTO employees(last_name, email, dept_id) values(?,?,?)\"; List&lt;Object[]&gt; batchArgs = new ArrayList&lt;Object[]&gt;(); batchArgs.add(new Object[]&#123;\"AA\", \"aa@gmail.com\", 1&#125;); batchArgs.add(new Object[]&#123;\"BB\", \"bb@gmail.com\", 1&#125;); batchArgs.add(new Object[]&#123;\"CC\", \"cc@gmail.com\", 1&#125;); batchArgs.add(new Object[]&#123;\"DD\", \"dd@gmail.com\", 1&#125;); batchArgs.add(new Object[]&#123;\"EE\", \"ee@gmail.com\", 1&#125;); jdbcTemplate.batchUpdate(sql, batchArgs); &#125; /** * 从数据库中获取一条记录，实际得到对应的一个对象 * 注意：不是调用queryForObject(String sql, Class&lt;Employee&gt; requiredType, Object... args)方法 * 而需要调用queryForObject(String sql, RowMapper&lt;Employee&gt; rowMapper, Object... args) * 其中的RowMapper指定如何映射结果集的行，常用的实现类为BeanPropertyRowMapper * 使用SQL中列的别名完成列名和类的属性名的映射,例如last_name lastName * 不支持级联属性，JdbcTemplate到底是一个JDBC的一个小工具，而不是ORM框架 */ @Test public void QueryForObject() &#123; String sql = \"SELECT id, last_name lastName, email, dept_id as \\\"department.id\\\" FROM employees WHERE id = ?\"; RowMapper&lt;Employee&gt; rowMapper = new BeanPropertyRowMapper&lt;Employee&gt;(Employee.class); Employee employee = jdbcTemplate.queryForObject(sql, rowMapper, 1); System.out.println(employee); &#125; /** * 查找实体类的集合 * 注意调用的不是queryForList()方法 */ @Test public void testQueryForList() &#123; String sql = \"SELECT id, last_name lastName, email FROM employees WHERE id &gt; ?\"; RowMapper&lt;Employee&gt; rowMapper = new BeanPropertyRowMapper&lt;Employee&gt;(Employee.class); List&lt;Employee&gt; employees = jdbcTemplate.query(sql, rowMapper, 5); System.out.println(employees); &#125; /* * 获取单个列的值，或做统计查询 * 使用queryForObject(String sql, Class&lt;Long&gt; requiredType)方法 */ @Test public void testQueryForObject2() &#123; String sql = \"SELECT count(id) FROM employees\"; long count = jdbcTemplate.queryForObject(sql, Long.class); System.out.println(count); &#125;&#125; 在单元测试类中进行不同情况的测试，使用JdbcTemplate。 实际使用 123456789101112131415161718192021package com.glemontree.spring.jdbc;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.jdbc.core.BeanPropertyRowMapper;import org.springframework.jdbc.core.JdbcTemplate;import org.springframework.jdbc.core.RowMapper;import org.springframework.stereotype.Repository;@Repositorypublic class EmployeeDao &#123; @Autowired private JdbcTemplate jdbcTemplate; public Employee get(Integer id) &#123; String sql = \"SELECT id, last_name lastName, email FROM employees WHERE id = ?\"; RowMapper&lt;Employee&gt; rowMapper = new BeanPropertyRowMapper&lt;Employee&gt;(Employee.class); Employee employee = jdbcTemplate.queryForObject(sql, rowMapper, id); System.out.println(employee); return employee; &#125;&#125; 在JDBC模板中使用具名参数具名参数简介 在经典的JDBC语法中，SQL参数是用占位符?表示，并且受到位置的限制。定位参数的问题在于一旦参数的顺序发生变化，就必须改变参数绑定 在Spring JDBC框架中，绑定SQL参数的另一种选择是使用具名参数（named parameter） 具名参数：SQL按名称（以冒号开头）而不是按位置进行指定，具名参数更易于维护，也提升了可读性 具名参数只在NamedParameterJdbcTemplate中得到支持 使用方法 Spring配置文件中配置NamedParameterJdbcTemplate 1234&lt;!-- 配置NamedParameterJdbcTemplate，该对象可以使用具名参数，其没有无参构造器，必须为其构造器指定参数 --&gt;&lt;bean id=\"namedParameterJdbcTemplate\" class=\"org.springframework.jdbc.core.namedparam.NamedParameterJdbcTemplate\"&gt; &lt;constructor-arg ref=\"dataSource\"&gt;&lt;/constructor-arg&gt;&lt;/bean&gt; 测试 12345678910@Testpublic void testNamedParameterJdbcTemplate2() &#123; String sql = \"INSERT INTO employees(last_name, email, dept_id) VALUES(:lastName, :email, :deptId)\"; Employee employee = new Employee(); employee.setLastName(\"XYZ\"); employee.setEmail(\"xyz@gmail.com\"); employee.setDeptId(3); SqlParameterSource parameterSource = new BeanPropertySqlParameterSource(employee); namedParameterJdbcTemplate.update(sql, parameterSource);&#125; 注意具名参数使用:参数名来表示。 使用具名参数时可以使用update(String sql, SqlParameterSource paramSource)这个方法来进行更新操作： SQL语句中的参数名和类的属性名一致 使用SqlParameterSource的BeanPropertySqlParameterSource实现类作为参数","tags":[{"name":"Spring, JDBCTemplate","slug":"Spring-JDBCTemplate","permalink":"https://glemontree.github.io/tags/Spring-JDBCTemplate/"}]},{"title":"[Struts2] Struts中OGNL","date":"2017-06-28T09:50:24.000Z","path":"2017/06/28/[Struts2] Struts中OGNL/","text":"Struts中OGNL一、OGNL概念OGNL（Object Graph Navigation Language），即对象图导航语言，是一种功能强大的表达式语言，可以任意存取对象的属性或者调用对象的方法。 OGNL表达式的计算是围绕OGNL上下文进行的，OGNL上下文实际上是一个Map对象，由ognl.Context类来表示，它里面可以存放很多个JavaBean对象，它有一个上下文根对象，上下文中的根对象可以直接使用名来访问或直接使用它的属性名来访问它的属性值，否则要加前缀”#key”。 Struts的标签库都是使用OGNL表达式来访问ActionContext中的对象数据的。 Struts将ActionContext设置为OGNL上下文，并将值栈作为OGNL的根对象放置到ActionContext中。 二、值栈访问值栈中的对象不用“#”，Struts总是将当前Action实例放置在栈顶，所以在OGNL中引用Action中的属性也不需要“#”。 三、OGNL中三个重要的符号：#、%、$3.1 #符号 12345678910111213141516171819202122232425262728- 访问非根对象属性，例如#session.msg表达式，由于Struts中值栈被视为根对象，所以访问其他非根对象时，需要加#前缀，实际上#相当于ActionContext.getContext()，#session.msg 表达式相当于ActionContext.getContext().getSession().getAttribute(&quot;msg&quot;)；- 用于过滤和投影集合，如persons.&#123;?#this.age&gt;25&#125;, persons.&#123;?#this.name==&quot;pla1&quot;&#125;.&#123;age&#125;[0]；- 用于构造map，例如#&#123;&apos;foo1&apos;:&apos;bar1&apos;, &apos;foo2&apos;:&apos;bar2&apos;&#125;。 | 名称 | 作用 | 例子 | | ----------- | --------------------------------------- | ---------------------------------------- | | parameters | 包含当前HTTP请求的Map | ```#parameters.id[0]=request.getParameter(&quot;id&quot;)``` | | request | 包含当前HttpServletRequest属性的Map | ```#request.username=request.getAttribute(&quot;username&quot;)``` | | session | 包含当前HttpSession属性的Map | ```#session.username=session.getAttribute(&quot;username&quot;)``` | | application | 包含当前ServletContext属性的Map | ```#application.username=application.getAttribute(&quot;username&quot;)``` | | attr | 用于按照request&gt;session&gt;application的顺序访问其属性 | ```#attr.username```相当于按照顺序在以上三个范围内读取username的属性，直到找到为止 | 注意：也可以写成#request[&apos;username&apos;] #session[&apos;username&apos;] #application[&apos;username&apos;]### 3.2 %符号%符号的用途是在标志的属性为字符串类型时，计算OGNL表达式的值，即在struts字符串中用%&#123;&#125;指出，其内部是一个OGNL表达式，需要解析，例如：```jsp&lt;h3&gt;构造Map&lt;/h3&gt;&lt;s:set name=&quot;foobar&quot; value=&quot;#&#123;&apos;foo1&apos;:&apos;bar1&apos;,&apos;foo2&apos;:&apos;bar2&apos;&#125;&quot;/&gt;&lt;p&gt;The value of key &quot;fool&quot; is &lt;s:property value=&quot;#foobar[&apos;foo1&apos;]&quot;/&gt;&lt;/p&gt;&lt;p&gt;不使用%：&lt;s:url value=&quot;#foobar[&apos;foo1&apos;]&quot;/&gt;&lt;/p&gt;&lt;p&gt;使用%：&lt;s:url value=&quot;%&#123;#foobar[&apos;foo1&apos;]&#125;&quot;/&gt;&lt;/p&gt; 运行结果如下： 123the value of key &quot;fool&quot; is bar1不使用%：#foobar[&apos;foo1&apos;]使用%：bar1 3.3 $符号$符号有两个用途： 在国际化资源文件中，引用OGNL表达式，例如国际化资源文件中的代码：reg.agerange=国际化资源信息：年龄必须在${min}同${max}之间 在Struts 框架的配置文件中引用OGNL表达式。","tags":[{"name":"Struts2, OGNL","slug":"Struts2-OGNL","permalink":"https://glemontree.github.io/tags/Struts2-OGNL/"}]},{"title":"[TCP/IP] TCP与UDP不同的包处理方式","date":"2017-06-28T09:49:21.000Z","path":"2017/06/28/[TCPIP] TCP与UDP不同的包处理方式/","text":"TCP与UDP不同的包处理方式声明：本文转载自博客 UDP发包的问题 举个例子：udp发送两次数据，第一次发送100字节， 第二字发送200字节，接收方一次recvfrom(1000)，收到是100，还是200，还是300？ UDP是数据报文协议，是以数据包形式，所以每次可以接收100，200，在理想情况下，第一次是无论recvfrom多少都是接收到100，当然可能由于网络原因，第二个包先到的话，有可能是200了。对可能由于网络原因乱序，所以可能先收到200，所以自定义的udp协议包头里都要加上一个序列号，标识发送与收包对应。 TCP发包问题 举个例子：如果换成tcp, 第一次发送 100字节 ，第二次发送200字节，recv( 1000 )会接收到多少？ tcp是流协议，所以recv( 1000 )，会收到300 tcp自己处理好了重传，保证数据包的完整性 有分片的情况 举个例子：如果MTU是1500，使用UDP发送 2000，那么recvfrom(2000)是收到1500，还是2000? 还是接收2000，数据分片由ip层处理了，放到udp还是一个完整的包。接收到的包是由路由路径上最少的MTU来分片，注意转到UDP已经在是组装好的(组装出错的包会经crc校验出错而丢弃)，是一个完整的数据包 TCP粘包 举个例子：由于TCP是流协议，对于一个socket的包，如发送 10AAAAABBBBB两次，由于网络原因第一次又分成两次发送， 10AAAAAB和BBBB，如果接包的时候先读取10(包长度)再读入后续数据，当接收得快，发送的慢时，就会出现先接收了 10AAAAAB,会解释错误 ,再接到到BBBB10AAAAABBBBB，也解释错误的情况。这就是TCP的粘包。 解决的办法TLV方式，先接收包头，在包头里指定包体长度来接收。设置包头包尾的检查位（如群空间0x2开头，0x3结束来检查一个包是否完整）。对于TCP来说：1）不存在丢包，错包，所以不会出现数据出错 2）如果包头检测错误，即为非法或者请求，直接重置即可 ​","tags":[{"name":"Tcp, UDP, 包","slug":"Tcp-UDP-包","permalink":"https://glemontree.github.io/tags/Tcp-UDP-包/"}]},{"title":"[Qt] VS+Qt生成软件图标","date":"2017-06-28T09:48:17.000Z","path":"2017/06/28/[Qt] VS+Qt生成软件图标/","text":"在项目文件夹里创建名为*.rc的文件，如myapp.rc; 文件中写入IDI_ICON1 ICON DISCARDABLE “myapp.ico，其中，myapp.ico为图标的文件名； 将文件myapp.ico拷贝到项目文件夹内； 在解决方案资源管理器中，右键点击项目，添加myapp.rc及myapp.ico； 重新生成解决方案。","tags":[{"name":"VS, Qt, 软件图标","slug":"VS-Qt-软件图标","permalink":"https://glemontree.github.io/tags/VS-Qt-软件图标/"}]},{"title":"[C++] VS中出现未将对象引用设置到对象的实例","date":"2017-06-28T09:47:27.000Z","path":"2017/06/28/[C++] VS中出现未将对象引用设置到对象的实例/","text":"VS中出现未将对象引用设置到对象的实例具体什么原因我也不知道，在知乎上看到了有人回答了解决方案，依据他给的方法，成功解决： 在window中打开功能里输入regedit，回车打开注册器。然后进入如下路径中HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Control\\Lsa\\FipsAlgorithmPolicy， 将enable设置为0。 参考资料VS2015一新建项目就出现未将对象引用设置到对象的实例怎么办？","tags":[{"name":"C++, VS","slug":"C-VS","permalink":"https://glemontree.github.io/tags/C-VS/"}]},{"title":"[Qt] QWebView的使用","date":"2017-06-28T09:46:34.000Z","path":"2017/06/28/[Qt] QWebView的使用/","text":"Qt中使用QWebView在Qt中要使用QWebView必须经过一些配置，否则会出现error:C1083: 无法打开包括文件:”QWebView”这样的错误，这主要是因为QWebView、QWebFrame、QWebPage、QWebInspector等这些类被单独移到了QtWebKitWidgets模块，不再在QtWebKit模块当中。解决方法如下： 在*.pro文件中添加Qt += webkitwidgets； 在源文件中添加#include &lt;QtWebKitWidgets/QWebView&gt;。 VS中使用QWebView我个人比较喜欢在VS中开发Qt程序，不太喜欢Qt的界面，那么在VS中怎么使用QWebView呢？需要进行下面的配置： 在解决方案资源管理器中右键你的项目，选择Qt Project Settings； 选择“Qt Modules”选项卡，勾选WebKit和WebKit Widgets选项即可。","tags":[{"name":"Qt, QWebView, VS","slug":"Qt-QWebView-VS","permalink":"https://glemontree.github.io/tags/Qt-QWebView-VS/"}]},{"title":"[Android] WebView之loadDataWithBaseUrl()和loadUrl()","date":"2017-06-28T09:45:34.000Z","path":"2017/06/28/[Android] WebView之loadDataWithBaseUrl()和loadUrl()/","text":"前言在写WebView的时候，经常会使用WebView，好处主要有两个： 可以更改展现的内容（包括样式） 可以实现部分功能的跨平台 loadData()和loadDataWithBaseUrl()WebView使用比较简单，可以使用loadUrl()来加载一个Url地址，也可以使用loadData()和loadDataWithBaseURL()加载一段HTML代码片段。 从方法定义上来看： 1234&gt; public void loadData(String data, String mimeType, String encoding)&gt;&gt; public void loadDataWithBaseURL(String baseUrl, String data, String mimeType, String encoding, String historyUrl)&gt; loadDataWithBaseURL()比loadData()多两个参数，可以指定HTML代码片段中相关资源的相对根路径，也可以指定历史Url，两个方法的其余三个参数相同。 其次，两个方法加载的HTML代码片段有些不同，loadData()中的html data不能包含’#’，’%’，’\\’，’?’四种特殊字符，这就为我们内嵌css等制造了麻烦，因为css中经常用这四种字符，当然有方法解决，这里不介绍。 总结本文主要是介绍WebView在嵌入HTML代码时常用的两种方法loadData()和loadDataWithBaseURL()两种方法的区别，本文虽短，但主要是为自己做个笔记。谢谢！","tags":[{"name":"WebView, loadDataWithBaseUrl, loadUrl","slug":"WebView-loadDataWithBaseUrl-loadUrl","permalink":"https://glemontree.github.io/tags/WebView-loadDataWithBaseUrl-loadUrl/"}]},{"title":"[Windows核心编程] 如何编写Unicode源代码","date":"2017-06-28T09:44:40.000Z","path":"2017/06/28/[Windows核心编程] 如何编写Unicode源代码/","text":"如何编写Unicode源代码 标准的C运行期字符串函数，如strcpy、strchr和strcat只能对ANSI字符串进行操作，不能正确的处理Unicode字符串，因此，ANSI C拥有一组补充函数，例如： 12char* strcat(char*, const char*);wchar_t* wcscat(wchar_t*, const wchar_T*); 所有的Unicode函数均以wcs开头，wcs表示宽字符串 如果需要创建同时为ANSI何Unicode进行编译的单一源代码文件，必须包含TChar.h文件，而不是包含String.h文件。Tchar.h文件的唯一作用是帮助创建ANSI/Unicode通用源代码文件，它包含你应该用在源代码中的一组宏，而不应该直接调用str函数或wcs函数。如果在编译源代码文件中定义了_UNICODE，这些宏就会引用wcs这组函数，否则，引用str这组函数。 若要定义一个ANSI/Unicode通用的字符串数组，请使用下面的TCHAR数据类型。如果定义了_UNICODE，TCHAR将声明为下面的形式： 1typedef wchar_t TCHAR 如果没有定义_UNICODE，则TCHAR将声明为下面的形式： 1typedef char TCHAR 使用该数据类型，可以向下面这样拍分配一个字符串： 1TCHAR szString[100]; 也可以创建对字符串的指针： 1TCHAR* szError = \"Error\" 上面这行代码存在一个问题，如果没定义_UNICODE，该编译器将能正确的编译这一行代码；但是，如果定义了__UNICODE，将会产生一个错误。 若要生成一个Unicode字符串而不是ANSI字符串，必须将该代码改写成下面的样子： 1TCHAR* szError = L\"Error\"; 字符串前面的L用于告诉编译器该字符串作为Unicode字符串来编译，然而现在只有当定义了_UNICODE时程序才能正常编译。 我们需要另一个宏，以便有选择的在字符串前面加上大写字母L。这项工作由_TEXT宏来完成，__TEXT宏也在TChar.h文件中做了定义。如果定义了__UNICODE，那么__TEXT定义成下面的形式： 1#define _TEXT(X) L ## x 如果没有定义，则定义成下面这种形式： 1#define _TEXT(x) x Windows定义了以下的一些Unicode数据类型： WCHAR: Unicode字符 PWSTR 指向Unicode字符串的指针 PCWSTR 指向一个恒定的Unicode字符串的指针 这些数据类型是指Unicode字符和字符串，Windows头文件中也定义了ANSI/Unicode通用数据类型PTSTR和PCTSTR，这些数据类型既可以指ANSI字符串，也可以指Unicode字符串，这取决于当编译模块是否定义了UNICODE宏。 ​","tags":[{"name":"Unicode","slug":"Unicode","permalink":"https://glemontree.github.io/tags/Unicode/"}]},{"title":"[Windows核心编程] 谈谈Windows中的错误处理机制","date":"2017-06-28T09:43:44.000Z","path":"2017/06/28/[Windows核心编程] 谈谈Windows中的错误处理机制/","text":"谈谈Windows中的错误处理机制 windows除了使用返回值标识函数执行情况，还引入了错误代码机制。返回值指示函数是否发生了错误，而要想知道究竟发生了什么错误，就得使用错误代码。 windows将错误代码存储于独立于线程的，线程局部存储区中，也就是说这个区域时每个线程独有的其他线程无法更改，它存储着一些线程独有的东西。 在函数执行后，可通过GetLastError()函数来获得错误代码，并且这个代码永远反应的是上一个函数的执行情况，也就是说它的值是由上一个函数设置的，那么当调用一个函数后没有调用GetLastError()就调用其他函数，此时GetLastError()返回的就是第二个函数的执行情况。 1DWORD GetLastError(); GetLastError()返回的是一个DWORD类型的数，我们无法直接从返回值得知具体的错误是什么，VS中给我们地提供了一个小工具可以将错误代码转换为相应的文本描述。在VS中你可以这样操作：工具-错误查找，只要输入相应的DWORD类型数就可以得到具体的错误信息。 另外，windows提供了函数FormatMessage()可以将传入的错误代码转换为对应的字符串的首地址。 调用GetLastError()返回的是windows定义的错误代码，我们还可以将这种机制用于我们自己的函数中，比如现在写了一个函数，返回false表示调用失败，那么此时你还可以使用错误代码来提供更多的信息，通过使用SetLastError()可以设置我们想设置的值，它将线程局部存储区的错误代码设置为我们传递的值，此后调用GetLastError()返回的就是我们刚刚设置的值。 Windows.h中定义了256个错误代码用于标识256中错误情况，我们在使用SetLastError()时 ，可以传入windows定义过得大部分错误代码，如果所有这些均不能满足，你可以传入大于255的数作为错误代码。 调试程序时，可以在watch窗口中输入$err,hr，它会在value一列显示当前线程的上一个错误代码和该值对应的 文本描述。 本文参考ithzhang的博客，想知道更多的可以去阅读他的博客：ithzhang的博客","tags":[{"name":"C++, 错误处理","slug":"C-错误处理","permalink":"https://glemontree.github.io/tags/C-错误处理/"}]},{"title":"[多线程] x=y的原子性","date":"2017-06-28T09:42:51.000Z","path":"2017/06/28/[多线程] x=y的原子性/","text":"x=y的原子性一、原子性介绍所谓的原子性是指该操作不能再继续划分为更小的操作，在多线程中原子操作是一个很重要的概念，决定了该操作是否需要同步机制来进行保护。 二、x=y操作的原子性在X86中，x=y包含两个操作：读取y至寄存器，然后将该值写入x，其中读取y的值至寄存器中是原子的，将值写入x也是原子的，但是这里需要格外注意的是两个原子操作的组合不一定是原子操作，如果在这两步骤之间有另外一个线程更改了y的值，那么最终得到的结果就不是你想要的结果。 因此，在执行非原子操作时一定要加上同步操作来避免得到不可预料的结果。 三、参考资料本文参考自博客。","tags":[{"name":"多线程, 原子性","slug":"多线程-原子性","permalink":"https://glemontree.github.io/tags/多线程-原子性/"}]},{"title":"[Linux] zsh corrupt","date":"2017-06-28T09:41:39.000Z","path":"2017/06/28/[Linux] zsh corrupt/","text":"Linux中zsh遇到corrupt bug这几天打开ubuntu，出现zsh: corrupt history file /home/gtp/.zsh_history的错误，网上找到了解决方案，这里记录一下，以防以后遇到了又得花时间在网上搜索解决方案。 解决方案如下： 123mv .zsh_history .zsh_history_badstrings .zsh_history_bad &gt; .zsh_historyfc -R .zsh_history 感谢HIT-Lori提供的解决方案。","tags":[{"name":"Linux, zsh","slug":"Linux-zsh","permalink":"https://glemontree.github.io/tags/Linux-zsh/"}]},{"title":"[设计模式] 单例模式","date":"2017-06-28T09:40:04.000Z","path":"2017/06/28/[设计模式] 单例模式/","text":"懒汉模式即第一次调用该类实例的时候才产生一个新的该类实例，并在以后仅返回此实例。需要用锁，来保证其线程安全性。原因：多个线程可能进入判断是否已经存在实例的if语句，从而non thread safety。使用double-check来保证thread safety。但是如果处理大量数据时，该锁才成为严重的性能瓶颈。 静态成员实例的懒汉模式： 12345678910111213141516171819202122 1 class Singleton 2 &#123; 3 private: 4 static Singleton* m_instance; 5 Singleton()&#123;&#125; 6 public: 7 static Singleton* getInstance(); 8 &#125;; 9 10 Singleton* Singleton::getInstance()11 &#123;12 if(NULL == m_instance)13 &#123;14 Lock();//借用其它类来实现，如boost15 if(NULL == m_instance)16 &#123;17 m_instance = new Singleton;18 &#125;19 UnLock();20 &#125;21 return m_instance;22 &#125; 内部静态实例的懒汉模式 这里需要注意的是，C++0X以后，要求编译器保证内部静态变量的线程安全性，可以不加锁。但C++ 0X以前，仍需要加锁。 12345678910111213 1 class SingletonInside 2 &#123; 3 private: 4 SingletonInside()&#123;&#125; 5 public: 6 static SingletonInside* getInstance() 7 &#123; 8 Lock(); // not needed after C++0x 9 static SingletonInside instance;10 UnLock(); // not needed after C++0x11 return instance; 12 &#125;13 &#125;; 饿汉模式即无论是否调用该类的实例，在程序开始时就会产生一个该类的实例，并在以后仅返回此实例。由静态初始化实例保证其线程安全性，WHY？因为静态实例初始化在程序开始时进入主函数之前就由主线程以单线程方式完成了初始化，不必担心多线程问题。故在性能需求较高时，应使用这种模式，避免频繁的锁争夺。 1234567891011121314 1 class SingletonStatic 2 &#123; 3 private: 4 static const SingletonStatic* m_instance; 5 SingletonStatic()&#123;&#125; 6 public: 7 static const SingletonStatic* getInstance() 8 &#123; 9 return m_instance;10 &#125;11 &#125;;12 13 //外部初始化 before invoke main14 const SingletonStatic* SingletonStatic::m_instance = new SingletonStatic; 参考资料本文转载自C++线程安全的单例模式。","tags":[{"name":"C++, 线程安全, 单例模式","slug":"C-线程安全-单例模式","permalink":"https://glemontree.github.io/tags/C-线程安全-单例模式/"}]},{"title":"[多线程] 互斥对象和锁","date":"2017-06-28T09:38:55.000Z","path":"2017/06/28/[多线程] 互斥对象和锁/","text":"互斥对象和锁锁互斥对象的主要操作有两个，即加锁(lock)和解锁(unlock)。当一个线程对互斥对象进行lock操作并成功获得这个互斥对象的所有权，在此线程对此对象unlock前，其他线程对这个互斥对象的lock操作都会被阻塞。 多个互斥对象加锁有些倾向需要对多个互斥对象进行加锁，考虑下面的代码： 12345678910std::mutex mt1, mt2;&#123; std::lock_guard&lt;std::mutex&gt; lock1(mt1); std::lock_guard&lt;std::mutex&gt; lock2(mt2);&#125;&#123; std::lock_guard&lt;std::mutex&gt; lock1(mt2); std::lock_guard&lt;std::mutex&gt; lock2(mt1);&#125; 上面程序中，如果线程1执行到第4行的时候恰好线程2执行到第8行，那么就会出现下面的情况： 线程1持有mt1，等待mt2 线程2持有mt2，等待mt1 线程1和线程2持有各自的mutex，互不松手，导致两个线程谁也运行不了，造成死锁现象。 通常情况，要含有多个互斥对象时，为了避免死锁，要求在多个线程中进行加锁时应保证其先后顺序一致，如下： 12345678910std::mutex mt1, mt2;&#123; std::lock_guard&lt;std::mutex&gt; lock1(mt1); std::lock_guard&lt;std::mutex&gt; lock2(mt2);&#125;&#123; std::lock_guard&lt;std::mutex&gt; lock1(mt1); std::lock_guard&lt;std::mutex&gt; lock2(mt2);&#125; 这样的话，即使线程1执行到第4行的时候线程2执行到第8行，由于互斥对象mt1已经被上锁，线程2只能等待线程1释放mt1，因此也就不会出现前面例子所说的死锁现象。 其实更好的做法是使用标准库中的std::lock和std::try_lock函数对多个互斥对象进行加锁，std::lock()可以对多个互斥对象一次性进行加锁。std::lock会使用一种避免死锁的算法对多个待加锁对象进行lock操作，当待加锁的对象中有不可用对象时std::lock会阻塞当前线程直到所有对象都可用。代码如下： 123456789101112std::mutex mt1, mt2;&#123; std::unique_lock&lt;std::mutex&gt; lock1(mt1, std::defer_lock); std::unique_lock&lt;std::mutex&gt; lock2(mt2, std::defer_lock); std::lock(lck1, lck2);&#125;&#123; std::unique_lock&lt;std::mutex&gt; lock1(mt1, std::defer_lock); std::unique_lock&lt;std::mutex&gt; lock2(mt2, std::defer_lock); std::lock(lck2, lck1);&#125;","tags":[{"name":"C++, 多线程, 互斥对象, 锁","slug":"C-多线程-互斥对象-锁","permalink":"https://glemontree.github.io/tags/C-多线程-互斥对象-锁/"}]},{"title":"[多线程] 互斥量和临界区的区别","date":"2017-06-28T09:37:33.000Z","path":"2017/06/28/[多线程] 互斥量和临界区的区别/","text":"互斥量和临界区的区别 通常有4种进程或线程同步互斥的控制方法，它们是： 临界区 互斥量 信号量 事件 其中临界区通过对多线程的串行化来访问公共资源或一段代码，速度快；互斥量为协调共同对一个共享资源的访问而设计的；信号量为控制一个具有有限数量用户资源而设计；事件则用来线程有一些事件已经发生，从而启动后继任务的开始。 今天我们主要对临界区和互斥量的异同点进行介绍，因为这两个实在太像了。 临界区 临界区用来保证在同一时刻只有一个线程可以访问到资源，对于临界区进行操作的函数有两个： EnterCriticalSection(); LeaveCriticalSection(); 临界区最大的特色是其同步速度很快，但是其只能用来同步本进程内的线程，而不可用来同步多个进程中的线程。 互斥量 互斥量和临界区很相似，只有拥有互斥对象的线程才具有访问资源的权限，互斥量比临界区负责，并且互斥量是可以命名的，因此互斥量不仅仅可以用于同一应用程序不同线程中资源的同步，也可以用于不同应用程序的线程之间实现对资源的同步。 因此互斥量可以在整个系统中被任意进程的任意线程访问到，但它严格限定只有获取了互斥量的线程才能释放该互斥量。 参考资料 临界区，互斥量，信号量，事件的区别 信号量、互斥量和临界区访问范围上的差别","tags":[{"name":"多线程, 互斥量, 临界区","slug":"多线程-互斥量-临界区","permalink":"https://glemontree.github.io/tags/多线程-互斥量-临界区/"}]},{"title":"[编程规范] 函数","date":"2017-06-28T09:36:14.000Z","path":"2017/06/28/[编程规范] 函数/","text":"对所调用函数的错误返回码需要仔细、全面的处理； 明确函数功能，精确地实现函数设计； 编写可重入函数时，应注意局部变量的使用，不应使用static局部变量，否则必须经过特殊处理，才能使函数具有可重入性； 编写可重入函数时，若使用全局变量，则应通过关中断、信号量（即P、V操作）等手段加以保护，若对所使用的全局变量不加以保护，则此函数不具有可重入性，即当多个进程调用此函数时，很有可能使有关全局变量变为不可知状态； 在同一项目组应明确规定对接口函数参数的合法性检查应由函数的调用者负责还是由接口函数本身负责，缺省是由函数调用者负责，注意函数参数检查的必要性，这对于减少代码错误很有帮助； 防止将函数的参数作为工作变量，最好先用局部变量代之，最后再将局部变量的内容赋值给该参数； 一个函数仅完成一件功能； 为简单功能编写函数，虽然为仅用一两行就可完成的功能去编写函数好像没必要，但用函数可使功能明确化，增加程序可读性，举个例子： 1value = (a &gt; b) ? a : b; //该语句的功能不很明显 修改如下： 1234int max(int a, int b) &#123; return ((a &gt; b) ? a : b);&#125;value = max(a, b); 不要设计多用途面面俱到的函数； 函数的功能应该是可以预测的，也就是说只要输入数据相同就应产生同样的输出； 避免设计多参数函数，不使用的参数从接口中去掉，目的是减少函数间接口的复杂度； 检查函数所有参数输入的有效性； 检查函数所有非参数输入的有效性，如数据文件、公共变量等，函数在使用输入之前，应进行必要的检查； 函数名应准确描述函数的功能； 使用动宾词组为执行某操作的函数命名，如果是OOP方法，可以只有动词，名词是对象本身； 避免使用无意义或含义不清的动词为函数命名，如process、handle等为函数命名，因为这些动词并没有说明要具体做什么； 函数的返回值要清楚、明了，函数的每种出粗返回值的意义要清晰、明了、准确，防止使用者误用、理解错误； 防止把没有关联的语句放在一个函数中，防止函数或过程内出现随机内聚，随机内聚是指没有关联或关联很弱的语句放到同一个函数或过程中，随机内聚给函数或过程的维护、测试及以后的升级等造成了不便，同时也使函数或过程的功能不明确。在编程时，经常遇到在不同函数中使用相同的代码，许多开发人员都愿意把这些代码提取出来，并构成一个新的函数，若这些代码关联较大并且是完成一个功能的，那么这种构造是合理的，否则这种构造将产生随机内聚的函数，例如： 123456void Init_Var(void) &#123; Rect.length = 0; Rect.width = 0; Point.x = 10; Point.y = 10;&#125; 矩形的长、宽与点的坐标基本没有任何关系，所以以上函数是随机内聚，应分成两个函数： 123456789void Init_Rect(void) &#123; Rect.length = 0; Rect.width = 0;&#125;void Init_Point(void) &#123; Point.x = 10; Point.y = 10;&#125; 如果多段代码重复做同一件事情，那么在函数的划分上可能存在问题，可考虑把这段代码构造成一个新的函数； 功能不明确较小的函数，特别是仅有一个上级函数调用它时，应考虑把它合并到上级函数中，而不必单独存在； 设计高扇入、合理扇出的函数，扇出是指一个函数直接调用其他函数的数目，而扇入函数是指有多少上级函数调用它，扇出过大，表明函数过于复杂，需要控制和协调过多的下级函数，而扇出过小，如总是1，表明系统的调用层次可能过多，这样不利于程序阅读和函数结构的分析，函数较合理的扇出通常是3~5； 减少函数本身或函数间的递归调用； 改进模块中函数的结构，降低函数间的耦合度，并提高函数的独立性和代码可读性、效率和可维护性，应尽量提高函数的内聚性，单一功能的函数内聚性最高； 避免使用BOOL参数，其一是BOOL参数无意义，调用时很难知道该参数到底传达的是什么意思，其二是BOOL参数值不利于扩充； 当一个过程（函数）中对较长变量（一般是结构的成员）有较多引用时，可以用一个意义相当的宏代替；","tags":[{"name":"C++, 编程规范","slug":"C-编程规范","permalink":"https://glemontree.github.io/tags/C-编程规范/"}]},{"title":"[Spring] 基于注解来配置Bean","date":"2017-06-28T09:32:52.000Z","path":"2017/06/28/[Spring] 基于注解来配置Bean/","text":"Bean的配置方式 基于XML文件的方式 基于注解的方式（基于注解配置Bean，基于注解来装配Bean的属性） 在classpath中扫描组件 组件扫描：Spring能够从classpath下自动扫描、侦测和实例化具有特定注解的组件 特定组件包括： @component：基本注解，标识了一个受Spring管理的组件 @Respositoy：标识持久层组件 @Service：标识服务层组件 @Controller：标识表现层组件 对于扫描到的组件，Spring有默认的命名规则，使用非限定类名，第一个字母小写，也可以在注解中通过value属性标识组件的名称 当在组件类中使用了特定的注解后，还需要在Spring的配置文件中声明&lt;context:component-scan&gt;： TestObject.java 12345678package com.glemontree.spring.annotation;import org.springframework.stereotype.Component;@Componentpublic class TestObject &#123;&#125; UserController.java 12345678910package com.glemontree.spring.annotation.controller;import org.springframework.stereotype.Controller;@Controllerpublic class UserController &#123; public void execute() &#123; System.out.println(\"UserController execute...\"); &#125;&#125; UserRepository.java UserRepositoryImpl.java 12345package com.glemontree.spring.annotation.repository;public interface UserRepository &#123; void save();&#125; 12345678910111213package com.glemontree.spring.annotation.repository;import org.springframework.stereotype.Repository;@Repository(\"userRepository\")public class UserRepositoryImpl implements UserRepository &#123; public void save() &#123; // TODO Auto-generated method stub System.out.println(\"UserRepository Save...\"); &#125;&#125; UserService.java 12345678910package com.glemontree.spring.annotation.sevice;import org.springframework.stereotype.Service;@Servicepublic class UserService &#123; public void add() &#123; System.out.println(\"UserService add...\"); &#125;&#125; 配置文件： 12345678910&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.0.xsd\"&gt; &lt;!--扫描com.glemontree.spring.annotation包及其子包--&gt; &lt;context:component-scan base-package=\"com.glemontree.spring.annotation\"&gt; &lt;/context:component-scan&gt;&lt;/beans&gt; 测试方法 12345678910111213141516171819202122232425package com.glemontree.spring.annotation;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;import com.glemontree.spring.annotation.controller.UserController;import com.glemontree.spring.annotation.repository.UserRepository;import com.glemontree.spring.annotation.sevice.UserService;public class Main &#123; public static void main(String[] args) &#123; ApplicationContext ctx = new ClassPathXmlApplicationContext(\"beans-annotation.xml\"); TestObject to = (TestObject) ctx.getBean(\"testObject\"); System.out.println(to); UserController uc = (UserController) ctx.getBean(\"userController\"); System.out.println(uc); UserService us = (UserService) ctx.getBean(\"userService\"); System.out.println(us); UserRepository ur = (UserRepository) ctx.getBean(\"userRepository\"); System.out.println(ur); &#125;&#125; 解析： base-package：指定一个需要扫描的基类包，Spring将会扫描这个基类包里极其子包里的所有类 当需要扫描多个包时，可以使用逗号分隔 如果仅希望扫描特定的类而非基包下的所有类，可使用resource-pattern属性过滤特定的类： 1234&lt;!--可以通过resource-pattern指定扫描的资源--&gt;&lt;context:component-scan base-package=\"com.glemontree.spring.beans\" resource-pattern:\"autowire/*.class\"/&gt; &lt;context:include-filter&gt;子结点表示包含哪些指定表达式的组件，该子结点需要use-default-filter配合使用，即设置&lt;context:component-scan&gt;的use-default-filter属性为false； 123456789101112&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.0.xsd\"&gt; &lt;context:component-scan base-package=\"com.glemontree.spring.annotation\" use-default-filters=\"false\"&gt; &lt;context:include-filter type=\"annotation\" expression=\"org.springframework.stereotype.Repository\"/&gt; &lt;/context:component-scan&gt;&lt;/beans&gt; &lt;context:exclude-filter&gt;子结点表示排除哪些指定表达式的组件； 123456789101112&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.0.xsd\"&gt; &lt;context:component-scan base-package=\"com.glemontree.spring.annotation\"&gt; &lt;!--不包含标注了@Repository的类--&gt; &lt;context:exclude-filter type=\"annotation\" expression=\"org.springframework.stereotype.Repository\"/&gt; &lt;/context:component-scan&gt;&lt;/beans&gt; &lt;context:component-scan&gt;下可以包含多个&lt;context:include-filter&gt;和&lt;context:exclude-filter&gt;子结点 &lt;context:include-filter&gt;和&lt;context:exclude-filter&gt;子结点支持多种类型的过滤表达式，常用的有： annotation：所有标注了xxxAnnotation的类 123456789101112&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.0.xsd\"&gt; &lt;context:component-scan base-package=\"com.glemontree.spring.annotation\"&gt; &lt;!--不包含标注了@Repository的类--&gt; &lt;context:exclude-filter type=\"annotation\" expression=\"org.springframework.stereotype.Repository\"/&gt; &lt;/context:component-scan&gt;&lt;/beans&gt; assinable：所有继承或扩展xxxService的类 123456789101112131415161718&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.0.xsd\"&gt; &lt;!-- &lt;context:component-scan base-package=\"com.glemontree.spring.annotation\" use-default-filters=\"false\"&gt; &lt;context:include-filter type=\"annotation\" expression=\"org.springframework.stereotype.Repository\"/&gt; &lt;/context:component-scan&gt; --&gt; &lt;context:component-scan base-package=\"com.glemontree.spring.annotation\" use-default-filters=\"true\"&gt; &lt;!--排除所有UserRepository和继承自UserRepository的类--&gt; &lt;context:exclude-filter type=\"assignable\" expression=\"com.glemontree.spring.annotation.repository.UserRepository\"/&gt; &lt;/context:component-scan&gt;&lt;/beans&gt; 1234567891011121314151617&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.0.xsd\"&gt; &lt;!-- &lt;context:component-scan base-package=\"com.glemontree.spring.annotation\" use-default-filters=\"false\"&gt; &lt;context:include-filter type=\"annotation\" expression=\"org.springframework.stereotype.Repository\"/&gt; &lt;/context:component-scan&gt; --&gt; &lt;context:component-scan base-package=\"com.glemontree.spring.annotation\" use-default-filters=\"false\"&gt; &lt;context:include-filter type=\"assignable\" expression=\"com.glemontree.spring.annotation.repository.UserRepository\"/&gt; &lt;/context:component-scan&gt;&lt;/beans&gt; 组件装配&lt;context:component-scan&gt;元素还会自动注册AutowiredAnnotationBeanPostProcessor实例，该实例可以自动装配具有@Autowired和@Resource、@Inject注解的属性。 Autowired：可以自动装配具有兼容类型的单个Bean属性 构造器、普通字段（即使是非public）以及一切具有参数的方法都可以应用@Autowired注解 默认情况下，所有使用@Autowired注解的属性都要被设置，当Spring找不到匹配的Bean装配属性时，会抛出异常，若某一属性允许不被设置，可以设置@Autowired注解的required属性为false 默认情况下，当IOC容器里存在多个类型兼容Bean时，通过类型的自动装配将无法工作，此时可以在@Qualifier注解里提供Bean的名称，Spring允许对方法的入参标注@Qualifier以指定注入Bean的名称： 1234567891011121314151617181920212223package com.glemontree.spring.annotation.sevice;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.beans.factory.annotation.Qualifier;import org.springframework.stereotype.Service;import com.glemontree.spring.annotation.repository.UserRepository;@Servicepublic class UserService &#123; private UserRepository userRepository; @Autowired @Qualifier(\"userRepositoryImpl\") // 通过@Qualifier指定Bean的名称，注意是bean的名称而不是类的名称 public void setUserRepository(UserRepository userRepository) &#123; this.userRepository = userRepository; &#125; public void add() &#123; System.out.println(\"UserService add...\"); userRepository.save(); &#125;&#125; 另外一种写法如下： 1234567891011121314151617181920212223package com.glemontree.spring.annotation.sevice;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.beans.factory.annotation.Qualifier;import org.springframework.stereotype.Service;import com.glemontree.spring.annotation.repository.UserRepository;@Servicepublic class UserService &#123; private UserRepository userRepository; // 将@Qualifier写在入参的前面 @Autowired public void setUserRepository(@Qualifier(\"userRepositoryImpl\")UserRepository userRepository) &#123; this.userRepository = userRepository; &#125; public void add() &#123; System.out.println(\"UserService add...\"); userRepository.save(); &#125;&#125; 泛型依赖注入 BaseRepository.java 12345package com.glemontree.spring.generic.di;public class BaseRepository&lt;T&gt; &#123;&#125; BaseService.java 12345678910111213package com.glemontree.spring.generic.di;import org.springframework.beans.factory.annotation.Autowired;public class BaseService&lt;T&gt; &#123; // BaseService依赖于BaseRepository，通过@Autowired建立关系 @Autowired protected BaseRepository&lt;T&gt; repository; public void add() &#123; System.out.println(\"add...\"); System.out.println(repository); &#125;&#125; User.java 12345package com.glemontree.spring.generic.di;public class User &#123;&#125; UserRepositpry.java 123456789package com.glemontree.spring.generic.di;import org.springframework.stereotype.Repository;// 通过@Repository注解注册bean@Repositorypublic class UserRepository extends BaseRepository&lt;User&gt;&#123;&#125; UserService.java 123456789package com.glemontree.spring.generic.di;import org.springframework.stereotype.Service;// 通过@Service注解注册bean@Servicepublic class UserService extends BaseService&lt;User&gt;&#123; &#125; beans-generic-di.xml 12345678910&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.0.xsd\"&gt;// 通过下面这段话UserRepository和UserService两个bean会被注册&lt;context:component-scan base-package=\"com.glemontree.spring.generic.di\"&gt;&lt;/context:component-scan&gt;&lt;/beans&gt; 虽然UserService和UserRepository之间并没有建立直接的联系，但是两个泛型类BaseService&lt;T&gt;和BaseRepository&lt;T&gt;之间通过@Autowired建立了联系，因此它们的两个子类UserService和UserRepository也建立了联系。","tags":[{"name":"Spring, 注解, Bean","slug":"Spring-注解-Bean","permalink":"https://glemontree.github.io/tags/Spring-注解-Bean/"}]},{"title":"[C++] 继承与同名成员变量","date":"2017-06-28T09:31:01.000Z","path":"2017/06/28/[C++] 继承与同名成员变量/","text":"C++继承中子类与父类有同名成员变量的情况话不多说，先看下面这个例子： 1234567891011121314151617181920212223242526272829303132333435#include &lt;iostream&gt;class Base &#123;public: int a; Base() &#123; a = 0; std::cout &lt;&lt; \"base constructor...\" &lt;&lt; std::endl; &#125; void print() &#123; std::cout &lt;&lt; a &lt;&lt; std::endl; &#125; ~Base() &#123; std::cout &lt;&lt; \"base destructor...\" &lt;&lt; std::endl; &#125;&#125;;class Derived : public Base &#123;public: int a; Derived() &#123; a = 1; std::cout &lt;&lt; \"derived constructor...\" &lt;&lt; std::endl; &#125; ~Derived() &#123; std::cout &lt;&lt; \"derived destructor...\" &lt;&lt; std::endl; &#125;&#125;;int main() &#123; Derived d; d.print(); std::cout &lt;&lt; d.a &lt;&lt; std::endl;&#125; 你们猜上面程序的输出结果是啥？反正我是猜错了[捂脸]。正确答案是0，1，而不是1，1。 下面解释下： 在继承的时候，允许子类存在和父类同名的成员变量，但是子类中和父类同名的成员变量并不会覆盖父类中的成员变量，它们是同时存在的。 在子类创建对象时，会先调用父类的构造函数，先为父类的a变量进行初始化，然后调用父类的构造函数为自己的a进行初始化，因为子类中没有定义print函数，所以按照就近原则去父类中查找print函数，于是调用父类中的print函数，而这个函数会调用父类的a变量。","tags":[{"name":"C++, 继承, 同名成员变量","slug":"C-继承-同名成员变量","permalink":"https://glemontree.github.io/tags/C-继承-同名成员变量/"}]},{"title":"[C++] 零散知识点","date":"2017-06-28T09:29:08.000Z","path":"2017/06/28/[C++] 零散知识点/","text":"time_t实际上是长整型long int，它用来 保存从1970年1月1日0时0分0秒到现在时刻的秒数，用time()这个函数获取 gmtime 函数原型：struct tm gmtime(time_t time) 函数功能：得到以结构tm表示的时间信息 函数返回：以结构tm表示的时间信息指针 所述文件：123456789101112```cpp#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;time.h&gt;int main() &#123; time_t t; struct tm* gmt; t = time(NULL); gmt = gmtime(&amp;t); return 0;&#125; tm结构体 123456789101112131415161718struct tm &#123; int tm_sec; // seconds int tm_min; // minutes int tm_hour; // hours int tm_mday; // day int tm_mon; // month int tm_year; // year-1900 int tm_wday; // day of week[0-6] int tm_yday; // days in year[0-365] int tm_isdst; // DST [-1/0/1]#ifdef __USE_BSD long int tm_gmtoff; // seconds east of UTC __const char* tm_zone; // Timezone abbreviation#else long int __tm_gmtoff; // seconds east of UTC __const char* __tm_zone; // Timezone abbreviation#endif&#125;; timeval结构体 struct timeval结构体在time.h中定义： 1234struct timeval &#123; time_t tv_sec; // seconds suseconds_t tv_usec; // Microseconds&#125;; 其中，tv_sec为EPoch到创建struct timeval时的秒数，tv_usec为微秒数，即秒后面的零头，假如tv_sec为1244770435，tv_usec为442388，即当前时间距Epoch时间1244770435秒，442388微秒。 gettimeofday() 获取当前时间（保存在结构体timeval中） share_from_this 当类对象被shared_ptr管理时，需要在类自己定义的函数里把当前对象作为参数传给其他函数时，这时需要传递一个shared_ptr，否则就不能保持shared_ptr管理这个类对象的语义（因为一个raw poiter指向这个类对象，而shared_ptr对类对象的这个引用没有计数，很可能shared_ptr已经把类对象资源释放了，而那个调用函数还在使用类对象）。 对一个类 A ，当我们希望使用 shared_ptr 来管理其类对象时，而且需要在自己定义的函数里把类对象 shared_ptr （为什么不用普通指针，当我们使用智能指针管理资源时，必须统一使用智能指针，而不能在某些地方使用智能指针某些地方使用 raw pointer ，否则不能保持智能指针的语义，从而产生各种错误）传给其他函数时，可以让类 A 从 enable_shared_from_this 继承： 1class A : public boost::enable_shared_from_this&lt;A&gt; &#123;&#125;; 然后在类A中需要传递类对象本身shared_ptr的地方使用shared_from_this函数获得指向自身的shared_ptr。 boost::shared_from_this值得注意的地方 这个 函数仅在12345678910- 如下代码是错误的 ```cpp class D : public boost::enable_shared_from_this&lt;D&gt; &#123; public: D() &#123; boost::shared_ptr&lt;D&gt; p = shared_from_this(); &#125; &#125;; 在D的构造函数中虽然可以保证123456789101112131415- 如下代码是错误的 ```cpp class D : public boost::enable_shared_from_this&lt;D&gt; &#123; public: void func() &#123; boost::shared_ptr&lt;D&gt; = shared_from_this(); &#125; &#125;; void main() &#123; D d; d.func(); &#125; 错误原因同上。 如下代码是正确的 1234void main() &#123; boost::shared_ptr&lt;D&gt; d(new D); d-&gt;func();&#125; 这里boost::shared_ptr&lt;D&gt; d(new D)实际上执行了3个动作： 首先调用enable_shared_from_this&lt;D&gt;的构造函数； 其次调用D的构造函数； 最后调用shared_ptr&lt;D&gt;的构造函数。 是第3个动作设置了enable_shared_from_this&lt;D&gt;的weak_ptr，而不是第1个动作。 shared_from_this使用场景 需求：在类的内部需要自身的shared_ptr而不是this裸指针 场景：在类中发起一个异步操作，callback回来要保证发起操作的对象仍然有效 异步回调的时候对象可能已经销毁了，所以使用shared_ptr传出去就是保证最少还有一个引用计数维持对象的生命周期直至回调结束。 __thread __thread是GCC内置的线程局部存储设施，存储效率可以和全局变量相比，__thread变量每一个线程有一份独立实体，各个线程的值互不干扰 getpid、SYS_gettid以及pthread_self getpid()得到的是进程的pid，在进程中，每个线程都有自己的pid，要得到线程的pid，必须用syscall(SYS_gettid)，其在系统内是唯一的，pthread_self函数获取的是线程ID，线程ID在某进程中是唯一的，在不同的进程中创建的线程可能会出现ID值相同的情况。","tags":[{"name":"C++","slug":"C","permalink":"https://glemontree.github.io/tags/C/"}]},{"title":"[C++] 前置++和后置++的区别","date":"2017-06-28T09:27:34.000Z","path":"2017/06/28/[C++] 前置++和后置++的区别/","text":"前置++和后置++的区别前置++和后置++在程序开发中使用十分频繁，那么你是否真正了解它们的区别呢？ 其实++i相当于下面的代码： 12i += 1;return i; 而i++则相当于下面的代码： 123j = i;i += 1;return j; 对于内建数据类型，其实前置++和后置++的效率相差不大，而对于自定义的数据类型，前置++返回对象的引用，而后置++则返回对象的值，所以导致在大对象的时候产生了较大的复制开销，引起效率降低。","tags":[{"name":"C++","slug":"C","permalink":"https://glemontree.github.io/tags/C/"},{"name":"前置++","slug":"前置","permalink":"https://glemontree.github.io/tags/前置/"},{"name":"后置++","slug":"后置","permalink":"https://glemontree.github.io/tags/后置/"}]},{"title":"[设计模式] 适配器模式","date":"2017-06-28T09:26:13.000Z","path":"2017/06/28/[设计模式] 适配器模式/","text":"C++中的适配器模式一、为什么需要适配器模式当你想使用一格现存的类，但是它的方法和你的要求不相同时，此时就需要使用适配器模式。 二、适配器的作用是什么适配器就是将一个类的接口转换成客户希望的另外一个接口，适配器模式使得原本由于接口不兼容而不能一起工作的类可以一起工作。 三、适配器模式的分类适配器模式可以分为两类，一种是类模式适配器，另一种是对象模式适配器。 类模式适配器 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960// 目标接口类，客户需要的接口class Target &#123;public: Target(); virtual ~Target(); virtual void Request();&#125;;// 需要适配的类class Adaptee &#123;public: Adaptee(); ~Adaptee(); void SpecificRequest();&#125;;// 适配器类，通过public继承获得接口继承的效果，通过private继承获得实现继承的效果class Adapter : public Target, private Adaptee &#123;public: Adapter(); ~Adapter(); virtual void Request(); &#125;;Target::Target() &#123; &#125;Target::~Target() &#123; &#125;void Target::Request() &#123; std::cout &lt;&lt; \"Target::Request()\" &lt;&lt; std::endl;&#125;Adaptee::Adaptee() &#123; &#125;Adaptee::~Adaptee() &#123; &#125;void Adaptee::SpecificRequest() &#123; std::cout &lt;&lt; \"Adaptee::SpecificRequest()\" &lt;&lt; std::endl;&#125;Adapter::Adapter() &#123; &#125;Adapter::~Adapter() &#123; &#125;void Adapter::Request() &#123; std::cout &lt;&lt; \"Adapetr::Request()\" &lt;&lt; std::endl; this-&gt;SpecificRequest(); std::cout &lt;&lt; \"------------------\" &lt;&lt; std::endl;&#125;int main() &#123; Target* pTarget = new Adapter(); pTarget-&gt;Request();&#125; 类模式Adapter的关键在于适配器类需要public继承目标接口类（客户需要的接口），并且private继承需要适配的类。 对象模式适配器 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667// 目标接口类，客户需要的接口class Target &#123;public: Target(); virtual ~Target(); virtual void Request();&#125;;// 需要适配的类class Adaptee &#123;public: Adaptee(); ~Adaptee(); void SpecificRequest();&#125;;// 适配器类，通过public继承获得接口继承的效果，通过private继承获得实现继承的效果class Adapter : public Target &#123;public: Adapter(Adaptee* adaptee); Adapter(); ~Adapter(); virtual void Request(); private: Adaptee* mAdaptee;&#125;;Target::Target() &#123; &#125;Target::~Target() &#123; &#125;void Target::Request() &#123; std::cout &lt;&lt; \"Target::Request()\" &lt;&lt; std::endl;&#125;Adaptee::Adaptee() &#123; &#125;Adaptee::~Adaptee() &#123; &#125;void Adaptee::SpecificRequest() &#123; std::cout &lt;&lt; \"Adaptee::SpecificRequest()\" &lt;&lt; std::endl;&#125;Adapter::Adapter(): mAdaptee(new Adaptee) &#123; &#125;Adapter::Adapter(Adaptee* adapteee) &#123; mAdaptee = adaptee;&#125;Adapter::~Adapter() &#123; &#125;void Adapter::Request() &#123; std::cout &lt;&lt; \"Adapetr::Request()\" &lt;&lt; std::endl; this-&gt;mAdaptee-&gt;SpecificRequest(); std::cout &lt;&lt; \"------------------\" &lt;&lt; std::endl;&#125;int main() &#123; Adaptee* ade = new Adaptee(); Target* pTarget = new Adapter(ade); pTarget-&gt;Request();&#125; 对象模式适配器和类模式适配器的关键区别在于适配器类只public继承了目标接口类（客户需要的接口），而在类中维护了一个需要适配的类的实例。 四、参考资料本文参考自文章C++设计模式-Adapter适配器模式","tags":[{"name":"C++, 设计模式, 适配器模式","slug":"C-设计模式-适配器模式","permalink":"https://glemontree.github.io/tags/C-设计模式-适配器模式/"}]},{"title":"[DB] 数据库将一个表中数据插入到另外一张表中","date":"2017-06-28T09:24:49.000Z","path":"2017/06/28/[DB] 数据库将一个表中数据插入到另外一张表中/","text":"两张表中的字段一致，并且希望插入全部数据： 1INSERT INTO 目标表 SELECT * FROM 来源表; 只导入指定字段： 1INSERT INTO 目标表(字段1,字段2,...) SELECT 字段1,字段2,... FROM 来源表; 只导入目标表中不存在的记录： 1INSERT INTO 目标表(字段1,字段2,...) SELECT 字段1,字段2,... FROM 来源表 WHERE not exists (SELECT * from 目标表 where 目标表.比较字段=来源表.比较字段) ​","tags":[{"name":"DB","slug":"DB","permalink":"https://glemontree.github.io/tags/DB/"},{"name":"INSERT","slug":"INSERT","permalink":"https://glemontree.github.io/tags/INSERT/"}]},{"title":"[DB] 数据库中%和_的用法","date":"2017-06-28T09:23:09.000Z","path":"2017/06/28/[DB] 数据库中%和_的用法/","text":"数据库中模糊查询命令like有两个通配符”%”和”_”，其中： %匹配0或多个字符 _匹配任意1个字符（必须有一个） 举例如下： 12345678SQL&gt; create table tt ( name char(10) );SQL&gt; insert into tt values ( '1234' );SQL&gt; select * from tt where name like '_23%'; NAME----------1234SQL&gt; select * from tt where name like '_1234%' ;no rows selected 以上两句表明，_不能匹配0个字符，必须要匹配一个。而%可以匹配0个字符。","tags":[{"name":"DB","slug":"DB","permalink":"https://glemontree.github.io/tags/DB/"},{"name":"通配符","slug":"通配符","permalink":"https://glemontree.github.io/tags/通配符/"}]},{"title":"[C++] 推荐一个在线编辑、编译、运行程序的网页","date":"2017-06-28T09:21:53.000Z","path":"2017/06/28/[C++] 推荐一个在线编辑、编译、运行程序的网页/","text":"","tags":[]},{"title":"[CMake] 推荐一个关于CMake的一个很详细的教程","date":"2017-06-28T09:18:46.000Z","path":"2017/06/28/[CMake] 推荐一个关于CMake的一个很详细的教程/","text":"如果你对CMake也很感兴趣这篇文章你值得拥有： CMake。","tags":[{"name":"CMake","slug":"CMake","permalink":"https://glemontree.github.io/tags/CMake/"}]}]