<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Glemontree&#39;s blog</title>
  
  <subtitle>day day up!</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-04-05T12:34:53.429Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Glemontree</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>[Java] 静态代理、JDK动态代理与CGLIB动态代理</title>
    <link href="http://yoursite.com/2018/04/05/%5BJava%5D%20%E9%9D%99%E6%80%81%E4%BB%A3%E7%90%86%E3%80%81JDK%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E4%B8%8ECGLIB%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/"/>
    <id>http://yoursite.com/2018/04/05/[Java] 静态代理、JDK动态代理与CGLIB动态代理/</id>
    <published>2018-04-05T12:01:20.000Z</published>
    <updated>2018-04-05T12:34:53.429Z</updated>
    
    <content type="html"><![CDATA[<h2 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h2><p>代理模式是常用设计模式的一种，常见的代理模式有静态代理和动态代理两大类，在Java中动态代理又可分为JDK动态代理和CGLIB动态代理，下面我们分别进行讲述！</p><h2 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h2><p>静态代理由业务实现类、业务代理类两部分组成，业务实现类负责实现主要的业务方法，业务代理类负责对调用的业务方法进行拦截、过滤、预处理，我们在需要调用业务时不是直接通过业务实现类来调用的，而是通过业务代理类的同名方法来调用被代理类处理过的业务方法。</p><h2 id="静态代理的实现过程"><a href="#静态代理的实现过程" class="headerlink" title="静态代理的实现过程"></a>静态代理的实现过程</h2><ul><li><p>接口，声明业务逻辑</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">  <span class="comment">/** </span></div><div class="line">   * 定义一个账户接口 </div><div class="line">   */  </div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Count</span> </span>&#123;  </div><div class="line">  <span class="comment">// 查询账户</span></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">queryCount</span><span class="params">()</span></span>;  </div><div class="line"></div><div class="line">  <span class="comment">// 修改账户  </span></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateCount</span><span class="params">()</span></span>;  </div><div class="line">&#125;</div></pre></td></tr></table></figure></li><li><p>业务实现类，实现业务逻辑接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/** </span></div><div class="line"> * 委托类(包含业务逻辑) </div><div class="line"> */  </div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CountImpl</span> <span class="keyword">implements</span> <span class="title">Count</span> </span>&#123;  </div><div class="line">  </div><div class="line">    <span class="meta">@Override</span>  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">queryCount</span><span class="params">()</span> </span>&#123;  </div><div class="line">        System.out.println(<span class="string">"查看账户..."</span>);  </div><div class="line">    &#125;  </div><div class="line">  </div><div class="line">    <span class="meta">@Override</span>  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateCount</span><span class="params">()</span> </span>&#123;  </div><div class="line">        System.out.println(<span class="string">"修改账户..."</span>);  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure></li><li><p>业务代理类，通过组合，在代理类中创建一个业务实现类对象来调用具体的业务方法；通过实现业务逻辑接口，来统一业务方法；在代理类中实现业务逻辑接口中的方法时，进行预处理操作、通过业务实现类对象调用真正的业务方法、进行调用后操作的定义。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CountProxy</span> <span class="keyword">implements</span> <span class="title">Count</span> </span>&#123;  </div><div class="line">    <span class="keyword">private</span> CountImpl countImpl;  <span class="comment">//组合一个业务实现类对象来进行真正的业务方法的调用</span></div><div class="line">  </div><div class="line">    <span class="comment">/** </span></div><div class="line">     * 覆盖默认构造器 </div><div class="line">     * <span class="doctag">@param</span> countImpl </div><div class="line">     */  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CountProxy</span><span class="params">(CountImpl countImpl)</span> </span>&#123;  </div><div class="line">        <span class="keyword">this</span>.countImpl = countImpl;  </div><div class="line">    &#125;  </div><div class="line">  </div><div class="line">    <span class="meta">@Override</span>  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">queryCount</span><span class="params">()</span> </span>&#123;  </div><div class="line">        System.out.println(<span class="string">"查询账户的预处理——————"</span>);  </div><div class="line">        <span class="comment">// 调用真正的查询账户方法</span></div><div class="line">        countImpl.queryCount();  </div><div class="line">        System.out.println(<span class="string">"查询账户之后————————"</span>);  </div><div class="line">    &#125;  </div><div class="line">  </div><div class="line">    <span class="meta">@Override</span>  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateCount</span><span class="params">()</span> </span>&#123;  </div><div class="line">        System.out.println(<span class="string">"修改账户之前的预处理——————"</span>);  </div><div class="line">        <span class="comment">// 调用真正的修改账户操作</span></div><div class="line">        countImpl.updateCount();  </div><div class="line">        System.out.println(<span class="string">"修改账户之后——————————"</span>);  </div><div class="line">    &#125; </div><div class="line">&#125;</div></pre></td></tr></table></figure></li><li><p>使用，首先创建业务实现类对象，然后把业务实现类对象作构造参数创建一个代理类对象，最后通过代理类对象进行业务方法的调用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;  </div><div class="line">  CountImpl countImpl = <span class="keyword">new</span> CountImpl();  </div><div class="line">  CountProxy countProxy = <span class="keyword">new</span> CountProxy(countImpl);  </div><div class="line">  countProxy.updateCount();  </div><div class="line">  countProxy.queryCount(); </div><div class="line">&#125;</div></pre></td></tr></table></figure></li></ul><h2 id="静态代理的缺点"><a href="#静态代理的缺点" class="headerlink" title="静态代理的缺点"></a>静态代理的缺点</h2><ul><li>一个代理类只能对一个业务接口的实现类进行包装，如果有多个业务接口的话就要定义很多实现类和代理类才行</li><li>如果代理类对业务方法的预处理、调用后操作都是一样的（比如：调用前输出提示、调用后自动关闭连接），则多个代理类就会有很多重复代码。</li></ul><h2 id="JDK动态代理"><a href="#JDK动态代理" class="headerlink" title="JDK动态代理"></a>JDK动态代理</h2><p>JDK动态代理所用到的代理类在程序调用到代理类对象时才由JVM真正创建，JVM根据传进来的业务实现类对象以及方法名，动态的创建了一个代理类的class文件并被字节码引擎执行，然后通过该代理类对象进行方法调用，我们需要做的，只需要指定代理类的预处理、调用后操作即可。</p><h3 id="JDK动态代理的实现过程"><a href="#JDK动态代理的实现过程" class="headerlink" title="JDK动态代理的实现过程"></a>JDK动态代理的实现过程</h3><ul><li><p>定义业务逻辑接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BookFacade</span> </span>&#123;  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addBook</span><span class="params">()</span></span>;  </div><div class="line">&#125;</div></pre></td></tr></table></figure></li><li><p>实现业务逻辑接口创建业务实现类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BookFacadeImpl</span> <span class="keyword">implements</span> <span class="title">BookFacade</span> </span>&#123;   </div><div class="line">    <span class="meta">@Override</span>  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addBook</span><span class="params">()</span> </span>&#123;  </div><div class="line">        System.out.println(<span class="string">"增加图书方法。。。"</span>);  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure></li><li><p>实现调用管理接口InvocationHandler，创建动态代理类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BookFacadeProxy</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;  </div><div class="line">    <span class="keyword">private</span> Object target;<span class="comment">//这是业务实现类对象，用来调用具体的业务方法 </span></div><div class="line">    <span class="comment">/** </span></div><div class="line">     * 绑定业务对象并返回一个代理类  </div><div class="line">     */  </div><div class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">bind</span><span class="params">(Object target)</span> </span>&#123;  </div><div class="line">        <span class="keyword">this</span>.target = target;  <span class="comment">//接收业务实现类对象参数</span></div><div class="line"></div><div class="line">       <span class="comment">//通过反射机制，创建一个代理类对象实例并返回。用户进行方法调用时使用</span></div><div class="line">       <span class="comment">//创建代理对象时，需要传递该业务类的类加载器（用来获取业务实现类的元数据，在包装方法是调用真正的业务方法）、接口、handler实现类</span></div><div class="line">        <span class="keyword">return</span> Proxy.newProxyInstance(target.getClass().getClassLoader(),  </div><div class="line">                target.getClass().getInterfaces(), <span class="keyword">this</span>); &#125;  </div><div class="line">    <span class="comment">/** </span></div><div class="line">     * 包装调用方法：进行预处理、调用后处理 </div><div class="line">     */  </div><div class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span>  </span></div><div class="line">            <span class="keyword">throws</span> Throwable &#123;  </div><div class="line">        Object result=<span class="keyword">null</span>;  </div><div class="line"></div><div class="line">        System.out.println(<span class="string">"预处理操作——————"</span>);  </div><div class="line">        <span class="comment">//调用真正的业务方法  </span></div><div class="line">        result=method.invoke(target, args);  </div><div class="line"></div><div class="line">        System.out.println(<span class="string">"调用后处理——————"</span>);  </div><div class="line">        <span class="keyword">return</span> result;  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure></li><li><p>在使用时，首先创建一个业务实现类对象和一个代理类对象，然后定义接口引用（这里使用向上转型）并用代理对象.bind(业务实现类对象)的返回值进行赋值。最后通过接口引用调用业务方法即可。（接口引用真正指向的是一个绑定了业务类的代理类对象，所以通过接口方法名调用的是被代理的方法们）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;  </div><div class="line">  BookFacadeImpl bookFacadeImpl=<span class="keyword">new</span> BookFacadeImpl();</div><div class="line">  BookFacadeProxy proxy = <span class="keyword">new</span> BookFacadeProxy();  </div><div class="line">  BookFacade bookfacade = (BookFacade) proxy.bind(bookFacadeImpl);  </div><div class="line">  bookfacade.addBook();  </div><div class="line">&#125;</div></pre></td></tr></table></figure></li></ul><h3 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h3><p>JDK动态代理的代理对象在创建时，需要使用业务实现类所实现的接口作为参数（因为后面代理方法时需要根据接口内的方法名进行调用），如果业务实现类是没有实现接口而是直接定义定义业务方法的话，就无法使用JDK动态代理了，并且，如果业务实现类中新增了接口中没有的方法，这些方法是无法被代理的（因为无法被调用）。</p><h2 id="CGLIB实现动态代理"><a href="#CGLIB实现动态代理" class="headerlink" title="CGLIB实现动态代理"></a>CGLIB实现动态代理</h2><p>CGLIB是针对类来实现代理的，原理是对指定的业务类生成一个子类，并覆盖其中业务方法实现代理，因为采用的是继承，所以不能对final修饰的类进行代理。</p><h3 id="CGLIB实现动态代理的过程"><a href="#CGLIB实现动态代理的过程" class="headerlink" title="CGLIB实现动态代理的过程"></a>CGLIB实现动态代理的过程</h3><ul><li><p>定义业务类，无需实现接口（当然，实现接口也可以）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BookFacadeImpl1</span> </span>&#123;  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addBook</span><span class="params">()</span> </span>&#123;  </div><div class="line">        System.out.println(<span class="string">"新增图书..."</span>);  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure></li><li><p>实现MethodInterceptor方法代理接口，创建代理类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BookFacadeCglib</span> <span class="keyword">implements</span> <span class="title">MethodInterceptor</span> </span>&#123;  </div><div class="line">    <span class="keyword">private</span> Object target;<span class="comment">//业务类对象，供代理方法中进行真正的业务方法调用</span></div><div class="line">  </div><div class="line">    <span class="comment">//相当于JDK动态代理中的绑定</span></div><div class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getInstance</span><span class="params">(Object target)</span> </span>&#123;  </div><div class="line">        <span class="keyword">this</span>.target = target;  <span class="comment">//给业务对象赋值</span></div><div class="line">        Enhancer enhancer = <span class="keyword">new</span> Enhancer(); <span class="comment">//创建加强器，用来创建动态代理类</span></div><div class="line">        enhancer.setSuperclass(<span class="keyword">this</span>.target.getClass());  <span class="comment">//为加强器指定要代理的业务类（即：为下面生成的代理类指定父类）</span></div><div class="line">        <span class="comment">//设置回调：对于代理类上所有方法的调用，都会调用CallBack，而Callback则需要实现intercept()方法进行拦</span></div><div class="line">        enhancer.setCallback(<span class="keyword">this</span>); </div><div class="line">       <span class="comment">// 创建动态代理类对象并返回  </span></div><div class="line">       <span class="keyword">return</span> enhancer.create(); </div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 实现回调方法 </span></div><div class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object obj, Method method, Object[] args, MethodProxy proxy)</span> <span class="keyword">throws</span> Throwable </span>&#123; </div><div class="line">        System.out.println(<span class="string">"预处理——————"</span>);</div><div class="line">        proxy.invokeSuper(obj, args); <span class="comment">//调用业务类（父类中）的方法</span></div><div class="line">        System.out.println(<span class="string">"调用后操作——————"</span>);</div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>; </div><div class="line">    &#125;</div></pre></td></tr></table></figure></li><li><p>创建业务类和代理类对象，然后通过代理类对象.getInstance(业务类对象)返回一个动态代理类对象（它是业务类的子类，可以用业务类引用指向它），最后通过动态代理类对象进行方法调用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;      </div><div class="line">  BookFacadeImpl1 bookFacade=<span class="keyword">new</span> BookFacadeImpl1()；</div><div class="line">  BookFacadeCglib  cglib=<span class="keyword">new</span> BookFacadeCglib();  </div><div class="line">  BookFacadeImpl1 bookCglib=(BookFacadeImpl1)cglib.getInstance(bookFacade);  </div><div class="line">  bookCglib.addBook();  </div><div class="line">&#125;</div></pre></td></tr></table></figure></li></ul><h2 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h2><p>本文转自<a href="http://www.cnblogs.com/ygj0930/p/6542259.html" target="_blank" rel="external">Java动态代理之JDK实现和CGlib实现（简单易懂）</a>。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;代理模式&quot;&gt;&lt;a href=&quot;#代理模式&quot; class=&quot;headerlink&quot; title=&quot;代理模式&quot;&gt;&lt;/a&gt;代理模式&lt;/h2&gt;&lt;p&gt;代理模式是常用设计模式的一种，常见的代理模式有静态代理和动态代理两大类，在Java中动态代理又可分为JDK动态代理和CGLI
      
    
    </summary>
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="代理模式" scheme="http://yoursite.com/tags/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>[C++] 动态链接库</title>
    <link href="http://yoursite.com/2018/03/30/%5BC++%5D%20%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5%E5%BA%93/"/>
    <id>http://yoursite.com/2018/03/30/[C++] 动态链接库/</id>
    <published>2018-03-30T05:06:09.000Z</published>
    <updated>2018-03-30T05:06:57.114Z</updated>
    
    <content type="html"><![CDATA[<h2 id="VS中使用动态链接库"><a href="#VS中使用动态链接库" class="headerlink" title="VS中使用动态链接库"></a>VS中使用动态链接库</h2><ul><li><p>添加头文件目录</p><p>配置属性 –&gt; C/C++ –&gt; 常规 –&gt; 附加包含目录，加入头文件存放的目录</p></li><li><p>添加lib文件</p><p>配置属性 –&gt; 链接器 –&gt; 输入 –&gt; 附加依赖项加入库名（xxx.lib），或者在cpp文件中用<code>#pragma comment(lib, &quot;xxx.lib&quot;)</code>来代替。</p><p>此时编译会提示：fatal error LNK1104：无法打开文件“xxx.lib”，原因是编译器找不到lib文件。</p></li><li><p>给项目添加库文件路径</p><p>在VS中右击项目选择属性，配置属性 –&gt; 链接器 –&gt; 常规 –&gt; 附加目录，在里面填上库文件所在的路径即可。</p></li><li><p>加载DLL</p><p>将dll文件拷贝到工程debug目录下（如果不拷贝，编译链接不报错，但是运行报错：无法找到<em>*</em>.dll），或者在系统环境变量中加入dll文件的路径。</p><p>另外一种方法就是右击项目选择属性，配置属性 –&gt;     调试 –&gt; 右侧环境，编辑 –&gt; 添加dll文件所在的路径，可以是绝对路径，也可以是相对路径，需要注意最后一定要以半角分号结束，例如<code>PATH=dll所在路径</code>。</p></li></ul><h2 id="DLL和LIB文件的区别"><a href="#DLL和LIB文件的区别" class="headerlink" title="DLL和LIB文件的区别"></a>DLL和LIB文件的区别</h2><p>lib是一个二进制文件，与dll类似，供其他程序调用，lib与dll的区别是：dll是运行时需要的，lib是编译时需要的。</p><p>共有两种库：</p><ul><li>lib文件包含了函数所在的dll文件和文件中函数位置的信息（入口），代码由运行时加载在进行空间中的DLL提供，称为动态链接库；</li><li>lib文件包含了函数代码本身，在编译时直接将代码加入程序当中，称为静态链接库。</li></ul><p>关于lib和dll的区别如下：</p><ul><li>lib是编译时用到的，dll是运行时用到的，如果要完成源代码的编译，只需要lib，如果要使动态链接的程序运行起来，只需要dll；</li><li>如果有dll文件，那么lib一般是一些索引信息，记录了dll中函数的入口和位置，dll中是函数的具体内容；如果只有lib文件，那么这个lib文件是静态编译出来的，索引和实现都在其中，使用静态编译的lib文件，在运行程序时不需要再挂动态库，缺点是导致应用程序比较大，而且失去了动态库的灵活性，发布新版本时要发布新的应用程序才行；</li><li>动态链接的情况下，有两个 文件：一个是LIB文件，一个是DLL文件。LIB包含被DLL导出的函数名称和位置，DLL包含实际的函数和数据，应用程序使用LIB文件链接到DLL 文件。在应用程序的可执行文件中，存放的不是被调用的函数代码，而是DLL中相应函数代码的地址，从而节省了内存资源。DLL和LIB文件必须随应用程序 一起发行，否则应用程序会产生错误。</li></ul><p>动态链接库和静态链接库分别需要的文件：</p><ul><li>使用静态链接库需要包含两个文件：<ul><li>.h头文件，包含lib中说明输出的类或符号原型或数据结构，应用程序调用lib时，需要将该文件包含入应用程序的源文件中；</li><li>.lib文件</li></ul></li><li>使用dll需要包含三个文件：<ul><li>.h头文件，包含dll中说明输出的类或符号原型或数据结构的.h文件，应用程序调用dll时，需要将该文件包含入应用程序的源文件中；</li><li>.lib文件，是dll在编译、链接成功之后生成的文件，作用是当其他程序调用dll时，需要将该文件引入应用程序，否则产生错误；</li><li>.dll文件，真正的可执行文件，开发成功的应用程序在发布时，只需要.exe文件和.dll文件，并不需要.lib文件和.h文件。</li></ul></li></ul><p>本小节转自<a href="https://blog.csdn.net/gshgsh1228/article/details/52141312" target="_blank" rel="external">LIB,DLL区别 及 VS中如何添加LIB,DLL</a>。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;VS中使用动态链接库&quot;&gt;&lt;a href=&quot;#VS中使用动态链接库&quot; class=&quot;headerlink&quot; title=&quot;VS中使用动态链接库&quot;&gt;&lt;/a&gt;VS中使用动态链接库&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;添加头文件目录&lt;/p&gt;
&lt;p&gt;配置属性 –&amp;gt; C/C
      
    
    </summary>
    
      <category term="C++" scheme="http://yoursite.com/categories/C/"/>
    
    
      <category term="动态链接库" scheme="http://yoursite.com/tags/%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>[网络编程] Linux网络编程常用函数</title>
    <link href="http://yoursite.com/2018/03/28/%5B%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%5D%20Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/"/>
    <id>http://yoursite.com/2018/03/28/[网络编程] Linux网络编程常用函数/</id>
    <published>2018-03-28T01:59:01.000Z</published>
    <updated>2018-03-28T03:45:23.712Z</updated>
    
    <content type="html"><![CDATA[<ul><li><p>socket函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">socket</span><span class="params">(<span class="keyword">int</span> domain, <span class="keyword">int</span> type, <span class="keyword">int</span> protocol)</span></span></div></pre></td></tr></table></figure><ul><li>domain：主机采用的通讯协议族（AF_UNIX和AF_INET），AF_UNIX只能够用于单一的Unix系统进程间进行通信，而AF_INET是针对Internet的。因而允许在远程主机之间进行通信。</li><li>type：采用的通信协议（SOCK_STREAM、SOCK_DGRAM等），SOCK_STREAM表明我们用的是TCP协议，而SOCK_DGRAM表示使用的是UDP协议。</li><li>protocol：由于指定了type，所以protocol的值一般为0</li></ul><p>socket()函数成功时返回文件描述符，失败时返回-1，看errno可知道出错的详细情况。</p></li><li><p>bind函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">bind</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">struct</span> sockaddr* my_addr, <span class="keyword">int</span> addrlen)</span></span>;</div></pre></td></tr></table></figure><ul><li><p>sockfd：socket函数返回的文件描述符</p></li><li><p>addrlen：是sockaddr结构的长度</p></li><li><p>my_addr：一个指向sockaddr的指针，<code>struct sockaddr</code>的定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span>  sockaddr &#123;</div><div class="line">  <span class="keyword">unsigned</span> <span class="keyword">short</span> as_family;</div><div class="line">  <span class="keyword">char</span> sa_data[<span class="number">14</span>];</div><div class="line">&#125;;</div></pre></td></tr></table></figure><p>不过由于系统的兼容性，一般不用这个头文件，而使用另外一个结构（<code>struct sockaddr_in</code>）来代替，其定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> sockaddr_in &#123;</div><div class="line">  <span class="keyword">unsigned</span> <span class="keyword">short</span> sin_family;</div><div class="line">  <span class="keyword">unsigned</span> <span class="keyword">short</span> <span class="keyword">int</span> sin_port;</div><div class="line">  <span class="keyword">struct</span> in_addr sin_addr;</div><div class="line">  <span class="keyword">unsigned</span> <span class="keyword">char</span> sin_zero[<span class="number">8</span>];</div><div class="line">&#125;;</div></pre></td></tr></table></figure><p>我们主要使用Internet，所以sin_family一般为AF_INET，sin_addr设置为INADDR_ANY表示可以和任何的主机通信，sin_port是监听的端口号，sin_zero[8]是用来填充的。</p></li></ul><p>bind函数的作用就是将本地的端口和socket函数返回的文件描述符捆绑在一起，成功时返回0。</p></li><li><p>linten函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">linten</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">int</span> backlog)</span></span>;</div></pre></td></tr></table></figure><ul><li>sockfd：是bind后的文件描述符</li><li>backlog：设置请求队列的最大长度</li></ul><p>listen函数的作用就是bind的文件描述符转为监听套接字。</p></li><li><p>accept函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">accept</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">struct</span> sockaddr* addr, <span class="keyword">int</span>* addrlen)</span></span>;</div></pre></td></tr></table></figure><ul><li>sockfd：是listen后的文件描述符</li><li>addr、addrlen是用来给客户端的程序填写的，服务器端只要传递指针就可以了，bind、listen和accept是服务器端用的函数，accept调用时，服务器端的程序会一直阻塞到有一个客户程序发出了连接，accept成功时返回最后的服务器端的文件描述符，这个时候服务器端就可以向该描述符写信息了。</li></ul></li><li><p>connect函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">connect</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">struct</span> sockaddr* serv_addr, <span class="keyword">int</span> addrlen)</span></span>;</div></pre></td></tr></table></figure><ul><li>sockfd：socket返回的文件描述符</li><li>serv_addr：存储了服务器端的连接信息，其中sin_addr是服务端的地址</li><li>addr_len：serv_addr的长度</li></ul><p>connect函数是客户端用来同服务端连接的，成功时返回0。</p></li><li><p>setsockopt函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">setsockopt</span><span class="params">(socket s, <span class="keyword">int</span> level, <span class="keyword">int</span> optname, <span class="keyword">const</span> <span class="keyword">char</span>* optval, <span class="keyword">int</span> optlen)</span></span>;</div></pre></td></tr></table></figure><ul><li>s：指向一个打开的套接字描述符</li><li>level：<ul><li>SOL_SOCKET：基本套接口</li><li>IPPROTO_IP：IPV4套接口</li><li>IPPROTO_IPV6：IPV6套接口</li><li>IPPROTO_TCP：TCP套接口</li></ul></li><li>optname：选项名称</li><li>optval：指针，指向存放选项值的缓冲区</li><li>optlen：optval缓冲区长度</li></ul></li><li><p>inet_ntop函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">inet_ntop</span><span class="params">(<span class="keyword">int</span> af, <span class="keyword">const</span> <span class="keyword">void</span>* src, <span class="keyword">char</span>* dst, <span class="keyword">socklen_t</span> cnt)</span></span>;</div></pre></td></tr></table></figure><p>这个函数转换网络二进制结构到ASCII类型的地址。</p><ul><li>af：地址簇，其取值可以为AF_INET、AF_INET6</li><li>src：来源地址</li><li>dst：接收转换后的数据</li><li>cnt：缓冲区dst的大小</li></ul></li><li><p>ntohs函数</p><p>将一个16位数由网络字节序转换为主机字节顺序。</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;&lt;p&gt;socket函数&lt;/p&gt;
&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;
      
    
    </summary>
    
      <category term="网络编程" scheme="http://yoursite.com/categories/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="Linux, 网络编程" scheme="http://yoursite.com/tags/Linux-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>[设计模式] 抽象工厂模式</title>
    <link href="http://yoursite.com/2018/03/25/%5B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%5D%20%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"/>
    <id>http://yoursite.com/2018/03/25/[设计模式] 抽象工厂模式/</id>
    <published>2018-03-25T08:03:31.000Z</published>
    <updated>2018-03-25T08:49:16.855Z</updated>
    
    <content type="html"><![CDATA[<h2 id="模式定义"><a href="#模式定义" class="headerlink" title="模式定义"></a>模式定义</h2><p>抽象工厂模式提供一个创建一系列相关或相关依赖对象的接口。</p><h2 id="模式结构"><a href="#模式结构" class="headerlink" title="模式结构"></a>模式结构</h2><p>抽象工厂模式包含以下角色：</p><ul><li>AbstractFactory：抽象工厂</li><li>ConcreteFactory：具体工厂</li><li>AbstractProduct：抽象产品</li><li>Product：具体产品</li></ul><p><img src="http://design-patterns.readthedocs.io/zh_CN/latest/_images/AbatractFactory.jpg" alt=""></p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><ul><li><p>Engine接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Engine</span> </span>&#123;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">engine</span><span class="params">()</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></li><li><p>Light接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Light</span> </span>&#123;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">light</span><span class="params">()</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></li><li><p>BMWEngine</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BMWEngine</span> <span class="keyword">implements</span> <span class="title">Engine</span> </span>&#123;</div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">engine</span><span class="params">()</span> </span>&#123;</div><div class="line">System.out.println(<span class="string">"bmw engine"</span>);</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></li><li><p>BMWLight</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BMWLight</span> <span class="keyword">implements</span> <span class="title">Light</span> </span>&#123;</div><div class="line"></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">light</span><span class="params">()</span> </span>&#123;</div><div class="line">System.out.println(<span class="string">"bmw light"</span>);</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></li><li><p>AudiEngine</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AudiEngine</span> <span class="keyword">implements</span> <span class="title">Engine</span> </span>&#123;</div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">engine</span><span class="params">()</span> </span>&#123;</div><div class="line">System.out.println(<span class="string">"audi engine"</span>);</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></li><li><p>AudiLight</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AudiLight</span> <span class="keyword">implements</span> <span class="title">Light</span> </span>&#123;</div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">light</span><span class="params">()</span> </span>&#123;</div><div class="line">System.out.println(<span class="string">"audi light"</span>);</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></li><li><p>Factory接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Factory</span> </span>&#123;</div><div class="line"><span class="function">Engine <span class="title">createEngine</span><span class="params">()</span></span>;</div><div class="line"><span class="function">Light <span class="title">createLight</span><span class="params">()</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></li><li><p>BMWFactory</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BMWFactory</span> <span class="keyword">implements</span> <span class="title">Factory</span> </span>&#123;</div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> Engine <span class="title">createEngine</span><span class="params">()</span> </span>&#123;</div><div class="line"><span class="keyword">return</span> <span class="keyword">new</span> BMWEngine();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> Light <span class="title">createLight</span><span class="params">()</span> </span>&#123;</div><div class="line"><span class="keyword">return</span> <span class="keyword">new</span> BMWLight();</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></li><li><p>AudiFactory</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AudiFactory</span> <span class="keyword">implements</span> <span class="title">Factory</span> </span>&#123;</div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> Engine <span class="title">createEngine</span><span class="params">()</span> </span>&#123;</div><div class="line"><span class="keyword">return</span> <span class="keyword">new</span> AudiEngine();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> Light <span class="title">createLight</span><span class="params">()</span> </span>&#123;</div><div class="line"><span class="keyword">return</span> <span class="keyword">new</span> AudiLight();</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></li><li><p>Test</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">Factory factory = <span class="keyword">new</span> AudiFactory();</div><div class="line">Engine engine = factory.createEngine();</div><div class="line">Light light = factory.createLight();</div><div class="line">engine.engine();</div><div class="line">light.light();</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>抽象工厂模式包含四个角色：<ul><li>抽象工厂用于声明生成抽象产品的方法</li><li>具体工厂实现了抽象工厂声明的生成抽象产品的方法，生成一组具体产品，这些产品构成了一个产品族</li><li>抽象产品为某种产品声明接口，在抽象产品中定义了产品的抽象业务方法</li><li>具体产品定义具体工厂生成的具体产品对象，实现抽闲产品接口中定义的业务方法</li></ul></li><li>抽象工厂模式和工厂方法模式最大的区别在于，工厂方法模式针对的是一个产品等级结构，而抽象工厂模式则需要面对多个产品等级结构</li><li>本文转自<a href="http://design-patterns.readthedocs.io/zh_CN/latest/creational_patterns/abstract_factory.html" target="_blank" rel="external">3.抽象工厂模式</a>。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;模式定义&quot;&gt;&lt;a href=&quot;#模式定义&quot; class=&quot;headerlink&quot; title=&quot;模式定义&quot;&gt;&lt;/a&gt;模式定义&lt;/h2&gt;&lt;p&gt;抽象工厂模式提供一个创建一系列相关或相关依赖对象的接口。&lt;/p&gt;
&lt;h2 id=&quot;模式结构&quot;&gt;&lt;a href=&quot;#模式结构&quot;
      
    
    </summary>
    
      <category term="设计模式" scheme="http://yoursite.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="抽象工厂模式" scheme="http://yoursite.com/tags/%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>[设计模式] 工厂方法模式</title>
    <link href="http://yoursite.com/2018/03/25/%5B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%5D%20%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/"/>
    <id>http://yoursite.com/2018/03/25/[设计模式] 工厂方法模式/</id>
    <published>2018-03-25T06:13:24.000Z</published>
    <updated>2018-03-25T06:58:27.611Z</updated>
    
    <content type="html"><![CDATA[<h2 id="模式定义"><a href="#模式定义" class="headerlink" title="模式定义"></a>模式定义</h2><p>在工厂方法模式中，工厂父类负责定义创建产品对象的公共接口，而工厂子类则负责生成具体的产品对象。</p><h2 id="模式结构"><a href="#模式结构" class="headerlink" title="模式结构"></a>模式结构</h2><p>工厂方法模式包含以下角色：</p><ul><li>Product：抽象产品</li><li>ConcreteProduct：具体产品</li><li>Factory：抽象工厂</li><li>ConcreteFactory：具体工厂</li></ul><p><img src="http://design-patterns.readthedocs.io/zh_CN/latest/_images/FactoryMethod.jpg" alt=""></p><h2 id="相对于简单工厂模式的优点"><a href="#相对于简单工厂模式的优点" class="headerlink" title="相对于简单工厂模式的优点"></a>相对于简单工厂模式的优点</h2><p>在工厂方法模式中，核心的工厂类不再负责所有产品的创建，而是将具体创建工作交给子类去做，这个核心类仅仅负责给出具体工厂必须实现的接口，而不负责哪一个产品类被实例化这种细节，这使得工厂方法模式可以允许系统在不修改工厂角色的情况下引入新产品。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><ul><li><p>Product接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Product</span> </span>&#123;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">name</span><span class="params">()</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></li><li><p>BMW</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BMW</span> <span class="keyword">implements</span> <span class="title">Product</span> </span>&#123;</div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">name</span><span class="params">()</span> </span>&#123;</div><div class="line">System.out.println(<span class="string">"bmw..."</span>);</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></li><li><p>Audi</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Audi</span> <span class="keyword">implements</span> <span class="title">Product</span> </span>&#123;</div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">name</span><span class="params">()</span> </span>&#123;</div><div class="line">System.out.println(<span class="string">"audi..."</span>);</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></li><li><p>Factory接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Factory</span> </span>&#123;</div><div class="line"><span class="function">Product <span class="title">create</span><span class="params">()</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></li><li><p>BMWFactory</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BMWFactory</span> <span class="keyword">implements</span> <span class="title">Factory</span> </span>&#123;</div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> Product <span class="title">create</span><span class="params">()</span> </span>&#123;</div><div class="line"><span class="keyword">return</span> <span class="keyword">new</span> BMW();</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></li><li><p>AudiFactory</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AudiFactory</span> <span class="keyword">implements</span> <span class="title">Factory</span> </span>&#123;</div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> Product <span class="title">create</span><span class="params">()</span> </span>&#123;</div><div class="line"><span class="keyword">return</span> <span class="keyword">new</span> Audi();</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></li><li><p>Test</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">Factory factory = <span class="keyword">new</span> AudiFactory();</div><div class="line">Product product = factory.create();</div><div class="line">product.name();</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>工厂方法模式包含四个角色：<ul><li>抽象产品是定义产品的接口，是工厂方法模式所创建对象的超类，即产品对象的共同父类或接口</li><li>具体产品实现了抽象产品接口，某种类型的具体产品由专门的具体工厂创建，它们之间往往是一一对应</li><li>抽象工厂中声明了工厂方法，用于返回一个产品，它是工厂方法模式的核心，任何在模式中创建对象的工厂类必须实现该接口</li><li>具体工厂是抽象工厂类的子类，实现了抽象工厂中定义的工厂方法，并可由客户调用，返回一个具体产品类的实例</li></ul></li><li>工厂方法模式允许系统在不修改工厂角色的情况下引进新产品</li><li>工厂方法模式的缺点在于增加新产品的同时需要增加新的工厂，导致系统类的个数成对增加</li><li>本文转自<a href="http://design-patterns.readthedocs.io/zh_CN/latest/creational_patterns/factory_method.html" target="_blank" rel="external">2.工厂方法模式</a>。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;模式定义&quot;&gt;&lt;a href=&quot;#模式定义&quot; class=&quot;headerlink&quot; title=&quot;模式定义&quot;&gt;&lt;/a&gt;模式定义&lt;/h2&gt;&lt;p&gt;在工厂方法模式中，工厂父类负责定义创建产品对象的公共接口，而工厂子类则负责生成具体的产品对象。&lt;/p&gt;
&lt;h2 id=&quot;模式
      
    
    </summary>
    
      <category term="设计模式" scheme="http://yoursite.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="工厂方法模式" scheme="http://yoursite.com/tags/%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>[设计模式] 简单工厂模式</title>
    <link href="http://yoursite.com/2018/03/23/%5B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%5D%20%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"/>
    <id>http://yoursite.com/2018/03/23/[设计模式] 简单工厂模式/</id>
    <published>2018-03-23T15:09:50.000Z</published>
    <updated>2018-03-23T15:53:41.703Z</updated>
    
    <content type="html"><![CDATA[<h2 id="模式定义"><a href="#模式定义" class="headerlink" title="模式定义"></a>模式定义</h2><p>简单工厂模式又称为静态工厂方法，在简单工厂模式中可以根据参数的不同返回不同类的实例，简单工厂模式专门定义一个类来负责创建其他类的实例，被创建的实例通常具有共同的父类。</p><h2 id="模式结构"><a href="#模式结构" class="headerlink" title="模式结构"></a>模式结构</h2><ul><li>Factory：工厂角色，负责实现创建所有实例的内部逻辑</li><li>Product：抽象产品角色，是所创建的所有对象的父类，负责描述所有实例共有的公共接口</li><li>ConcreteProduct：具体产品角色。</li></ul><p><img src="http://design-patterns.readthedocs.io/zh_CN/latest/_images/SimpleFactory.jpg" alt=""></p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><ul><li><p>Product抽象类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Product</span> </span>&#123;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">use</span><span class="params">()</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>Product类仅仅提供一个接口，具体不同的商品实现不同的use()方法。</p></li><li><p>ConcreteProductA</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteProductA</span> <span class="keyword">implements</span> <span class="title">Product</span> </span>&#123;</div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">use</span><span class="params">()</span> </span>&#123;</div><div class="line">System.out.println(<span class="string">"ConcreteProductA..."</span>);</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></li><li><p>ConcreteProductB</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteProductB</span> <span class="keyword">implements</span> <span class="title">Product</span> </span>&#123;</div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">use</span><span class="params">()</span> </span>&#123;</div><div class="line">System.out.println(<span class="string">"ConcreteProductB..."</span>);</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></li><li><p>SimpleFactory</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleFactory</span> </span>&#123;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Product <span class="title">createProduct</span><span class="params">(String name)</span> </span>&#123;</div><div class="line"><span class="keyword">if</span> (name.equals(<span class="string">"A"</span>)) &#123;</div><div class="line"><span class="keyword">return</span> <span class="keyword">new</span> ConcreteProductA();</div><div class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (name.equals(<span class="string">"B"</span>)) &#123;</div><div class="line"><span class="keyword">return</span> <span class="keyword">new</span> ConcreteProductB();</div><div class="line">&#125;</div><div class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></li><li><p>Test</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">Product product = SimpleFactory.createProduct(<span class="string">"A"</span>);</div><div class="line">product.use();</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>​</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;模式定义&quot;&gt;&lt;a href=&quot;#模式定义&quot; class=&quot;headerlink&quot; title=&quot;模式定义&quot;&gt;&lt;/a&gt;模式定义&lt;/h2&gt;&lt;p&gt;简单工厂模式又称为静态工厂方法，在简单工厂模式中可以根据参数的不同返回不同类的实例，简单工厂模式专门定义一个类来负责创建其他
      
    
    </summary>
    
      <category term="设计模式" scheme="http://yoursite.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="简单工厂模式" scheme="http://yoursite.com/tags/%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>[Redis] Redis数据类型</title>
    <link href="http://yoursite.com/2018/03/23/%5BRedis%5D%20Redis%E5%8E%9F%E7%90%86/"/>
    <id>http://yoursite.com/2018/03/23/[Redis] Redis原理/</id>
    <published>2018-03-23T13:16:39.000Z</published>
    <updated>2018-03-23T13:40:30.922Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Redis数据类型"><a href="#Redis数据类型" class="headerlink" title="Redis数据类型"></a>Redis数据类型</h2><p>与Memcached仅支持简单的key-value结构的数据记录不同，Redis支持的数据类型有String、List、Hash、Set和Sorted Set。</p><p><img src="http://s3.51cto.com/wyfs02/M01/58/5C/wKiom1SvUaiAGz1-AADTt6pnZyY572.jpg" alt=""></p><p>Redis内部使用一个redisObject对象来表示所有的key和value，在上图中，type代表一个value对象具体是何种数据类型，encoding是不同数据类型在redis内部的存储方式，比如：type=string代表value存储的是一个普通的字符串，那么对应的encoding可以是raw或者int，如果是int则代表实际redis内部是按数值类型存储和表示这个字符串的，当然前提是这个字符串本身可以用数值表示。</p><p>上图中vm字段只有打开了Redis的虚拟内存功能，此字段才会真正的分配内存，该功能默认是关闭状态的。</p><h3 id="String类型"><a href="#String类型" class="headerlink" title="String类型"></a>String类型</h3><p>字符串是Redis的最基础的类型，Redis中使用的字符串是通过包装的，基于C语言字符数组实现的简单动态字符串（Simple Dynamic String, sds）一个抽象数据结构。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> sdshdr &#123;</div><div class="line">  <span class="keyword">int</span> len; <span class="comment">// len表示buf中存储的字符串的长度</span></div><div class="line">  <span class="keyword">int</span> <span class="built_in">free</span>; <span class="comment">// free表示buf中空闲空间的长度</span></div><div class="line">  <span class="keyword">char</span> buf[]; <span class="comment">// buf用来存储字符串内容</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure><p>String是最常用的数据类型，普通的key-value都可以归为此类。</p><h3 id="Hash类型"><a href="#Hash类型" class="headerlink" title="Hash类型"></a>Hash类型</h3><p>Hash是一个String类型的field和value之间的映射表，即Redis的Hash数据类型的key对应的value实际的内部存储结构是一个HashMap，因此Hash特别适合存储对象。</p><p><img src="https://images2015.cnblogs.com/blog/811915/201701/811915-20170113135937838-1351764137.png" alt=""></p><p>Hash类型通常用一个对象存储用户信息、商品信息、订单信息等。</p><h3 id="List类型"><a href="#List类型" class="headerlink" title="List类型"></a>List类型</h3><p>Redis的List类型其实就是每一个元素都是String类型的双向链表，可以从链表的头部和尾部添加或者删除元素，因此，其既可以作为栈，也可以作为队列来使用。</p><p><img src="https://images2015.cnblogs.com/blog/811915/201701/811915-20170113140412463-693350201.png" alt=""></p><p>List类型通常用在好友列表、粉丝列表、消息队列、最新消息排行等场合。</p><h3 id="Set类型"><a href="#Set类型" class="headerlink" title="Set类型"></a>Set类型</h3><p>Redis的Set类型是一个无序的String类型数据的集合，与List不同的是Set不能有重复的数据。实际上，Set内部是用HashMap实现的，Set只用了HashMap的key列来存储对象。</p><p><img src="https://images2015.cnblogs.com/blog/811915/201701/811915-20170113141353041-1553936162.png" alt=""></p><p>Set类型有取交集、并集、差集等操作，通常用在求共同好友、共同兴趣、分类标签等。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Redis数据类型&quot;&gt;&lt;a href=&quot;#Redis数据类型&quot; class=&quot;headerlink&quot; title=&quot;Redis数据类型&quot;&gt;&lt;/a&gt;Redis数据类型&lt;/h2&gt;&lt;p&gt;与Memcached仅支持简单的key-value结构的数据记录不同，Redis支持
      
    
    </summary>
    
      <category term="Redis" scheme="http://yoursite.com/categories/Redis/"/>
    
    
      <category term="Redis" scheme="http://yoursite.com/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>[Java] Java虚拟机垃圾收集</title>
    <link href="http://yoursite.com/2018/03/23/%5BJava%5D%20Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86/"/>
    <id>http://yoursite.com/2018/03/23/[Java] Java虚拟机垃圾收集/</id>
    <published>2018-03-23T09:08:56.000Z</published>
    <updated>2018-03-23T13:10:17.699Z</updated>
    
    <content type="html"><![CDATA[<h2 id="垃圾收集算法"><a href="#垃圾收集算法" class="headerlink" title="垃圾收集算法"></a>垃圾收集算法</h2><blockquote><p>  可作为GC Roots的对象包括：</p><ul><li>虚拟机栈（栈帧中的本地变量表）中的引用对象</li><li>方法区中的类静态属性引用的对象</li><li>方法区中的常量引用的对象</li><li>本地方法栈中JNI的引用对象</li></ul></blockquote><h3 id="标记-清除算法"><a href="#标记-清除算法" class="headerlink" title="标记-清除算法"></a>标记-清除算法</h3><p>其缺点为：</p><ul><li>效率不高</li><li>标记清除之后会产生大量不连续的内存碎片</li></ul><p><img src="https://images2015.cnblogs.com/blog/811915/201702/811915-20170228163546813-591415562.png" alt=""></p><h3 id="复制算法"><a href="#复制算法" class="headerlink" title="复制算法"></a>复制算法</h3><p>它将可用内存容量划分为大小相等的两块，每次只使用其中的一块，当这一块用完之后，就将还存活的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉，这样使得每次都是对其中一块内存进行回收，不会产生碎片等情况。其缺点是内存缩小为原来的一半。</p><p><img src="https://images2015.cnblogs.com/blog/811915/201702/811915-20170228164403782-1128832964.png" alt=""></p><h3 id="标记-清理算法"><a href="#标记-清理算法" class="headerlink" title="标记-清理算法"></a>标记-清理算法</h3><p>其缺点为在标记-清除的基础上还需进行对象的移动，成本相对较高，好处就是不会产生内存碎片。</p><p><img src="https://images2015.cnblogs.com/blog/811915/201702/811915-20170228164444782-56804909.png" alt=""></p><h2 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h2><p><img src="http://img.my.csdn.net/uploads/201210/03/1349278110_8410.jpg" alt=""></p><p>如上图所示，有7种收集器，分为两块，上面为新生代收集器，下面为老年代收集器，如果两个收集器之间存在连线，就说明它们可以搭配使用。</p><h3 id="Serial-串行GC-收集器"><a href="#Serial-串行GC-收集器" class="headerlink" title="Serial(串行GC)收集器"></a>Serial(串行GC)收集器</h3><p>其为一个新生代的收集器，单线程执行，使用复制算法，它在进行垃圾回收的时候，必须暂停其他所有的工作线程（用户线程），对于限定单个CPU的环境来说，Serial收集器由于没有线程交互的开销，专心做垃圾收集自然可以获得最高的单线程手机效率。</p><h3 id="ParNew-并行-收集器"><a href="#ParNew-并行-收集器" class="headerlink" title="ParNew(并行)收集器"></a>ParNew(并行)收集器</h3><p>ParNew收集器就是Serial收集器的多线程版本。</p><h3 id="Parallel-Scavenge-并行回收GC-收集器"><a href="#Parallel-Scavenge-并行回收GC-收集器" class="headerlink" title="Parallel Scavenge(并行回收GC)收集器"></a>Parallel Scavenge(并行回收GC)收集器</h3><p>Parallel Scavenge收集器也是一个新生代收集器，它也是使用复制算法的收集器，又是并行多线程收集器， Parallel Scavenge收集器的特点是它的关注点与其他收集器不同，CMS等收集器的关注点是尽可能缩短垃圾收集时用户线程的停顿时间，而Parallel Scavenge收集器的目标则是达到一个可控制的吞吐量，吞吐量 = 程序运行时间 / （程序运行时间 + 垃圾收集时间）。</p><h3 id="Serial-Old-串行GC-收集器"><a href="#Serial-Old-串行GC-收集器" class="headerlink" title="Serial Old(串行GC)收集器"></a>Serial Old(串行GC)收集器</h3><p>其为Serial收集器的老年代版本，它同样使用一个单线程执行收集，使用“标记-整理”算法。</p><h3 id="Parallel-Old-并行GC-收集器"><a href="#Parallel-Old-并行GC-收集器" class="headerlink" title="Parallel Old(并行GC)收集器"></a>Parallel Old(并行GC)收集器</h3><p>Parallel Old是Parallel Scavenge收集器的老年代版本，使用多线程和“标记-整理”算法。</p><h3 id="CMS-并发GC-收集器"><a href="#CMS-并发GC-收集器" class="headerlink" title="CMS(并发GC)收集器"></a>CMS(并发GC)收集器</h3><p>CMS（Concurrent Mark Sweep）收集器是一种以获取最短回收停顿时间为目标的收集器，CMS收集器是基于“标记-清除”算法实现的，整个收集过程分为4个步骤：</p><ul><li>初始标记</li><li>并发标记</li><li>重新标记</li><li>并发清除</li></ul><p>其中初始标记、重新标记这两个步骤任然需要停顿其他用户线程。初始标记仅仅只是标记出GC ROOTS能直接关联到的对象，速度很快，并发标记阶段是进行GC ROOTS 根搜索算法阶段，会判定对象是否存活。而重新标记阶段则是为了修正并发标记期间，因用户程序继续运行而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间会被初始标记阶段稍长，但比并发标记  阶段要短。</p><p>由于整个过程中耗时最长的并发标记和并发清除过程中，收集器线程都可以与用户线程一起工作，所以整体来说，CMS收集器的内存回收过程是与用户线程一起并发执行的。</p><p>CMS收集器的优点：并发收集、低停顿，但是CMS还远远达不到完美，器主要有三个显著缺点：</p><p>CMS收集器对CPU资源非常敏感。在并发阶段，虽然不会导致用户线程停顿，但是会占用CPU资源而导致引用程序变慢，总吞吐量下降。CMS默认启动的回收线程数是：(CPU数量+3) / 4。</p><h3 id="G1收集器"><a href="#G1收集器" class="headerlink" title="G1收集器"></a>G1收集器</h3><p>G1（Garbage First）收集器是JDK1.7提供的一个新收集器，G1收集器基于“标记-整理”算法实现，不会产生内存碎片，还有一个特点就是G1将整个Java堆（包括新生代和老年代）。</p><h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><p>本文转载自<a href="http://www.cnblogs.com/shanheyongmu/p/6484158.html" target="_blank" rel="external">Java虚拟机学习 - 垃圾收集器 （4）</a>。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;垃圾收集算法&quot;&gt;&lt;a href=&quot;#垃圾收集算法&quot; class=&quot;headerlink&quot; title=&quot;垃圾收集算法&quot;&gt;&lt;/a&gt;垃圾收集算法&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;  可作为GC Roots的对象包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;虚拟机栈（栈帧中
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>[SpringMVC] HTTP协议中GET、PUT、DELETE、POST与幂等性</title>
    <link href="http://yoursite.com/2018/03/20/%5BSpringMVC%5D%20HTTP%E5%8D%8F%E8%AE%AE%E4%B8%ADGET%E3%80%81PUT%E3%80%81DELETE%E3%80%81POST%E4%B8%8E%E5%B9%82%E7%AD%89%E6%80%A7/"/>
    <id>http://yoursite.com/2018/03/20/[SpringMVC] HTTP协议中GET、PUT、DELETE、POST与幂等性/</id>
    <published>2018-03-20T12:40:32.000Z</published>
    <updated>2018-03-23T09:10:59.752Z</updated>
    
    <content type="html"><![CDATA[<ul><li><p>幂等性</p><p>幂等性即为不管进行多少次重复操作，或者说一次和多次请求某一个资源应该具有相同的副作用。</p></li><li><p>REST请求中的幂等性操作</p><p>GET、PUT和DELETE都是幂等操作，而POST不是。</p><ul><li>GET方法用于获取资源，不应有副作用，所以是幂等的，需要注意的是，这里强调的是一次和多次具有相同的副作用，而不是多次GET请求的结果相同</li><li>DELETE方法用于删除资源，第一次将资源删除后，后面多次进行此删除操作，最终结果都是一样的</li><li>PUT请求的幂等性可以这样理解，将A改成B，第一次请求值变成了B，再进行多次此操作，最终的结果还是B，与一次执行的结果是一样的</li><li>POST方法会在服务器端创建资源，两次相同的POST请求会在服务器端产生两份资源，它们具有不同的URI，因此，POST请求不具有幂等性</li></ul></li><li><p>分布式事务与幂等性</p><p>看下面的例子，假设有一个从账户取钱的远程API，我们暂时用函数的方式记为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">bool withdraw(account_id, amount);</div></pre></td></tr></table></figure><p>withdraw的语义是从account_id对应的账户中扣除amount数额的钱；如果扣除成功则返回true，账户余额减少amount；如果扣除失败则返回false，账户余额不变。值得注意的是：和本地环境相比，我们不能轻易假设分布式环境的可靠性。一种典型的情况是withdraw请求已经被服务器端正确处理，但服务器端的返回结果由于网络等原因被掉丢了，导致客户端无法得知处理结果。如果是在网页上，一些不恰当的设计可能会使用户认为上一次操作失败了，然后刷新页面，这就导致了withdraw被调用两次，账户也被多扣了一次钱。</p><p>这个问题的解决方案一是采用分布式事务，通过引入支持分布式事务的中间件来保证withdraw功能的事务性。分布式事务的优点是对于调用者很简单，复杂性都交给了中间件来管理。缺点则是一方面架构太重量级，容易被绑在特定的中间件上，不利于异构系统的集成；另一方面分布式事务虽然能保证事务的ACID性质，而但却无法提供性能和可用性的保证。</p><p>另一种更轻量级的解决方案是幂等设计。我们可以通过一些技巧把withdraw变成幂等的，比如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">int create_ticket() </div><div class="line">bool idempotent_withdraw(ticket_id, account_id, amount)</div></pre></td></tr></table></figure><p>create_ticket的语义是获取一个服务器端生成的唯一的处理号ticket_id，它将用于标识后续的操作。idempotent_withdraw和withdraw的区别在于关联了一个ticket_id，一个ticket_id表示的操作至多只会被处理一次，每次调用都将返回第一次调用时的处理结果。这样，idempotent_withdraw就符合幂等性了，客户端就可以放心地多次调用。</p><p>基于幂等性的解决方案中一个完整的取钱流程被分解成了两个步骤：1.调用<code>create_ticket()</code>获取ticket_id；2.调用<code>idempotent_withdraw(ticket_id, account_id, amount)</code>。虽然create_ticket不是幂等的，但在这种设计下，它对系统状态的影响可以忽略，加上idempotent_withdraw是幂等的，所以任何一步由于网络等原因失败或超时，客户端都可以重试，直到获得结果。</p></li><li><p>根据幂等性区分POST和PUT的使用</p><p>举一个简单的例子，假如有一个博客系统提供一个Web API，模式是这样<code>http://superblogging/blogs/{blog-name}</code>，很简单，将<code>{blog-name}</code>替换为我们的blog名字，往这个URI发送一个HTTP PUT或者POST请求，HTTP的body部分就是博文，这是一个很简单的REST API例子。</p><p>我们应该用PUT方法还是POST方法？</p><p>取决于这个REST服务的行为是否是idempotent的，假如我们发送两个<code>http://superblogging/blogs/post/Sample</code>请求，服务器端是什么样的行为？如果产生了两个博客帖子，那就说明这个服务不是idempotent的，因为多次使用产生了副作用了嘛；如果后一个请求把第一个请求覆盖掉了，那这个服务就是idempotent的。前一种情况，应该使用POST方法，后一种情况，应该使用PUT方法。</p></li><li><p>本文转自<a href="http://blog.csdn.net/qq_33082731/article/details/74230813" target="_blank" rel="external">利用幂等性区分HTTP的POST与PUT请求</a>和<a href="http://blog.csdn.net/zjkC050818/article/details/78799386" target="_blank" rel="external">HTTP幂等性及GET、POST、PUT、DELETE的区别</a>。</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;&lt;p&gt;幂等性&lt;/p&gt;
&lt;p&gt;幂等性即为不管进行多少次重复操作，或者说一次和多次请求某一个资源应该具有相同的副作用。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;REST请求中的幂等性操作&lt;/p&gt;
&lt;p&gt;GET、PUT和DELETE都是幂等操作，而POST不是。&lt;/p&gt;
&lt;
      
    
    </summary>
    
      <category term="SpringMVC" scheme="http://yoursite.com/categories/SpringMVC/"/>
    
    
      <category term="幂等性" scheme="http://yoursite.com/tags/%E5%B9%82%E7%AD%89%E6%80%A7/"/>
    
  </entry>
  
  <entry>
    <title>[算法] 背包问题</title>
    <link href="http://yoursite.com/2018/01/30/%5B%E7%AE%97%E6%B3%95%5D%20%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/"/>
    <id>http://yoursite.com/2018/01/30/[算法] 背包问题/</id>
    <published>2018-01-30T05:32:21.000Z</published>
    <updated>2018-01-30T07:33:49.055Z</updated>
    
    <content type="html"><![CDATA[<p>题目：</p><p>​    在n个物品中挑选若干物品装入背包，最多能装多满？假设背包的大小为m，每个物品的大小为A[i]</p><p>样例：</p><p>​    如果有4个物品<strong>[2, 3, 5, 7]</strong></p><p>​    如果背包的大小为<strong>11</strong>，可以选择<strong>[2, 3, 5]</strong>装入背包，最多可以装满<strong>10</strong>的空间。</p><p>​    如果背包的大小为<strong>12</strong>，可以选择<strong>[2, 3, 7]</strong>装入背包，最多可以装满<strong>12</strong>的空间。</p><p>​    函数需要返回最多能装满的空间大小。</p><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">backPack</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span>[] A)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[A.length][m + <span class="number">1</span>]; <span class="comment">// 动态规划矩阵</span></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; A.length; i++) &#123;</div><div class="line">      dp[i][<span class="number">0</span>] = <span class="number">0</span>; <span class="comment">// 背包空间为0时，不管放多少个物品，可装满的背包空间都为0</span></div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; m + <span class="number">1</span>; j++) &#123;</div><div class="line">      <span class="keyword">if</span> (A[<span class="number">0</span>] &lt;= j) &#123; <span class="comment">// 当第0个物品的空间小于等于当前背包空间j时</span></div><div class="line">        dp[<span class="number">0</span>][j] = A[<span class="number">0</span>]; <span class="comment">// 背包可装满的最大空间是第0个物品的体积</span></div><div class="line">      &#125; <span class="keyword">else</span> &#123; <span class="comment">// 当第0个物品的空间大于当前背包空间j时</span></div><div class="line">        dp[<span class="number">0</span>][j] = <span class="number">0</span>; <span class="comment">// 背包可装满的空间是0</span></div><div class="line">      &#125;</div><div class="line">      </div><div class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; A.length; i++) &#123; <span class="comment">// 当放第1个到第A.length - 1个物品时</span></div><div class="line">        <span class="keyword">if</span> (A[i] &gt; j) &#123; <span class="comment">// 若该物品所占空间大于背包总空间，该物品无法放入背包</span></div><div class="line">          dp[i][j] = dp[i - <span class="number">1</span>][j]; <span class="comment">// 背包可装满的最大空间不变</span></div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">          <span class="comment">// 若该物品所占空间小于等于背包总空间，则需将背包腾出至少A[j]后，将该物品放入，放入新物品后背包最大可装满空间可能更大，也可能变小，取大值作为背包空间为j且放第i个物品时可以有的最大可装满空间</span></div><div class="line">          dp[i][j] = Math.max(dp[i - <span class="number">1</span>][j - A[i]] + A[i], dp[i - <span class="number">1</span>][j]);</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> dp[A.length - <span class="number">1</span>][m];</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>解析：</p><ul><li><code>dp[i][j]</code>表示当背包总重量为j且有前i个物品时，背包最多装满<code>dp[i][j]</code>的空间</li><li>状态转移方程为：<code>dp[i][j] = Math.max(dp[i - 1][j - A[i]] + A[i], dp[i - 1][j])</code></li><li>为了把第i个物品放进背包，背包当然要先腾出至少<code>A[i]</code>的空间，腾出后空间的最多装满空间为<code>dp[ i - 1][j - A[i]]</code>，再加上第i个物品的空间A[i]，即为当背包总空间为j时，装入第i个物品背包的总装满空间。</li><li>当然第i个物品所占的空间可能比此时背包的总空间j要大(<code>j &lt; A[i]</code>)，此时装不进第i个物品，因此此时背包的总装满空间为<code>dp[i-1][j]</code>。</li><li>还有一种可能的情形是，虽然第i个物品能够装入包中，但为了把第i个物品装入而拿出了其他物品，使此时的总装入空间<code>dp[i-1][j-A[i]] + A[i] &lt; dp[i-1][j]</code>。</li><li>其他情形： 当j = 0时，<code>dp[i][0] = 0</code></li><li>建立的动态规划数组大小为<code>dp[A.length][m + 1]</code>，之所以需要m + 1列是因为需要考虑背包空间大小为0时的情况</li><li><img src="http://m.qpic.cn/psb?/V102Jpn32UNsWb/iWMyjreIpNFNpe0v4fEd0VFpHllDfiC7UYuLx3eFMuU!/b/dAcBAAAAAAAA&amp;bo=DQPEAAAAAAADB.g!&amp;rf=viewer_4" alt=""></li><li>参考自文章<a href="http://blog.csdn.net/wutingyehe/article/details/46910103" target="_blank" rel="external">【LintCode】Backpack 背包问题</a>。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;题目：&lt;/p&gt;
&lt;p&gt;​    在n个物品中挑选若干物品装入背包，最多能装多满？假设背包的大小为m，每个物品的大小为A[i]&lt;/p&gt;
&lt;p&gt;样例：&lt;/p&gt;
&lt;p&gt;​    如果有4个物品&lt;strong&gt;[2, 3, 5, 7]&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;​    如果
      
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="动态规划" scheme="http://yoursite.com/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>[算法] 删除二叉搜索树中的某一个节点</title>
    <link href="http://yoursite.com/2018/01/30/%5B%E7%AE%97%E6%B3%95%5D%20%E5%88%A0%E9%99%A4%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E6%9F%90%E4%B8%80%E4%B8%AA%E8%8A%82%E7%82%B9/"/>
    <id>http://yoursite.com/2018/01/30/[算法] 删除二叉搜索树中的某一个节点/</id>
    <published>2018-01-30T05:13:10.000Z</published>
    <updated>2018-01-30T05:28:38.952Z</updated>
    
    <content type="html"><![CDATA[<p>题目：删除二叉搜索树中满足某个条件的节点</p><p>具体代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">deleteNode</span><span class="params">(TreeNode root, <span class="keyword">int</span> key)</span> </span>&#123;</div><div class="line">      <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">      &#125;</div><div class="line">      </div><div class="line">      <span class="keyword">if</span> (root.val &lt; key) &#123;</div><div class="line">        root.right = deleteNode(root.right, key);</div><div class="line">        <span class="keyword">return</span> root;</div><div class="line">      &#125;</div><div class="line">      </div><div class="line">      <span class="keyword">if</span> (root.val &gt; key) &#123;</div><div class="line">        root.left = deleteNode(root.left, key);</div><div class="line">        <span class="keyword">return</span> root;</div><div class="line">      &#125;</div><div class="line">      </div><div class="line">      <span class="keyword">if</span> (root.left == <span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span>) &#123;</div><div class="line">        root = <span class="keyword">null</span>;</div><div class="line">        <span class="keyword">return</span> root;</div><div class="line">      &#125;</div><div class="line">      </div><div class="line">      <span class="keyword">if</span> (root.left != <span class="keyword">null</span> &amp;&amp;root.right == <span class="keyword">null</span>) &#123;</div><div class="line">        root = root.left;</div><div class="line">        <span class="keyword">return</span> root;</div><div class="line">      &#125;</div><div class="line">      </div><div class="line">      <span class="keyword">if</span> (root.left == <span class="keyword">null</span> &amp;&amp; root.right != <span class="keyword">null</span>) &#123;</div><div class="line">        root = root.right;</div><div class="line">        <span class="keyword">return</span> right;</div><div class="line">      &#125;</div><div class="line">      </div><div class="line">      <span class="comment">// 重新调整二叉树，首先在左子树中找出最大值，将最大值赋值给根结点，然后删除左子树中值最大的节点，新的子树赋值给根结点的左子树</span></div><div class="line">      <span class="keyword">if</span> (root.left != <span class="keyword">null</span> &amp;&amp; root.right != <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">int</span> val = findMaxInLeftTree(root.left);</div><div class="line">        root.val = val;</div><div class="line">        root.left = deleteNode(root.left, val);</div><div class="line">        <span class="keyword">return</span> root;</div><div class="line">      &#125;</div><div class="line">      </div><div class="line">      <span class="keyword">return</span> root;</div><div class="line">&#125;  </div><div class="line">  </div><div class="line">  <span class="function"><span class="keyword">int</span> <span class="title">findMaxInLeftTree</span><span class="params">(TreeNode node)</span> </span>&#123;</div><div class="line">      <span class="keyword">if</span> (node == <span class="keyword">null</span>) &#123; <span class="comment">// 空节点，直接返回</span></div><div class="line">        <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">      &#125;</div><div class="line">      </div><div class="line">      <span class="keyword">if</span> (node.right == <span class="keyword">null</span>) &#123; <span class="comment">// 右子树的节点的值比根结点的值大，若右子树为空，则直接返回根结点的值</span></div><div class="line">        <span class="keyword">return</span> node.val;</div><div class="line">      &#125;</div><div class="line">      </div><div class="line">      <span class="keyword">if</span> (node.right == <span class="keyword">null</span> &amp;&amp; node.left == <span class="keyword">null</span>) &#123; <span class="comment">// 左子树和右子树均为空，则直接返回根结点的值</span></div><div class="line">        <span class="keyword">return</span> node.val;</div><div class="line">      &#125;</div><div class="line">      </div><div class="line">      <span class="keyword">return</span> findMaxInLeftTree(node.right); <span class="comment">// 左子树和右子树都不为空，最大值必然在右子树中，则递归找出右子树中的最大值</span></div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;题目：删除二叉搜索树中满足某个条件的节点&lt;/p&gt;
&lt;p&gt;具体代码如下：&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div c
      
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="二叉搜索树" scheme="http://yoursite.com/tags/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>[算法] 最长回文子串</title>
    <link href="http://yoursite.com/2018/01/30/%5B%E7%AE%97%E6%B3%95%5D%20%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2/"/>
    <id>http://yoursite.com/2018/01/30/[算法] 最长回文子串/</id>
    <published>2018-01-30T03:28:34.000Z</published>
    <updated>2018-01-30T03:44:42.807Z</updated>
    
    <content type="html"><![CDATA[<p>题目：找出一个字符串中的最长回文子串！</p><p>回文字符串的子串也是回文，比如P[i,j]（表示以i开始以j结束的子串）是回文字符串，那么P[i + 1, j - 1]也是回文字符串，这样最长回文子串就能分解成一系列子问题了。</p><p>首先定义状态方程和转移方程，P[i,j] = 0表示子串[i,j]不是回文子串，P[i,j] = 1表示子串[i, j]是回文子串：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">P[i, i] = 1;</div><div class="line">P[i, j] = P[i + 1, j - 1], if s[i] == s[j];</div><div class="line">P[i, j] = 0, if s[i] != s[j];</div></pre></td></tr></table></figure><p>具体代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="built_in">string</span> <span class="title">findLongestPalindrome</span><span class="params">(<span class="built_in">string</span>&amp; s)</span> </span>&#123;</div><div class="line">  <span class="keyword">const</span> <span class="keyword">int</span> length = s.size();</div><div class="line">  <span class="keyword">int</span> maxLength = <span class="number">0</span>;</div><div class="line">  <span class="keyword">int</span> start;</div><div class="line">  <span class="keyword">bool</span> P[<span class="number">50</span>][<span class="number">50</span>] = &#123;<span class="literal">false</span>&#125;;</div><div class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++) &#123; <span class="comment">// 初始化</span></div><div class="line">    P[i][i] = <span class="literal">true</span>;</div><div class="line">    <span class="keyword">if</span> (i &lt; length - <span class="number">1</span> &amp;&amp; s.at(i) == s.at(i + <span class="number">1</span>)) &#123;</div><div class="line">      P[i][i + <span class="number">1</span>] = <span class="literal">true</span>;</div><div class="line">      start = i;</div><div class="line">      maxLength = <span class="number">2</span>;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  </div><div class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> len = <span class="number">3</span>; len &lt;= length; len++) &#123; <span class="comment">// 子串长度</span></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= length - len; i++) &#123; <span class="comment">// 子串起始地址</span></div><div class="line">      <span class="keyword">int</span> j = i + len - <span class="number">1</span>; <span class="comment">// 子串结束地址</span></div><div class="line">      <span class="keyword">if</span> (P[i + <span class="number">1</span>][j - <span class="number">1</span>] &amp;&amp; s.at(i) == s.at(j)) &#123;</div><div class="line">        p[i][j] = <span class="literal">true</span>;</div><div class="line">        maxLength = len;</div><div class="line">        start = i;</div><div class="line">      &#125;</div><div class="line">    &#125; </div><div class="line">  &#125;</div><div class="line">  </div><div class="line">  <span class="keyword">if</span> (maxLength &gt; <span class="number">2</span>) &#123;</div><div class="line">    <span class="keyword">return</span> s.substr(start, maxLength);</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> <span class="literal">nullptr</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;题目：找出一个字符串中的最长回文子串！&lt;/p&gt;
&lt;p&gt;回文字符串的子串也是回文，比如P[i,j]（表示以i开始以j结束的子串）是回文字符串，那么P[i + 1, j - 1]也是回文字符串，这样最长回文子串就能分解成一系列子问题了。&lt;/p&gt;
&lt;p&gt;首先定义状态方程和转移方程
      
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="动态规划" scheme="http://yoursite.com/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>[Java] Java书籍推荐</title>
    <link href="http://yoursite.com/2018/01/27/%5BJava%5D%20Java%E4%B9%A6%E7%B1%8D%E6%8E%A8%E8%8D%90/"/>
    <id>http://yoursite.com/2018/01/27/[Java] Java书籍推荐/</id>
    <published>2018-01-27T05:44:35.000Z</published>
    <updated>2018-01-27T05:53:15.120Z</updated>
    
    <content type="html"><![CDATA[<ul><li><p>《Spring Boot实战》</p></li><li><p>《Head First设计模式》</p><p>隆重推荐这本神书,很有趣.刚开始读觉得很深,但是和《轻量级Java EE企业应用实战》一起看,思考那些设计模式存在的意义,会对软件架构方面的知识豁然开朗…</p></li><li><p>《Java并发编程实践》</p><p>又是个歪果仁写的书,里面详细介绍了Java并发工具包java.util.concurrent的各种工具以及很多的并发编程实践之道,是并发编程的入门之作。</p></li><li><p>《Java并发编程的艺术》</p><p>国人写的书,也是写Java并发编程的,与上一本相比个人认为比较凝练/干净/易懂</p></li><li><p>《架构探险:从零开始写Java Web框架》</p><p>作者叫黄勇,一本非常让我拍手叫绝的书….首推!绝对干货!如果你不想看spring源码也没有太大关系,这本书带你一步步地开发出一个类似spring mvc的简单框架,并且逐步地增加需求和完善,理解了每个细节对于理解Java Web的开发是很有帮助的。</p></li><li><p>《深入分析Java Web技术内幕》</p><p>这本书我觉得是必看的,可以说是对我帮助最大的一本技术书籍,覆盖了Java Web很多方面的知识,比如计算机网络|Tomcat结构|Spring架构|SpringMVC原理|模板引擎实现原理等,绝对很有收货,足够有深度也很有难度。</p></li><li><p>《Spring源码深度剖析》</p><p>一本比较详细的书,其实对于阅读源代码,跟着作者的思路读,再结合自己的断点调试进行学习的方式是最好的。</p></li><li><p>《深入理解Java虚拟机-(JVM高级特性与最佳实践)》</p><p>想知道Java虚拟机为什么会帮你自动收集垃圾而不需要你管理资源释放吗?想知道Java虚拟机的内存区域是如何划分的吗?想知道Java虚拟机是如何唯一确定一个Java实现类,并且如何加载类的吗?想知道JVM凭什么能够将远程服务器发送的网络字节加载到JVM内存,从而实现远程过程调用的吗?这本书你值得拥有!(感谢这本书让我回答出RPC的实现原理)</p></li><li><p>《MySQL技术内幕-InnoDB存储引擎》</p></li><li><p>《大型网站技术架构:核心原理与案例分析》</p><p>李智慧著,确实是很好的入门书籍.实际上如果有操作系统和Web项目后台开发的基础话阅读起来不会特别困难,主要内容是介绍当今企业应对大型网站高并发请求的种种策略。</p></li><li><p>《分布式Java应用-基础与实践》</p><p>这本书比较深,介绍分布式Java应用和相应的应用场景,什么远程过程调用(RPC)呀,基于服务的体系架构呀(SOA)等,同时也讲了很多java比较底层的知识,最后介绍构建高可用/可伸缩系统的工程经验。</p></li><li><p>《大型分布式网站架构:设计与实践》</p><p>与上一本书类似,不过个人觉得更偏向于”介绍”互联网安全架构和分布式系统的各种组件(比如分布式缓存|消息队列|搜索引擎等),目前我只接触了Redis,相应的组件实在太多了- -此外对系统监控和数据分析等也做了相应介绍,这些我感觉比较偏向运维岗的工作人员。</p></li><li><p>《Redis实战》</p><p>Redis的基本用法和在生产环境的应用,值得拥有,虽然书籍是用python,不过官方github也有放java的源码。</p></li><li><p>《Redis设计与实现》</p><p>Redis的源码解读,怎么说呢,反正比spring源码好读太多了….而且作者读得很用心,整理出了带注释版本的redis源码,去读个痛快吧少年。</p></li><li><p>转自<a href="http://vlambda.com/wz_wCMChbqotv.html" target="_blank" rel="external">阿里巴巴等大厂的 Java岗位要求是什么？</a>。</p><p>​</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;&lt;p&gt;《Spring Boot实战》&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;《Head First设计模式》&lt;/p&gt;
&lt;p&gt;隆重推荐这本神书,很有趣.刚开始读觉得很深,但是和《轻量级Java EE企业应用实战》一起看,思考那些设计模式存在的意义,会对软件架构方面的知
      
    
    </summary>
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>[TCPIP] 利用TCP/IP参考模型分析数据传输过程</title>
    <link href="http://yoursite.com/2017/12/23/%5BTCPIP%5D%20%E5%88%A9%E7%94%A8TCPIP%E5%8F%82%E8%80%83%E6%A8%A1%E5%9E%8B%E5%88%86%E6%9E%90%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93%E8%BF%87%E7%A8%8B/"/>
    <id>http://yoursite.com/2017/12/23/[TCPIP] 利用TCPIP参考模型分析数据传输过程/</id>
    <published>2017-12-23T03:51:45.000Z</published>
    <updated>2017-12-23T03:54:21.003Z</updated>
    
    <content type="html"><![CDATA[<p><a href="http://blog.sina.com.cn/s/blog_5ec353710101i892.html" target="_blank" rel="external">利用TCP/IP参考模型分析数据传输过程</a>。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;http://blog.sina.com.cn/s/blog_5ec353710101i892.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;利用TCP/IP参考模型分析数据传输过程&lt;/a&gt;。&lt;/p&gt;

      
    
    </summary>
    
      <category term="TCP/IP" scheme="http://yoursite.com/categories/TCP-IP/"/>
    
    
  </entry>
  
  <entry>
    <title>[DB] 事务的隔离级别</title>
    <link href="http://yoursite.com/2017/12/15/%5BDB%5D%20%E4%BA%8B%E5%8A%A1%E7%9A%84%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB/"/>
    <id>http://yoursite.com/2017/12/15/[DB] 事务的隔离级别/</id>
    <published>2017-12-15T02:39:53.000Z</published>
    <updated>2017-12-15T03:09:37.713Z</updated>
    
    <content type="html"><![CDATA[<ul><li><p>数据库事务有不同的隔离级别，不同的隔离级别对锁的使用是不同的，锁的应用最终导致不同事务的隔离级别。</p></li><li><p>隔离级别有以下四种：</p><ul><li>读未提交（Read Uncommitted）</li><li>读已提交（Read Committed）大多数数据库默认的隔离级别</li><li>可重复读（Repeatable-Read）mysql数据库默认的级别</li><li>序列化（serializable）</li></ul></li><li><p>看下面这个例子，A修改事务级别为未提交读，并开始事务，对user表做一次查询：</p><p><img src="https://pic2.zhimg.com/50/v2-f3f7a559c42064af5102ab95388d654d_hd.jpg" alt=""></p><p>B事务更新一条记录：</p><p><img src="https://pic2.zhimg.com/50/v2-4ae7a68c02f2a64605faa60908e72e1d_hd.jpg" alt=""></p><p>此时B事务还未提交，A在事务内做一次查询，发现查询结果已经改变：</p><p><img src="https://pic3.zhimg.com/50/v2-ce2497f31b85344940ad46e9f20a3626_hd.jpg" alt=""></p><p>B进行事务回滚：</p><p><img src="https://pic3.zhimg.com/50/v2-ef013f5c7c697460311c30e5211b4afe_hd.jpg" alt=""></p><p>A再做一次查询，查询结果又变回去了：</p><p><img src="https://pic1.zhimg.com/50/v2-579f1ebaac2616411603687b6a6b6160_hd.jpg" alt=""></p><p>由试验可知，在一个进程的事务当中，我更改了其中的一行数据，但是我修改完之后就释放了锁，这时候另一个进程读取了该数据，此时先前的事务是还未提交的，直到我回滚了数据，另一个进程读的数据就变成了无用的或是错误的数据，我们通常把这种数据称为脏数据，这种情况读出来的数据叫脏读。</p></li><li><p>之前是只要操作完数据就立刻释放掉锁，现在是把释放锁的位置调整到事务提交之后，此时在事务提交之前，其他进程是无法对该行数据进行读取的，包括任何操作。那么数据库为此种状态的数据库操作规则又给了一个名字叫“读已提交（Read Committed）”，或者叫不可重复读。</p></li><li><p>把隔离性调整为READ-COMMITTED（读取提交内容），设置A的事务隔离级别，并进入事务做一次查询：</p><p><img src="https://pic2.zhimg.com/50/v2-501201e5e87e1b9b94f5410fc1e60435_hd.jpg" alt=""></p><p>B开始事务，并对记录进行修改：</p><p><img src="https://pic1.zhimg.com/50/v2-bb86e5eaaa89d342125a426c05a096a0_hd.jpg" alt=""></p><p>A再对user表进行查询，发现记录没有受到影响：</p><p><img src="https://pic4.zhimg.com/50/v2-f1ed9b67af09782dc16b832a2796907b_hd.jpg" alt=""></p><p>B提交事务：</p><p><img src="https://pic3.zhimg.com/50/v2-30a832483a152dc31c818de21acf737a_hd.jpg" alt=""></p><p>A再对user表进行查询，发现记录被修改：</p><p><img src="https://pic2.zhimg.com/50/v2-fd2565c4437cfd385f408e5535694169_hd.jpg" alt=""></p><p>试验进行到这里，你会发现，在同一个事务中如果两次读取相同的数据时，最后的结果却不一致。这里我们把这种现象称为：不可重复读。因为在第一个事务读取了数据之后，此时另一个事务把该数据给修改了，这时候事务提交，那么另一个事务在第二次读取的时候，结果就不一样，一个修改前的，一个是修改后的。</p><p>但是细心的你会发现，既然你说此种隔离性是在事务提交后才释放锁，那么在试验过程中，在该数据未提交前，另一个事务为什么也是仍然可以读取的呀。是我说错了吗？不是的，在这里mysql使用了一个并发版本控制机制，他们把它叫做MVCC，通俗的也就是说：mysql为了提高系统的并发量，在事务未提交前，虽然事务内操作的数据是锁定状态，但是另一个事务仍然可以读取，大多数数据库默认的就是这个级别的隔离性。但mysql不是。</p><p>而且不只是在更新数据时出现这个问题，在插入数据时仍然会造成类似的这样一种现象：mysql虽然锁住了正在操作的数据行，但它仍然不会阻止另一个事务往表插入新行新的数据。比如：一个事务读取或更新了表里的所有行，接着又有另一个事务往该表里插入一个新行，在事务提交后。原来读取或更改过数据的事务又第二次读取了相同的数据，这时候这个事务中两次读取的结果集行数就不一样。原来更新了所有行，而现在读出来发现竟然还有一行没有更新。这就是所谓的幻读。</p><p>为了防止同事务中两次读取数据不一致，（包括不可重读和幻读），接下来该如何继续做呢？！</p><p>mysql依然采取的是MVCC并发版本控制来解决这个问题。具体是：如果事务中存在多次读取同样的数据，MySQL第一次读的时候仍然会保持选择读最新提交事务的数据，当第一次之后，之后再读时，mysql会取第一次读取的数据作为结果。这样就保证了同一个事务多次读取数据时数据的一致性。这时候，mysql把这种解决方案叫做：可重复读（Repeatable-Read)，也就是上述所写的第三个隔离性，也是mysql默认的隔离级别。</p><p>注意：幻读和不可重复读（Read Committed）都是读取了另一条已经提交的事务（这点就脏读不同），所不同的是不可重复读查询的都是同一个数据项，而幻读针对的是一批数据整体（比如数据的个数）。</p><p>说到这里，真的就完事了吗？到这里其实mysql并未完全解决数据的一致性问题。只是在读取上做了手脚，解决了传统意义上的幻读和不可重复读。<br>例子：1 A事务开启，B事务开启。<br>​           2 B事务往表里面插入了一条数据，但还并未提交。<br>​           3 A事务开始查询了，并没有发现B事务这次插入的数据。然后此时B事务提交了数据。<br>​           4 于是乎，A事务就以为没有这条数据，就开始添加这条数据，但是却发现，发生了数据 重复冲突。</p><p>最后这个时候，该我们的最后一种隔离级别也是最高的隔离级：别序列化（serializable）登场了。<br>该隔离级别会自动在锁住你要操作的整个表的数据，如果另一个进程事务想要操作表里的任何数据就需要等待获得锁的进程操作完成释放锁。可避免脏读、不可重复读、幻读的发生。当然性能会下降很多，会导致很多的进程相互排队竞争锁。</p><p>后记：以上所说的四种隔离性的锁机制应用是数据库自动完成的，不需要人为干预。隔离级别的设置只对当前链接有效。对于使用MySQL命令窗口而言，一个窗口就相当于一个链接，当前窗口设置的隔离级别只对当前窗口中的事务有效</p></li><li><p>本文转自<a href="https://www.zhihu.com/question/30272728/answer/95908054" target="_blank" rel="external">数据库事务原子性、一致性是怎样实现的？</a></p><p>​</p><p>​</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;&lt;p&gt;数据库事务有不同的隔离级别，不同的隔离级别对锁的使用是不同的，锁的应用最终导致不同事务的隔离级别。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;隔离级别有以下四种：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;读未提交（Read Uncommitted）&lt;/li&gt;
&lt;li&gt;读已提交（
      
    
    </summary>
    
      <category term="DB" scheme="http://yoursite.com/categories/DB/"/>
    
    
      <category term="事务隔离级别" scheme="http://yoursite.com/tags/%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB/"/>
    
  </entry>
  
  <entry>
    <title>[TCPIP] 三次握手和四次挥手</title>
    <link href="http://yoursite.com/2017/12/14/%5BTCPIP%5D%20%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%92%8C%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B/"/>
    <id>http://yoursite.com/2017/12/14/[TCPIP] 三次握手和四次挥手/</id>
    <published>2017-12-14T11:26:02.000Z</published>
    <updated>2017-12-14T11:27:23.912Z</updated>
    
    <content type="html"><![CDATA[<p>可参考<a href="https://www.zhihu.com/question/24853633" target="_blank" rel="external">TCP 为什么是三次握手，为什么不是两次或四次？</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;可参考&lt;a href=&quot;https://www.zhihu.com/question/24853633&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;TCP 为什么是三次握手，为什么不是两次或四次？&lt;/a&gt;&lt;/p&gt;

      
    
    </summary>
    
      <category term="TCPIP" scheme="http://yoursite.com/categories/TCPIP/"/>
    
    
      <category term="三次握手, 四次挥手" scheme="http://yoursite.com/tags/%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B-%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B/"/>
    
  </entry>
  
  <entry>
    <title>[Java] Java虚拟机</title>
    <link href="http://yoursite.com/2017/12/14/%5BJava%5D%20Java%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    <id>http://yoursite.com/2017/12/14/[Java] Java虚拟机/</id>
    <published>2017-12-14T09:22:58.000Z</published>
    <updated>2017-12-14T14:07:27.242Z</updated>
    
    <content type="html"><![CDATA[<ul><li><p>JVM物理结构：</p><p><img src="http://wiki.jikexueyuan.com/project/java-vm/images/jvm.gif" alt=""></p><p>Java编译器只面向JVM，生成JVM能理解的代码或字节码文件，Java源文件经编译器，编译成字节码程序，通过JVM将每一条指令翻译成不同平台机器码，通过特定平台运行！</p></li><li><p>Java代码编译和执行的整个过程包含三个重要的机制：</p><ul><li>Java源码编译机制</li><li>类加载机制</li><li>类执行机制</li></ul></li><li><p>Java源码编译机制由三个过程组成：</p><ul><li>分析和输入到符号表</li><li>注解处理</li><li>语义分析和生成class文件</li></ul></li><li><p>类加载过程中会先检查类是否已被加载，检查顺序是自底向上，从Custom ClassLoader到BootStrap ClassLoader逐层检查，只要某个ClassLoader已加载就视为已加载该类，保证此类只被加载一次，而加载的顺序是自顶向下的，也就是由上层来逐层尝试加载此类。</p></li><li><p>JVM是基于栈的体系结构来执行class字节码文件的，线程创建后，都会产生程序计数器（PC）和栈（Stack），程序计数器存放下一条要执行的指令在方法内的偏移量，栈中存放一个个栈帧，每个栈帧对应着每个方法的每次调用，而栈帧又是由局部变量区和操作数栈两部分组成，局部变量区用于存放方法中的局部变量和参数，操作数栈中用于存放方法执行过程中产生的中间结果。</p></li><li><p>Java虚拟机规范将JVM所管理的内存分为以下几个运行时数据区：程序计数器、Java虚拟机栈、本地方法栈、Java堆、方法区。</p><p>其中，Java堆和方法区是线程共享内存区，而虚拟机栈、本地方法栈和程序计数器则是线程私有内存区。</p><ul><li><p>程序计数器</p><p>每条线程都有一个独立的程序计数器，各线程间的计数器互不影响，因此该区域是线程私有的。当程序执行一个Java方法时，该计数器记录的是正在执行的虚拟机字节码指令的地址，当线程在执行的是Native方法时，该计数器的值为空。另外，该内存区是唯一一个在Java虚拟机规范中没有规定任何OOM情况的区域。</p></li><li><p>Java虚拟机栈</p><p>该区域是线程私有的，它的生命周期和线程相同</p></li><li><p>本地方法栈</p><p>虚拟机栈为虚拟机执行Java方法服务，而本地方法栈则为使用到的本地操作系统方法服务。</p></li><li><p>Java堆</p><p>Java堆是所有线程共享的一块内存区域，几乎所有的对象实例和数组都在这类分配内存，Java Heap是垃圾收集器管理的主要区域，因此很多时候称为GC堆。</p></li><li><p>方法区</p><p>方法区是各个线程共享的内存区域，它用于存储已经被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。方法区又被称为永久代，但这仅仅对于Sun HotSpot来说。Java虚拟机规范把方法区描述为Java堆的一个逻辑部分，另外，虚拟机规范允许该区域可以选择不实现垃圾回收，相对而言，垃圾收集行为在这个区域比较少出现，该区域的内存回收目标主要是针对废弃常量和无用类的回收。运行时常量池是方法区的一部分，Class文件中除了有类的版本、字段、方法、接口等信息之外，还有一项就是常量池，用于存放编译器生成的各种字面量和符号引用，这部分内容将在类加载后存放到方法区的运行时常量池中。运行时常量池相对于Class文件常量池的另一个重要特性就是具备动态性，Java语言并不要求常量一定只能在编译器产生，也就是并非预置于Class文件中的常量池中的内容才能进入方法区的运行时常量池，运行期间也可能将新的常量放入池中，这种特性被开发人员利用较多的是String类的intern()方法。</p><p>当方法区无法满足内存分配需求时，将抛出OutOfMemoryError异常。</p></li><li><p>​</p><p>直接内存并不是虚拟机运行时数据区的一部分，也不是 Java 虚拟机规范中定义的内存区域，它直接从操作系统中分配，因此不受 Java 堆大小的限制，但是会受到本机总内存的大小及处理器寻址空间的限制，因此它也可能导致 OutOfMemoryError 异常出现。在 JDK1.4 中新引入了 NIO 机制，它是一种基于通道与缓冲区的新 I/O 方式，可以直接从操作系统中分配直接内存，即在堆外分配内存，这样能在一些场景中提高性能，因为避免了在 Java 堆和 Native 堆中来回复制数据。</p></li></ul></li><li><p>类初始化是类加载过程的最后一个阶段，到初始化阶段，才真正开始执行类中的Java程序代码，虚拟机规范严格规定了有且只有四种情况必须立即对类进行初始化：</p><ul><li>遇到new、getstatic、putstatic、invokestatic这四条字节码指定时，如果类还没有进行初始化，则需要触发其初始化，生成这四条指令最常见的Java代码场景是：使用new关键字实例化对象时、读取或设置一个类的静态字段（static）时（被static修饰又被final修饰的，已在编译期把结果放入常量池的静态字段除外）以及调用一个类的静态方法时；</li><li>使用java.lang.refect包的方法对类进行反射调用时，如果类还没有进行初始化，则需要触发其初始化；</li><li>当初始化一个类的时候，如果发现其父类还没有进行初始化，则需要先触发其父类的初始化；</li><li>当虚拟机启动时，用户需要指定一个要执行的主类，虚拟机会先执行该主类。</li></ul><p>虚拟机只有这四种情况才会触发类的初始化，称为对一个类进行主动引用，除此之外所有引用类的方式都不会触发其初始化，称为被动引用，下面举一些例子来说明被动引用：</p><p>通过子类引用父类中的静态字段，这时对子类的引用为被动引用，因此不会初始化子类，只会初始化父类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Father</span> </span>&#123;</div><div class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> m = <span class="number">33</span>;</div><div class="line">  <span class="keyword">static</span> &#123;</div><div class="line">    System.out.println(<span class="string">"父类被初始化"</span>);</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span> <span class="keyword">extends</span> <span class="title">Father</span> </span>&#123;</div><div class="line">  <span class="keyword">static</span> &#123;</div><div class="line">    System.out.println(<span class="string">"子类被初始化"</span>);</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticTest</span> </span>&#123;</div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">    System.out.println(Child.m);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>执行结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">父类被初始化</div><div class="line">33</div></pre></td></tr></table></figure><p>对于静态字段，只有直接定义这个字段的类才会被初始化，因此，通过子类来引用父类中定义的静态字段，只会触发父类的初始化而不会触发子类的初始化。</p><p>常量在编译阶段会被存入调用它的类的常量池中，本质上没有直接引用到定义该常量的类，因此不会触发定义常量的类的初始化：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Const</span> </span>&#123;</div><div class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String NAME = <span class="string">"我是常量"</span>;</div><div class="line">  <span class="keyword">static</span> &#123;</div><div class="line">    System.out.println(<span class="string">"初始化Const类"</span>);</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FinalTest</span></span>&#123;  </div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;  </div><div class="line">    System.out.println(Const.NAME);  </div><div class="line">  &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure><p>执行后输出的结果为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">我是常量</div></pre></td></tr></table></figure><p>虽然程序中引用了 const 类的常量 NAME，但是在编译阶段将此常量的值“我是常量”存储到了调用它的类 FinalTest 的常量池中，对常量 Const.NAME 的引用实际上转化为了 FinalTest 类对自身常量池的引用。也就是说，实际上 FinalTest 的 Class 文件之中并没有 Const 类的符号引用入口，这两个类在编译成 Class 文件后就不存在任何联系了。</p><p>通过数组定义来引用类，不会触发类的初始化：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Const</span></span>&#123;  </div><div class="line">  <span class="keyword">static</span>&#123;  </div><div class="line">    System.out.println(<span class="string">"初始化Const类"</span>);  </div><div class="line">  &#125;  </div><div class="line">&#125;  </div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayTest</span></span>&#123;  </div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;  </div><div class="line">    Const[] con = <span class="keyword">new</span> Const[<span class="number">5</span>];  </div><div class="line">  &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure><p>执行后不输出任何信息，说明 Const 类并没有被初始化。</p></li><li><p>Java程序最初是仅仅通过解释器进行执行的，即对字节码逐条解释执行，这种方式的执行速度相对会比较慢，尤其是当某个方法或代码块运行的特别频繁的时候，这种方式的执行效率就显得很低，于是后来在虚拟机中引入了JIT编译器（即时编译器），当虚拟机发现某个方法或代码块执行比较频繁的时候，就会把这些代码认定为“Hot Spot Code”（热点代码），为了提高热点代码的执行效率，在运行时，虚拟机将会把这些代码编译成与本地平台相关的机器码，并进行各层次的优化，完成这项任务的正是JIT编译器。</p><p>当程序需要迅速启动和执行时，解释器可以首先发挥作用，省去编译的时间，立即执行；当程序运行后，随着时间的推移，编译器会逐渐发挥作用，把越来越多的代码编译成本地代码后，可以获得更高的执行效率。</p><p>解释执行可以节约内存，而编译执行可以提升效率。</p><p>运行过程中会被即时编译器编译的“热点代码”有两类：</p><ul><li>被多次调用的方法</li><li>被多次调用的循环体</li></ul></li><li><p>本文参考自<a href="http://wiki.jikexueyuan.com/project/java-vm/" target="_blank" rel="external">深入理解 Java 虚拟机</a>。</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;&lt;p&gt;JVM物理结构：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://wiki.jikexueyuan.com/project/java-vm/images/jvm.gif&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;Java编译器只面向JVM，生成JVM能理解的代码或字
      
    
    </summary>
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="Java, 虚拟机, 类加载" scheme="http://yoursite.com/tags/Java-%E8%99%9A%E6%8B%9F%E6%9C%BA-%E7%B1%BB%E5%8A%A0%E8%BD%BD/"/>
    
  </entry>
  
  <entry>
    <title>[DB] JDBC知识点</title>
    <link href="http://yoursite.com/2017/12/13/%5BDB%5D%20JDBC%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    <id>http://yoursite.com/2017/12/13/[DB] JDBC知识点/</id>
    <published>2017-12-13T08:47:13.000Z</published>
    <updated>2017-12-13T09:25:42.160Z</updated>
    
    <content type="html"><![CDATA[<ul><li><p>JDBC：Java DataBase Connect，即Java数据库连接，我们可以用它来操作关系型数据库。</p></li><li><p>JDBC的Statement：</p><p>Statement是JDBC中用来执行数据库SQL查询语句的接口。通过调用连接对象的getStatement()方法可以生成一个Statement对象，我们可以通过调用它的execute()、executeQuery()、executeUpdate()方法来执行静态SQL查询。</p><p>Statement的execute(String query)方法用来执行任意的SQL查询，如果查询的结果是一个ResultSet，这个方法就返回true，如果不是ResultSet，比如insert或者update语句，他就会返回false，我们可以通过它的getResultSet方法来获取ResultSet，或者通过getUpdateCount()方法来获取更新的记录条数。</p><p>Statement的executeQuery(String query)接口用来执行select查询，并且返回ResultSet。即使查询不到记录返回的ResultSet也不会为null。我们通常使用executeQuery来执行查询语句，这样的话如果传进来的是insert或者update语句的话，它会抛出错误信息为 “executeQuery method can not be used for update”的java.util.SQLException。</p><p>Statement的executeUpdate(String query)方法用来执行insert或者update/delete（DML）语句，或者 什么也不返回DDL语句。返回值是int类型，如果是DML语句的话，它就是更新的条数，如果是DDL的话，就返回0。</p><p>只有当你不确定是什么语句的时候才应该使用execute()方法，否则应该使用executeQuery或者executeUpdate方法。</p></li><li><p>PreparedStatement：PreparedStatement对象代表的是一个预编译的SQL语句，用它提供的setter方法可以传入查询的变量。由于PreparedStatement是预编译的，通过它可以将对应的SQL语句高效的执行多次。</p></li><li><p>通过Statement的getGeneratedKeys()方法可以获取表自动生成的主键</p></li><li><p>脏读：当我们使用事务时，有可能会出现这样的情况，有一行数据刚更新，与此同时另一个查询读到了这个刚更新的值。这样就导致了脏读，因为更新的数据还没有进行持久化，更新这行数据的业务可能会进行回滚，这样这个数据就是无效的。</p><p>数据库的TRANSACTIONREADCOMMITTED，TRANSACTIONREPEATABLEREAD，和TRANSACTION_SERIALIZABLE隔离级别可以防止脏读。</p></li><li><p>幻读：指一个事务多次执行一条查询返回的却是不同的值，假设一个事务正根据某个条件进行数据查询，然后另一个事务插入了满足这个查询条件的语句，之后这个事务再次执行了这条查询，返回的结果集中会包含刚插入的那条新数据，这行新数据被称为幻行，这种现象称为幻读。</p><p>只有TRANSACTION_SERIALIZABLE隔离级别才能防止产生幻读。</p></li><li><p>java.util.Date和java.sql.Date有什么区别？</p><p>java.util.Date包含日期和时间，而java.sql.Date只包含日期信息，而没有具体的时间信息。如果你想把时间信息存储在数据库里，可以考虑使用Timestamp或者DateTime字段。</p></li><li><p>JDBC里的CLOB和BLOB数据类型分别代表什么？</p><p>CLOB即Character Large Objects，字符大对象，它是由单字节字符组成的字符串数据，这种数据类型适用于存储超长的文本信息，那么可能会超出标准的VARCHAR数据类型长度限制的文本。</p><p>BLOB即Binary Large Objects，它是二进制大对象，由二进制数据组成，它能用于存储超过VARBINARY限制的二进制数据，这种数据类型适合存储图片、声音、图形或者其他业务程序特定的数据。</p></li><li><p>数据库的隔离级别：当我们为了数据的一致性使用事务时，数据库系统用锁来防止别人访问事务中用到的数据，数据库通过锁来防止脏读、不可重复读以及幻读等问题。</p><p>数据库使用JDBC设置的隔离级别来决定使用何种锁机制，我们可以通过Connection的getTransactionIsolation和setTransactionIsolation方法来获取和设置数据库的隔离级别。</p><p>| 隔离级别                         | 事务   | 脏读   | 不可重复读 | 幻读   |<br>| —————————- | —- | —- | —– | —- |<br>| TRANSACTION_NONE             | 不支持  | 不可用  | 不可用   | 不可用  |<br>| TRANSACTION_READ_COMMITTED   | 支持   | 阻止   | 允许    | 允许   |<br>| TRANSACTION_READ_UNCOMMITTED | 支持   | 允许   | 允许    | 允许   |<br>| TRANSACTION_REPEATABLE_READ  | 支持   | 阻止   | 阻止    | 允许   |<br>| TRANSACTION_SERIALIZABLE     | 支持   | 阻止   | 阻止    | 阻止   |</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;&lt;p&gt;JDBC：Java DataBase Connect，即Java数据库连接，我们可以用它来操作关系型数据库。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;JDBC的Statement：&lt;/p&gt;
&lt;p&gt;Statement是JDBC中用来执行数据库SQL查询语句的接口。
      
    
    </summary>
    
      <category term="DB" scheme="http://yoursite.com/categories/DB/"/>
    
    
      <category term="DB JDBC" scheme="http://yoursite.com/tags/DB-JDBC/"/>
    
  </entry>
  
  <entry>
    <title>[Linux] vmware中启动ubuntu蓝屏</title>
    <link href="http://yoursite.com/2017/12/10/%5BLinux%5D%20vmware%E4%B8%AD%E5%90%AF%E5%8A%A8ubuntu%E8%93%9D%E5%B1%8F/"/>
    <id>http://yoursite.com/2017/12/10/[Linux] vmware中启动ubuntu蓝屏/</id>
    <published>2017-12-10T14:18:34.000Z</published>
    <updated>2017-12-10T14:21:08.698Z</updated>
    
    <content type="html"><![CDATA[<p>先进入字符界面：<strong>Ctrl + Alt + F4</strong></p><p>然后安装相应服务，然后重置它！</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">sudo apt-get install xserver-xorg-lts-utopic </div><div class="line">sudo dpkg-reconfigure xserver-xorg-lts-utopic </div><div class="line">reboot</div></pre></td></tr></table></figure><p>如果前面第一个操作有问题，需要重置 dpkg 后再试，总之按提示操作就好了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo dpkg --configure -a</div></pre></td></tr></table></figure><p>有看到其他人不是安装 xserver-xorg-lts-utopic，而是 xserver-xorg-lts-quantal 。估计是版本问题。</p><p>reboot 系统后，亲切的图形界面终于回来了！</p><p>本文转载自文章<a href="http://www.cnblogs.com/liaojieliang/p/ubuntu-blue.html" target="_blank" rel="external">VMware 虚拟机 Ubuntu 登录后蓝屏问题</a>。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;先进入字符界面：&lt;strong&gt;Ctrl + Alt + F4&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;然后安装相应服务，然后重置它！&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;d
      
    
    </summary>
    
      <category term="Linux" scheme="http://yoursite.com/categories/Linux/"/>
    
    
      <category term="Linux, vmware, ubuntu, 蓝屏" scheme="http://yoursite.com/tags/Linux-vmware-ubuntu-%E8%93%9D%E5%B1%8F/"/>
    
  </entry>
  
  <entry>
    <title>[DB] mysql的最左前缀匹配原则</title>
    <link href="http://yoursite.com/2017/12/10/%5BDB%5D%20mysql%E7%9A%84%E6%9C%80%E5%B7%A6%E5%89%8D%E7%BC%80%E5%8C%B9%E9%85%8D%E5%8E%9F%E5%88%99/"/>
    <id>http://yoursite.com/2017/12/10/[DB] mysql的最左前缀匹配原则/</id>
    <published>2017-12-10T09:43:29.000Z</published>
    <updated>2017-12-10T10:14:14.505Z</updated>
    
    <content type="html"><![CDATA[<p>mysql建立联合索引有最左前缀的原则，即最左优先，如：</p><p>如果有一个2列的索引(col1, col2)，则已经对(col1)、(col1, col2)上建立了索引；</p><p>如果有一个3列的索引(col1, col2, col3)，则已经对(col1)、(col1, col2)、(col1, col2, col3)上建立了索引；</p><p>总结：</p><ul><li>b+树的数据项是复合的数据结构，比如(name,age,sex)的时候，b+树是按照从左到右的顺序来建立搜索树的，比如当(张三,20,F)这样的数据来检索的时候，b+树会优先比较name来确定下一步的所搜方向，如果name相同再依次比较age和sex，最后得到检索的数据；但当(20,F)这样的没有name的数据来的时候，b+树就不知道第一步该查哪个节点，因为建立搜索树的时候name就是第一个比较因子，必须要先根据name来搜索才能知道下一步去哪里查询。</li><li>比如当(张三,F)这样的数据来检索时，b+树可以用name来指定搜索方向，但下一个字段age的缺失，所以只能把名字等于张三的数据都找到，然后再匹配性别是F的数据了， 这个是非常重要的性质，即索引的最左匹配特性。（这种情况无法用到联合索引）</li></ul><p>测试1：</p><p>联合索引： KEY <code>key_aS_aT</code> (<code>auditSt</code>,<code>applyTime</code>)</p><p>1、explain select <em> from tblArticle0 where applyTime=123 and auditSt =1 ;<br>2、 explain select </em> from tblArticle0 where auditSt =1 and applyTime =123 ;</p><p>测试结果：1和2两种情况都用到了索引key_aS_aT，所以索引顺序是可以颠倒的，只要where条件中的字段包含索引中的第一个字段即可。</p><p>测试2：</p><p>联合索引： KEY<code>sex_type_age on user(sex,type,age);</code></p><p>1、explain select <em> from user_test where sex = 2<br>2、explain select </em> from user_test where sex = 2 and type = 2<br>3、explain select * from user_test where sex = 2 and age = 10</p><p>测试结果：这3条sql语句都会用到联合索引sex_type_age，因为where条件中包含了第一个索引字段sex。</p><p>再看下面这种：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`student`</span> (</div><div class="line">  <span class="string">`id`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT,</div><div class="line">  <span class="string">`name`</span> <span class="built_in">varchar</span>(<span class="number">255</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</div><div class="line">  <span class="string">`cid`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</div><div class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>),</div><div class="line">  <span class="keyword">KEY</span> <span class="string">`name_cid_INX`</span> (<span class="string">`name`</span>,<span class="string">`cid`</span>)</div><div class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> AUTO_INCREMENT=<span class="number">8</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8;</div></pre></td></tr></table></figure><p>索引方面：id是主键，(name,cid)是一个多列索引。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">EXPLAIN</span> <span class="keyword">SELECT</span> * <span class="keyword">FROM</span> student <span class="keyword">WHERE</span>   cid=<span class="number">1</span>;</div></pre></td></tr></table></figure><p><img src="https://pic1.zhimg.com/50/d3086a6c81bb2c77796cfc2249b610bc_hd.jpg" alt=""></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">EXPLAIN</span> <span class="keyword">SELECT</span> * <span class="keyword">FROM</span> student <span class="keyword">WHERE</span>   cid=<span class="number">1</span> <span class="keyword">AND</span> <span class="keyword">name</span>=<span class="string">'小红'</span>;</div></pre></td></tr></table></figure><p><img src="https://pic3.zhimg.com/50/53ab2cdea64b7e58e66c4ef86aa6b06a_hd.jpg" alt=""></p><p><strong>你的疑问是</strong>：sql查询用到索引的条件是必须要遵守最左前缀原则，为什么上面两个查询还能用到索引？</p><p>上述你的两个查询的explain结果中显示用到索引的情况类型是不一样的。,可观察explain结果中的type字段。你的查询中分别是：</p><ol><li>type: index </li><li>type: ref  </li></ol><p><strong>解释：</strong><br>index：这种类型表示是mysql会对整个该索引进行扫描。要想用到这种类型的索引，对这个索引并无特别要求，只要是索引，或者某个复合索引的一部分，mysql都可能会采用index类型的方式扫描。但是呢，缺点是效率不高，mysql会从索引中的第一个数据一个个的查找到最后一个数据，直到找到符合判断条件的某个索引。</p><p><strong>所以：</strong>对于你的第一条语句：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">EXPLAIN</span> <span class="keyword">SELECT</span> * <span class="keyword">FROM</span> student <span class="keyword">WHERE</span>   cid=<span class="number">1</span>;</div></pre></td></tr></table></figure><p>判断条件是cid=1,而cid是(name,cid)复合索引的一部分，没有问题，可以进行index类型的索引扫描方式。explain显示结果使用到了索引，是index类型的方式。</p><p>ref：这种类型表示mysql会根据特定的算法快速查找到某个符合条件的索引，而不是会对索引中每一个数据都进行一 一的扫描判断，也就是所谓你平常理解的使用索引查询会更快的取出数据。而要想实现这种查找，索引却是有要求的，要实现这种能快速查找的算法，索引就要满足特定的数据结构。<strong>简单说，也就是索引字段的数据必须是有序的，才能实现这种类型的查找，才能利用到索引。</strong></p><p><strong>下面就说下复合索引：</strong><br>以该表的(name,cid)复合索引为例,它内部结构简单说就是下面这样排列的：</p><p><img src="https://pic2.zhimg.com/50/8c45fe417afbe97127e8c55fe1cd9395_hd.jpg" alt=""></p><p>mysql创建复合索引的规则是首先会对复合索引的最左边的，也就是第一个name字段的数据进行排序，在第一个字段的排序基础上，然后再对后面第二个的cid字段进行排序。其实就相当于实现了类似 order by name cid这样一种排序规则。</p><p>所以：第一个name字段是绝对有序的，而第二字段就是无序的了。所以通常情况下，直接使用第二个cid字段进行条件判断是用不到索引的，当然，可能会出现上面的使用index类型的索引。这就是所谓的mysql为什么要强调最左前缀原则的原因。</p><p><strong>那么什么时候才能用到呢?</strong><br>当然是cid字段的索引数据也是有序的情况下才能使用咯，什么时候才是有序的呢？观察可知，当然是在name字段是等值匹配的情况下，cid才是有序的。发现没有，观察两个name名字为 c 的cid字段是不是有序的呢。从上往下分别是4  5。<br>这也就是mysql索引规则中要求复合索引要想使用第二个索引，必须先使用第一个索引的原因。（而且第一个索引必须是等值匹配）。</p><p>所以对于你的这条sql查询：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">EXPLAIN</span> <span class="keyword">SELECT</span> * <span class="keyword">FROM</span> student <span class="keyword">WHERE</span>   cid=<span class="number">1</span> <span class="keyword">AND</span> <span class="keyword">name</span>=<span class="string">'小红'</span>;</div></pre></td></tr></table></figure><p>没有错，而且复合索引中的两个索引字段都能很好的利用到了！因为语句中最左面的name字段进行了等值匹配，所以cid是有序的，也可以利用到索引了。</p><p><strong>你可能会问</strong>：我建的索引是(name,cid)。而我查询的语句是cid=1 AND name=’小红’; 我是先查询cid，再查询name的，不是先从最左面查的呀？</p><p>好吧，我再解释一下这个问题：首先可以肯定的是把条件判断反过来变成这样 name=’小红’ and cid=1; 最后所查询的结果是一样的。<br>那么问题产生了？既然结果是一样的，到底以何种顺序的查询方式最好呢？</p><p>所以，而此时那就是我们的mysql查询优化器该登场了，mysql查询优化器会判断纠正这条sql语句该以什么样的顺序执行效率最高，最后才生成真正的执行计划。所以，当然是我们能尽量的利用到索引时的查询顺序效率最高咯，所以mysql查询优化器会最终以这种顺序进行查询执行。</p><p><strong>所以</strong>，而此时那就是我们的mysql查询优化器该登场了，mysql查询优化器会判断纠正这条sql语句该以什么样的顺序执行效率最高，最后才生成真正的执行计划。所以，当然是我们能尽量的利用到索引时的查询顺序效率最高咯，所以mysql查询优化器会最终以这种顺序进行查询执行。</p><p>本文转载自知乎<a href="https://www.zhihu.com/question/36996520" target="_blank" rel="external">mysql索引最左匹配原则的理解?</a>，作者沈杰链接：<a href="https://www.zhihu.com/question/36996520/answer/93256153。" target="_blank" rel="external">https://www.zhihu.com/question/36996520/answer/93256153。</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;mysql建立联合索引有最左前缀的原则，即最左优先，如：&lt;/p&gt;
&lt;p&gt;如果有一个2列的索引(col1, col2)，则已经对(col1)、(col1, col2)上建立了索引；&lt;/p&gt;
&lt;p&gt;如果有一个3列的索引(col1, col2, col3)，则已经对(col1)、
      
    
    </summary>
    
      <category term="DB" scheme="http://yoursite.com/categories/DB/"/>
    
    
      <category term="DB 最左前缀" scheme="http://yoursite.com/tags/DB-%E6%9C%80%E5%B7%A6%E5%89%8D%E7%BC%80/"/>
    
  </entry>
  
</feed>
