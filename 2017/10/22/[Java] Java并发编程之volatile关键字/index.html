<!DOCTYPE html>
<html>
<head>
    

    
<!-- Tencent Speed -->
<script>var _speedMark = new Date()</script>
<!-- End Tencent Speed -->
<!-- Tencent Analysis -->
<script async src="//tajs.qq.com/stats?sId=65601540"></script>
<!-- End Tencent Analysis -->


    



    <meta charset="utf-8">
    
    
    
    
    <title>[Java] Java并发编程之volatile关键字 | Glemontree&#39;s blog | day day up!</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    
    <meta name="theme-color" content="#3F51B5">
    
    
    <meta name="keywords" content="Java 并发 volatile">
    <meta name="description" content="说在前面本文转载自文章Java并发编程：volatile关键字解析，作者对volatile关键字的使用以及原理进行了详细的解析，我觉得写的非常好，所以转载下来做个记录，感谢作者。
内存模型的相关概念计算机在执行程序的时候每条指令都是在CPU中执行的，而执行指令的过程中势必涉及到数据的读取和写入。由于程序运行过程中的临时数据都是存放在主存（物理内存）当中的，这时就存在一个问题，由于CPU执行速度很快">
<meta property="og:type" content="article">
<meta property="og:title" content="[Java] Java并发编程之volatile关键字">
<meta property="og:url" content="https://glemontree.github.io/2017/10/22/[Java] Java并发编程之volatile关键字/index.html">
<meta property="og:site_name" content="Glemontree's blog">
<meta property="og:description" content="说在前面本文转载自文章Java并发编程：volatile关键字解析，作者对volatile关键字的使用以及原理进行了详细的解析，我觉得写的非常好，所以转载下来做个记录，感谢作者。
内存模型的相关概念计算机在执行程序的时候每条指令都是在CPU中执行的，而执行指令的过程中势必涉及到数据的读取和写入。由于程序运行过程中的临时数据都是存放在主存（物理内存）当中的，这时就存在一个问题，由于CPU执行速度很快">
<meta property="og:image" content="http://images.cnitblog.com/blog/288799/201408/212305263939989.jpg">
<meta property="og:updated_time" content="2017-10-22T07:20:20.020Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="[Java] Java并发编程之volatile关键字">
<meta name="twitter:description" content="说在前面本文转载自文章Java并发编程：volatile关键字解析，作者对volatile关键字的使用以及原理进行了详细的解析，我觉得写的非常好，所以转载下来做个记录，感谢作者。
内存模型的相关概念计算机在执行程序的时候每条指令都是在CPU中执行的，而执行指令的过程中势必涉及到数据的读取和写入。由于程序运行过程中的临时数据都是存放在主存（物理内存）当中的，这时就存在一个问题，由于CPU执行速度很快">
<meta name="twitter:image" content="http://images.cnitblog.com/blog/288799/201408/212305263939989.jpg">
    
        <link rel="alternate" type="application/atom+xml" title="Glemontree&#39;s blog" href="/atom.xml">
    
    <link rel="shortcut icon" href="/img/favicon.ico">
    <link rel="stylesheet" href="//unpkg.com/hexo-theme-material-indigo@latest/css/style.css">
    <script>window.lazyScripts=[]</script>

    <!-- custom head -->
    

</head>

<body>
    <div id="loading" class="active"></div>

    <aside id="menu" class="hide" >
  <div class="inner flex-row-vertical">
    <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="menu-off">
        <i class="icon icon-lg icon-close"></i>
    </a>
    <div class="brand-wrap" style="background-image:url(/img/brand.jpg)">
      <div class="brand">
        <a href="/" class="avatar waves-effect waves-circle waves-light">
          <img src="/img/avatar.jpg">
        </a>
        <hgroup class="introduce">
          <h5 class="nickname">Glemontree</h5>
          <a href="mailto:glemontree@163.com" title="glemontree@163.com" class="mail">glemontree@163.com</a>
        </hgroup>
      </div>
    </div>
    <div class="scroll-wrap flex-col">
      <ul class="nav">
        
            <li class="waves-block waves-effect">
              <a href="/"  >
                <i class="icon icon-lg icon-home"></i>
                Homepage
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/archives"  >
                <i class="icon icon-lg icon-archives"></i>
                Archives
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/tags"  >
                <i class="icon icon-lg icon-tags"></i>
                Tags
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/categories"  >
                <i class="icon icon-lg icon-th-list"></i>
                Categories
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="https://github.com/Glemontree" target="_blank" >
                <i class="icon icon-lg icon-github"></i>
                Github
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="http://www.weibo.com/glemontree" target="_blank" >
                <i class="icon icon-lg icon-weibo"></i>
                Weibo
              </a>
            </li>
        
      </ul>
    </div>
  </div>
</aside>

    <main id="main">
        <header class="top-header" id="header">
    <div class="flex-row">
        <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light on" id="menu-toggle">
          <i class="icon icon-lg icon-navicon"></i>
        </a>
        <div class="flex-col header-title ellipsis">[Java] Java并发编程之volatile关键字</div>
        
        <div class="search-wrap" id="search-wrap">
            <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="back">
                <i class="icon icon-lg icon-chevron-left"></i>
            </a>
            <input type="text" id="key" class="search-input" autocomplete="off" placeholder="输入感兴趣的关键字">
            <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="search">
                <i class="icon icon-lg icon-search"></i>
            </a>
        </div>
        
        
        <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="menuShare">
            <i class="icon icon-lg icon-share-alt"></i>
        </a>
        
    </div>
</header>
<header class="content-header post-header">

    <div class="container fade-scale">
        <h1 class="title">[Java] Java并发编程之volatile关键字</h1>
        <h5 class="subtitle">
            
                <time datetime="2017-10-22T02:10:59.000Z" itemprop="datePublished" class="page-time">
  2017-10-22
</time>


	<ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/Java/">Java</a></li></ul>

            
        </h5>
    </div>

    


</header>


<div class="container body-wrap">
    
    <aside class="post-widget">
        <nav class="post-toc-wrap post-toc-shrink" id="post-toc">
            <h4>TOC</h4>
            <ol class="post-toc"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#说在前面"><span class="post-toc-number">1.</span> <span class="post-toc-text">说在前面</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#内存模型的相关概念"><span class="post-toc-number">2.</span> <span class="post-toc-text">内存模型的相关概念</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#并发编程中的三个概念"><span class="post-toc-number">3.</span> <span class="post-toc-text">并发编程中的三个概念</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#原子性"><span class="post-toc-number">3.1.</span> <span class="post-toc-text">原子性</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#可见性"><span class="post-toc-number">3.2.</span> <span class="post-toc-text">可见性</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#有序性"><span class="post-toc-number">3.3.</span> <span class="post-toc-text">有序性</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#Java内存模型"><span class="post-toc-number">4.</span> <span class="post-toc-text">Java内存模型</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#原子性-1"><span class="post-toc-number">4.1.</span> <span class="post-toc-text">原子性</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#可见性-1"><span class="post-toc-number">4.2.</span> <span class="post-toc-text">可见性</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#有序性-1"><span class="post-toc-number">4.3.</span> <span class="post-toc-text">有序性</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#深入剖析volatile关键字"><span class="post-toc-number">5.</span> <span class="post-toc-text">深入剖析volatile关键字</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#volatile关键字的两层语义"><span class="post-toc-number">5.1.</span> <span class="post-toc-text">volatile关键字的两层语义</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#volatile保证原子性吗？"><span class="post-toc-number">5.2.</span> <span class="post-toc-text">volatile保证原子性吗？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#volatile能保证有序性吗？"><span class="post-toc-number">5.3.</span> <span class="post-toc-text">volatile能保证有序性吗？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#volatile的原理和实现机制"><span class="post-toc-number">5.4.</span> <span class="post-toc-text">volatile的原理和实现机制</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#使用volatile关键字的场景"><span class="post-toc-number">6.</span> <span class="post-toc-text">使用volatile关键字的场景</span></a></li></ol>
        </nav>
    </aside>


<article id="post-[Java] Java并发编程之volatile关键字"
  class="post-article article-type-post fade" itemprop="blogPost">

    <div class="post-card">
        <h1 class="post-card-title">[Java] Java并发编程之volatile关键字</h1>
        <div class="post-meta">
            <time class="post-time" title="2017-10-22 10:10:59" datetime="2017-10-22T02:10:59.000Z"  itemprop="datePublished">2017-10-22</time>

            
	<ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/Java/">Java</a></li></ul>



            
<span id="busuanzi_container_page_pv" title="文章总阅读量" style='display:none'>
    <i class="icon icon-eye icon-pr"></i><span id="busuanzi_value_page_pv"></span>
</span>


        </div>
        <div class="post-content" id="post-content" itemprop="postContent">
            <h2 id="说在前面"><a href="#说在前面" class="headerlink" title="说在前面"></a>说在前面</h2><p>本文转载自文章<a href="http://www.importnew.com/18126.html" target="_blank" rel="external">Java并发编程：volatile关键字解析</a>，作者对volatile关键字的使用以及原理进行了详细的解析，我觉得写的非常好，所以转载下来做个记录，感谢作者。</p>
<h2 id="内存模型的相关概念"><a href="#内存模型的相关概念" class="headerlink" title="内存模型的相关概念"></a>内存模型的相关概念</h2><p>计算机在执行程序的时候每条指令都是在CPU中执行的，而执行指令的过程中势必涉及到数据的读取和写入。由于程序运行过程中的临时数据都是存放在主存（物理内存）当中的，这时就存在一个问题，由于CPU执行速度很快，而从内存读取数据和向内存写入数据的过程和CPU执行指令的速度相比要慢得多，因此如果任何时候对数据的操作都要通过内存的交互来进行，会大大降低指令执行的速度，因此CPU里面就有了高速缓存。</p>
<p>也就是，当程序运行过程中会将运算需要的数据从主存复制一份到CPU的高速缓存当中，那么CPU在进行计算时就可以直接从它的高速缓存中读取数据和向其中写入数据，当运算结束后，再将高速缓存中的数据刷新到主存中，举个简单的例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">i = i + <span class="number">1</span>;</div></pre></td></tr></table></figure>
<p>当线程执行这个语句时，会先从主存中读取i的值，然后复制一份到高速缓存中，然后CPU执行指令对i进行加1操作，然后将数据写入高速缓存，最后将高速缓存中i最新的值刷新到主存当中。</p>
<p>这个代码在单线程中运行是没有任何问题的，但是在多线程中运行就会有问题了，在多核CPU中，每条线程可能运行于不同的CPU，因此每个线程运行时有自己的高速缓存，本文以多核CPU为例。</p>
<p>比如同时有2个线程执行这段代码，假设初始时的i的值为0，那么我们希望两个线程执行完之后i的值变为2，但是事实会是这样吗？</p>
<p>可能存在下面这种情况：初始时，两个线程分别读取i的值存入各自所在的CPU高速缓存中，然后线程1进行加1操作，然后把i的最新值写入到内存，此时线程2的高速缓存当中i的值还是0，进行加1操作之后，i的值为1，然后线程2把i的值写入内存。</p>
<p>最终结果i的值为1，而不是2，这就是著名的缓存一致性问题，通常称这种被多个线程访问的变量为共享变量。</p>
<p>也就是说，如果一个变量在多个CPU中都存在缓存（一般在多线程编程时才会出现），那么就可能存在缓存不一致的问题。</p>
<p>为了解决缓存不一致的问题，通常来说有以下两种解决方法：</p>
<ul>
<li>通过在总线加LOCK#锁的方式</li>
<li>通过缓存一致性协议</li>
</ul>
<p>这两种方式都是硬件层面上提供的方式。</p>
<p>在早期的CPU当中，是通过在总线上加LOCK#锁的形式来解决缓存不一致的问题，因此CPU和其他部件进行通信都是通过总线来进行的，如果对总线加LOCK#锁的话，也就是说阻塞其他CPU对其他部件访问（如内存），从而使得只能有一个CPU能使用这个变量的内存，比如上面的例子中，如果一个线程在执行i=i+1，如果在执行这段代码的过程中在总线上发出了LOCK#锁的信号，那么只能等待这段代码执行完成之后其他CPU才能从变量i所在的内存中读取变量，然后进行相应的操作，这样就解决了缓存不一致的问题。</p>
<p>但是上面的方式存在一个问题，由于在锁住总线的过程中其他CPU无法访问内存，导致效率低下。</p>
<p>所以就出现了缓存一致性协议。最出名的就是Intel 的MESI协议，MESI协议保证了每个缓存中使用的共享变量的副本是一致的。它核心的思想是：当CPU写数据时，如果发现操作的变量是共享变量，即在其他CPU中也存在该变量的副本，会发出信号通知其他CPU将该变量的缓存行置为无效状态，因此当其他CPU需要读取这个变量时，发现自己缓存中缓存该变量的缓存行是无效的，那么它就会从内存重新读取。</p>
<h2 id="并发编程中的三个概念"><a href="#并发编程中的三个概念" class="headerlink" title="并发编程中的三个概念"></a>并发编程中的三个概念</h2><p>在并发编程中，通常会遇到下面三个问题：原子性问题、可见性问题以及有序性问题。</p>
<h3 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h3><p>原子性：即一个操作或者多个操作要么全部执行并且执行的过程不会被任何因素打断，要么就全部不执行。举个最简单的例子，大家想一下假如一个32位的变量赋值过程不具备原子性的话，会发生什么后果？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">i = <span class="number">9</span>;</div></pre></td></tr></table></figure>
<p>假若一个线程执行到这个语句时，我暂且假设为一个32位的变量赋值包含两个过程：为低16位赋值和为高16位赋值。</p>
<p>那么就可能发生一种情况：当将低16位数值写入之后，突然被中断，而此时又有一个线程去读取i的值，那么读取到的值就是错误的数据。</p>
<h3 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h3><p>可见性就是指当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值，举个例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 线程1执行的代码</span></div><div class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</div><div class="line">i = <span class="number">10</span>;</div><div class="line"></div><div class="line"><span class="comment">// 线程2执行的代码</span></div><div class="line">j = i;</div></pre></td></tr></table></figure>
<p>假若执行线程1的是CPU1，执行线程2的是CPU2，由上面的分析可知，当线程1执行i=10这句时，会先把i的初始值加载到CPU1的高速缓存中，然后赋值为10，那么在CPU1的高速缓存中i的值变为10了，却没有立即写入到主存中去。</p>
<p>此时线程2执行j=i，它会先去主存读取i的值并加载到CPU2的缓存当中，注意此时内存当中i的值还是0，那么就会使得j的值为0，而不是10。</p>
<p>这就是可见性问题，线程1对变量i修改了之后，线程2没有立即看到线程1修改的值。</p>
<h3 id="有序性"><a href="#有序性" class="headerlink" title="有序性"></a>有序性</h3><p>有序性：即程序执行的顺序按照代码的先后顺序执行。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</div><div class="line"><span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</div><div class="line">i = <span class="number">1</span>; <span class="comment">// 语句1</span></div><div class="line">flag = <span class="keyword">true</span>; <span class="comment">// 语句2</span></div></pre></td></tr></table></figure>
<p>上面的代码定义了一个int型变量，定义了一个boolean类型变量，然后分别对这两个变量进行赋值操作，从代码顺序上看，语句1是在语句2的前面，那么JVM在真正执行这段代码的时候会保证语句1一定会在语句2前面执行吗？不一定，为什么？这里可能会发生指令重排序。</p>
<p>一般来说，处理器为了提高运行效率，可能会对输入代码进行优化，它不保证程序中各个语句的执行先后顺序同代码中的顺序一致，但是它会保证程序最终运行结果和代码顺序执行的结果是一致的。</p>
<p>比如上面的代码，语句1和语句2谁先执行对最终的程序结果并没有影响，那么就有可能在执行过程中，语句2先执行而语句1后执行。</p>
<p>但是要注意，虽然处理器会对指令进行重排序，但是它会保证程序最终结果会和代码顺序执行效果相同，那么它靠什么来保证呢？再看下面这个例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> a = <span class="number">10</span>; <span class="comment">// 语句1</span></div><div class="line"><span class="keyword">int</span> r = <span class="number">2</span>; <span class="comment">// 语句2</span></div><div class="line">a = a + <span class="number">3</span>; <span class="comment">// 语句3</span></div><div class="line">r = a * a; <span class="comment">// 语句4</span></div></pre></td></tr></table></figure>
<p>这段代码有4个语句，那么可能的一个执行顺序是：</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="http://images.cnitblog.com/blog/288799/201408/212305263939989.jpg" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure>
<p>那么可不可能是这个执行顺序呢： 语句2 语句1 语句4 语句3</p>
<p>不可能，因为处理器在进行重排序时是会考虑指令之间的数据依赖性，如果一个指令Instruction2 必须用到Instruction1的结果，那么处理器会保证Instruction1会在Instruction2 之前执行。</p>
<p>虽然重排序不会影响单个线程内程序执行的结果，但是多线程呢？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 线程1</span></div><div class="line">context = loadContext(); <span class="comment">// 语句1</span></div><div class="line">inited = <span class="keyword">true</span>; <span class="comment">// 语句2</span></div><div class="line"></div><div class="line"><span class="comment">// 线程2</span></div><div class="line"><span class="keyword">while</span> (!inited) &#123;</div><div class="line">  	sleep();</div><div class="line">&#125;</div><div class="line">doSomethingwithconfig(context);</div></pre></td></tr></table></figure>
<p>上面代码中，由于语句1和语句2没有数据依赖性，因此可能会被重排序，假如发生了重排序，在线程1执行过程中先执行语句2，而此时线程2会以为初始化工作已经完成，那么就会跳出while循环，去执行doSomethingwithconfig(context)方法，而此时context没有被初始化，就会导致程序出错。</p>
<p>从上面可以看出，指令重排序不会影响单个线程的执行，但是会影响到线程并发执行的正确性。</p>
<p>也就是说，要想并发程序正确的执行，必须保证原子性、可见性以及有序性。只要有一个没有被保证，就有可能导致程序运行不正确。</p>
<h2 id="Java内存模型"><a href="#Java内存模型" class="headerlink" title="Java内存模型"></a>Java内存模型</h2><p>Java内存模型规定所有的变量都是存在主存当中（类似于前面说的物理内存），每个线程都有自己的工作内存（类似于前面的高速缓存），线程对变量的所有操作都必须在工作内存中进行，而不能直接对主存进行操作，并且每个线程不能访问其他线程的工作内存。</p>
<p>举个简单的例子，在Java中，执行下面的语句：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">i = <span class="number">10</span>;</div></pre></td></tr></table></figure>
<p>执行线程必须先在自己的工作线程中对变量i所在的缓存进行赋值操作，然后再写入主存当中，而不是直接将数值10写入主存当中。</p>
<p>那么Java语言本身对原子性、可见性以及有序性提供了哪些保证呢？</p>
<h3 id="原子性-1"><a href="#原子性-1" class="headerlink" title="原子性"></a>原子性</h3><p>在Java中，对基本数据类型的变量的读取和赋值操作是原子性操作，即这些操作是不可被中断的，要么执行，要么不执行。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">x = <span class="number">10</span>; <span class="comment">// 语句1</span></div><div class="line">y = x; <span class="comment">// 语句2</span></div><div class="line">x++; <span class="comment">// 语句3</span></div><div class="line">x = x + <span class="number">1</span>; <span class="comment">// 语句4</span></div></pre></td></tr></table></figure>
<p>上面的语句只有语句1是原子性操作，其他3个语句都不是原子性操作。语句1是直接将数值10赋值给x，也就是说线程执行这个语句的会直接将数值10写入到工作内存中。</p>
<p>语句2实际上包含2个操作，它先去读取x的值，再将x的值写入工作内存，虽然读取x的值以及将x的值写入工作内存这2个操作都是原子性操作，但是合起来就不是原子性操作了。</p>
<p>同样地，x++和x = x + 1包含3个操作：读取x的值，进行加1操作，写入新的值。</p>
<p>也就是说，只有简单的读取、赋值（而且必须是将数字赋值给某个变量，变量之间的赋值不是原子操作）才是原子操作。</p>
<h3 id="可见性-1"><a href="#可见性-1" class="headerlink" title="可见性"></a>可见性</h3><p>对于可见性，Java提供了volatile关键字来保证可见性。</p>
<p>当一个共享变量被volatile修饰时，它会保证修改的值立即被更新到主存，当有其他线程需要读取时，它会去内存中读取新值。</p>
<p>而普通的共享变量不能保证可见性，因为普通共享变量被修改之后，什么时候被写入主存是不确定的，当其他线程去读取时，此时内存中可能还是原来的旧值，因此无法保证可见性。</p>
<p>另外，通过synchronized和Lock也能够保证可见性，synchronized和Lock能保证同一时刻只有一个线程获取锁然后执行同步代码，并且在释放锁之前会对变量的修改刷新到主存中，因此可以保证可见性。</p>
<h3 id="有序性-1"><a href="#有序性-1" class="headerlink" title="有序性"></a>有序性</h3><p>在Java内存模型中，允许编译器和处理器会指令进行重排序，但是重排序过程不会影响到单线程程序的执行，却会影响到多线程并发执行的正确性。</p>
<p>在Java里面，可以通过volatile关键字来保证一定的有序性，另外可以通过synchronized和Lock来保证有序性，很显然，synchronized和Lock保证每个时刻是有一个线程执行同步代码，相当于是让线程顺序执行同步代码，自然保证了有序性。</p>
<p>另外，Java内存模型具备一些先天的有序性，即不需要通过任何手段就能够保证的有序性，这个通常也称为happens-before原则，如果两个操作的执行次序无法从happens-before原则推倒出来，那么它们就不能保证它们的有序性，虚拟机可以随意的对它们进行重排序。</p>
<h2 id="深入剖析volatile关键字"><a href="#深入剖析volatile关键字" class="headerlink" title="深入剖析volatile关键字"></a>深入剖析volatile关键字</h2><h3 id="volatile关键字的两层语义"><a href="#volatile关键字的两层语义" class="headerlink" title="volatile关键字的两层语义"></a>volatile关键字的两层语义</h3><p>一旦一个共享变量（类的成员变量、类的静态成员变量）被volatile修饰之后，那么就具备了两层语义：</p>
<ul>
<li>保证了不同线程对这个变量进行操作时的可见性，即一个线程修改了某个变量的值，这新值对其他线程来说是立即可见的</li>
<li>禁止进行指令重排序</li>
</ul>
<p>先看一段代码，加入线程1先执行，线程2后执行：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 线程1</span></div><div class="line"><span class="keyword">boolean</span> stop = <span class="keyword">false</span>;</div><div class="line"><span class="keyword">while</span> (!stop) &#123;</div><div class="line">  	doSomething();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 线程2</span></div><div class="line">stop = <span class="keyword">true</span>;</div></pre></td></tr></table></figure>
<p>这段代码是很典型的一段代码，很多人在中断线程时可能都会采用这种标记办法。但是事实上，这段代码会完全运行正确么？即一定会将线程中断么？不一定，也许在大多数时候，这个代码能够把线程中断，但是也有可能会导致无法中断线程（虽然这个可能性很小，但是只要一旦发生这种情况就会造成死循环了）。</p>
<p>下面解释一下这段代码为何有可能导致无法中断线程。在前面已经解释过，每个线程在运行过程中都有自己的工作内存，那么线程1在运行的时候，会将stop变量的值拷贝一份放在自己的工作内存当中。</p>
<p>那么当线程2更改了stop变量的值之后，但是还没来得及写入主存当中，线程2转去做其他事情了，那么线程1由于不知道线程2对stop变量的更改，因此还会一直循环下去。</p>
<p>但是用volatile修饰之后就变得不一样了：</p>
<p>第一：使用volatile关键字会强制将修改的值立即写入主存；</p>
<p>第二：使用volatile关键字的话，当线程2进行修改时，会导致线程1的工作内存中缓存变量stop的缓存行无效（反映到硬件层的话，就是CPU的L1或者L2缓存中对应的缓存行无效）；</p>
<p>第三：由于线程1的工作内存中缓存变量stop的缓存行无效，所以线程1再次读取变量stop的值时会去主存读取。</p>
<p>那么在线程2修改stop值时（当然这里包括2个操作，修改线程2工作内存中的值，然后将修改后的值写入内存），会使得线程1的工作内存中缓存变量stop的缓存行无效，然后线程1读取时，发现自己的缓存行无效，它会等待缓存行对应的主存地址被更新之后，然后去对应的主存读取最新的值。</p>
<p>那么线程1读取到的就是最新的正确的值。</p>
<h3 id="volatile保证原子性吗？"><a href="#volatile保证原子性吗？" class="headerlink" title="volatile保证原子性吗？"></a>volatile保证原子性吗？</h3><p>不能，volatile关键字能保证可见性没有错，但是并不能保证原子性，可见性只能保证每次读取的是最新的值，但是volatile没办法保证对变量的操作的原子性。</p>
<h3 id="volatile能保证有序性吗？"><a href="#volatile能保证有序性吗？" class="headerlink" title="volatile能保证有序性吗？"></a>volatile能保证有序性吗？</h3><p>volatile能在一定程度上保证有序性，volatile关键字禁止指令重排序有两层意思：</p>
<ul>
<li>当程序执行到volatile变量的读操作或者写操作时，在其前面的操作的更改肯定全部已经执行，其结果已经对后面的操作可见，在其后面的操作肯定还没有执行；</li>
<li>在进行指令优化时，不能将在对volatile变量访问的语句放在其后面执行，也不能把volatile变量后面的语句放在其前面执行</li>
</ul>
<p>看下面这个例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//x、y为非volatile变量</span></div><div class="line"><span class="comment">//flag为volatile变量</span></div><div class="line">x = <span class="number">2</span>;        <span class="comment">//语句1</span></div><div class="line">y = <span class="number">0</span>;        <span class="comment">//语句2</span></div><div class="line">flag = <span class="keyword">true</span>;  <span class="comment">//语句3</span></div><div class="line">x = <span class="number">4</span>;         <span class="comment">//语句4</span></div><div class="line">y = -<span class="number">1</span>;       <span class="comment">//语句5</span></div></pre></td></tr></table></figure>
<p>由于flag变量为volatile变量，那么在进行指令重排序的过程的时候，不会将语句3放到语句1、语句2前面，也不会将语句3放到语句4和语句5的后面，但是要注意语句1和语句2的顺序、语句4和语句5的顺序是不作任何保证的。</p>
<p>并且voloatile关键字能保证执行到语句3的时候，语句1和语句2必定是执行完毕的，且语句1和语句2的执行结果对语句3、语句4、语句5是可见的。</p>
<p>那么我们回到前面的一个例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//线程1:</span></div><div class="line">context = loadContext();   <span class="comment">//语句1</span></div><div class="line">inited = <span class="keyword">true</span>;             <span class="comment">//语句2</span></div><div class="line"> </div><div class="line"><span class="comment">//线程2:</span></div><div class="line"><span class="keyword">while</span>(!inited )&#123;</div><div class="line">  sleep()</div><div class="line">&#125;</div><div class="line">doSomethingwithconfig(context);</div></pre></td></tr></table></figure>
<p>前面举这个例子的时候，提到有可能语句2会在语句1之前执行，那么就可能导致context还没被初始化，而线程2中就使用未初始化的context去进行操作，导致程序出错。</p>
<p>这里如果用volatile关键字对inited变量进行修饰，就不会出现这种问题了，因为当执行到语句2时，必定能保证context已经初始化完毕。</p>
<h3 id="volatile的原理和实现机制"><a href="#volatile的原理和实现机制" class="headerlink" title="volatile的原理和实现机制"></a>volatile的原理和实现机制</h3><p>“观察加入volatile关键字和没有加入volatile关键字时所生成的汇编代码发现，加入volatile关键字时，会多出一个lock前缀指令”</p>
<p>lock前缀指令实际上相当于一个内存屏障（也成内存栅栏），内存屏障会提供3个功能：</p>
<ul>
<li>它确保指令重排序时不会把其后面的指令排到内存屏障之前的位置，也不会把前面的指令排到内存屏障的后面；即在执行到内存屏障这句指令时，在它前面的操作已经全部完成；</li>
<li>它会强制将对缓存的修改操作立即写入主存；</li>
<li>如果是写操作，它会导致其他CPU中对应的缓存行无效。</li>
</ul>
<h2 id="使用volatile关键字的场景"><a href="#使用volatile关键字的场景" class="headerlink" title="使用volatile关键字的场景"></a>使用volatile关键字的场景</h2><p>通常来说，使用volatile必须具备以下两个条件：</p>
<ul>
<li>对变量的写操作不依赖于当前值</li>
<li>该变量没有包含在具有其他变量的不变式中</li>
</ul>
<p>实际上这些条件表明可以被写入volatile变量的这些有效值独立于任何程序的状态，包括变量的当前状态。</p>
<p>事实上，上面的这两个条件需要保证操作是原子性操作，才能保证使用volatile关键字的程序在并发时能够正确执行。</p>
<ul>
<li><p>状态标记量</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">volatile</span> <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</div><div class="line"> </div><div class="line"><span class="keyword">while</span>(!flag)&#123;</div><div class="line">    doSomething();</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setFlag</span><span class="params">()</span> </span>&#123;</div><div class="line">    flag = <span class="keyword">true</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">volatile</span> <span class="keyword">boolean</span> inited = <span class="keyword">false</span>;</div><div class="line"><span class="comment">//线程1:</span></div><div class="line">context = loadContext();  </div><div class="line">inited = <span class="keyword">true</span>;            </div><div class="line"> </div><div class="line"><span class="comment">//线程2:</span></div><div class="line"><span class="keyword">while</span>(!inited )&#123;</div><div class="line">sleep()</div><div class="line">&#125;</div><div class="line">doSomethingwithconfig(context);</div></pre></td></tr></table></figure>
</li>
<li><p>double check</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton instance = <span class="keyword">null</span>;</div><div class="line"> </div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</div><div class="line"> </div><div class="line">    &#125;</div><div class="line"> </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span>(instance==<span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">synchronized</span> (Singleton.class) &#123;</div><div class="line">                <span class="keyword">if</span>(instance==<span class="keyword">null</span>)</div><div class="line">                    instance = <span class="keyword">new</span> Singleton();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> instance;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>​</p>
</li>
</ul>

        </div>

        <blockquote class="post-copyright">
    
    <div class="content">
        
<span class="post-time">
    最后更新时间：<time datetime="2017-10-22T07:20:20.020Z" itemprop="dateUpdated">2017-10-22 15:20:20</time>
</span><br>


        
        <a href="/2017/10/22/[Java] Java并发编程之volatile关键字/" target="_blank" rel="external">https://glemontree.github.io/2017/10/22/[Java] Java并发编程之volatile关键字/</a>
        
    </div>
    
    <footer>
        <a href="https://glemontree.github.io">
            <img src="/img/avatar.jpg" alt="Glemontree">
            Glemontree
        </a>
    </footer>
</blockquote>

        
<div class="page-reward">
    <a id="rewardBtn" href="javascript:;" class="page-reward-btn waves-effect waves-circle waves-light">赏</a>
</div>



        <div class="post-footer">
            
	<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java-并发-volatile/">Java 并发 volatile</a></li></ul>


            
<div class="page-share-wrap">
    

<div class="page-share" id="pageShare">
    <ul class="reset share-icons">
      <li>
        <a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=https://glemontree.github.io/2017/10/22/[Java] Java并发编程之volatile关键字/&title=《[Java] Java并发编程之volatile关键字》 — Glemontree's blog&pic=https://glemontree.github.io/img/avatar.jpg" data-title="微博">
          <i class="icon icon-weibo"></i>
        </a>
      </li>
      <li>
        <a class="weixin share-sns wxFab" href="javascript:;" data-title="微信">
          <i class="icon icon-weixin"></i>
        </a>
      </li>
      <li>
        <a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=https://glemontree.github.io/2017/10/22/[Java] Java并发编程之volatile关键字/&title=《[Java] Java并发编程之volatile关键字》 — Glemontree's blog&source=记录我学习的每一步" data-title=" QQ">
          <i class="icon icon-qq"></i>
        </a>
      </li>
      <li>
        <a class="facebook share-sns" target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=https://glemontree.github.io/2017/10/22/[Java] Java并发编程之volatile关键字/" data-title=" Facebook">
          <i class="icon icon-facebook"></i>
        </a>
      </li>
      <li>
        <a class="twitter share-sns" target="_blank" href="https://twitter.com/intent/tweet?text=《[Java] Java并发编程之volatile关键字》 — Glemontree's blog&url=https://glemontree.github.io/2017/10/22/[Java] Java并发编程之volatile关键字/&via=https://glemontree.github.io" data-title=" Twitter">
          <i class="icon icon-twitter"></i>
        </a>
      </li>
      <li>
        <a class="google share-sns" target="_blank" href="https://plus.google.com/share?url=https://glemontree.github.io/2017/10/22/[Java] Java并发编程之volatile关键字/" data-title=" Google+">
          <i class="icon icon-google-plus"></i>
        </a>
      </li>
    </ul>
 </div>



    <a href="javascript:;" id="shareFab" class="page-share-fab waves-effect waves-circle">
        <i class="icon icon-share-alt icon-lg"></i>
    </a>
</div>



        </div>
    </div>

    
<nav class="post-nav flex-row flex-justify-between">
  
    <div class="waves-block waves-effect prev">
      <a href="/2017/10/23/[Linux] Linux中的伙伴系统和slab机制/" id="post-prev" class="post-nav-link">
        <div class="tips"><i class="icon icon-angle-left icon-lg icon-pr"></i> Prev</div>
        <h4 class="title">[Linux] Linux中的伙伴系统和slab机制</h4>
      </a>
    </div>
  

  
    <div class="waves-block waves-effect next">
      <a href="/2017/10/20/[Java] Java面试题/" id="post-next" class="post-nav-link">
        <div class="tips">Next <i class="icon icon-angle-right icon-lg icon-pl"></i></div>
        <h4 class="title">[Java] Java面试题</h4>
      </a>
    </div>
  
</nav>



    











    <!-- Valine Comments -->
    <div class="comments vcomment" id="comments"></div>
    <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
    <script src="//unpkg.com/valine@latest/dist/Valine.min.js"></script>
    <!-- Valine Comments script -->
    <script>
        var GUEST_INFO = ['nick','mail','link'];
        var guest_info = 'nick,mail,link'.split(',').filter(function(item){
          return GUEST_INFO.indexOf(item) > -1
        });
        new Valine({
            el: '#comments',
            notify: 'false' == 'true',
            verify: 'false' == 'true',
            appId: "Xkpzm75UqDRakK5m745rI78u-gzGzoHsz",
            appKey: "nttscBKerm7QwkliKPpUSrln",
            avatar: "mm",
            placeholder: "Just go go",
            guest_info: guest_info.length == 0 ? GUEST_INFO : guest_info,
            pageSize: "10"
        })
    </script>
    <!-- Valine Comments end -->







</article>

<div id="reward" class="page-modal reward-lay">
    <a class="close" href="javascript:;"><i class="icon icon-close"></i></a>
    <h3 class="reward-title">
        <i class="icon icon-quote-left"></i>
        谢谢打赏
        <i class="icon icon-quote-right"></i>
    </h3>
    <div class="reward-content">
        
        <div class="reward-code">
            <img id="rewardCode" src="/img/wechat.jpg" alt="打赏二维码">
        </div>
        
        <label class="reward-toggle">
            <input id="rewardToggle" type="checkbox" class="reward-toggle-check"
                data-wechat="/img/wechat.jpg" data-alipay="/img/alipay.jpg">
            <div class="reward-toggle-ctrol">
                <span class="reward-toggle-item wechat">微信</span>
                <span class="reward-toggle-label"></span>
                <span class="reward-toggle-item alipay">支付宝</span>
            </div>
        </label>
        
    </div>
</div>



</div>

        <footer class="footer">
    <div class="top">
        
<p>
    <span id="busuanzi_container_site_uv" style='display:none'>
        站点总访客数：<span id="busuanzi_value_site_uv"></span>
    </span>
    <span id="busuanzi_container_site_pv" style='display:none'>
        站点总访问量：<span id="busuanzi_value_site_pv"></span>
    </span>
</p>


        <p>
            
                <span><a href="/atom.xml" target="_blank" class="rss" title="rss"><i class="icon icon-lg icon-rss"></i></a></span>
            
            <span>博客内容遵循 <a rel="license" href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh">知识共享 署名 - 非商业性 - 相同方式共享 4.0 国际协议</a></span>
        </p>
    </div>
    <div class="bottom">
        <p><span>Glemontree &copy; 2017 - 2019</span>
            <span>
                
                Power by <a href="http://hexo.io/" target="_blank">Hexo</a> Theme <a href="https://github.com/yscoder/hexo-theme-indigo" target="_blank">indigo</a>
            </span>
        </p>
    </div>
</footer>

    </main>
    <div class="mask" id="mask"></div>
<a href="javascript:;" id="gotop" class="waves-effect waves-circle waves-light"><span class="icon icon-lg icon-chevron-up"></span></a>



<div class="global-share" id="globalShare">
    <ul class="reset share-icons">
      <li>
        <a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=https://glemontree.github.io/2017/10/22/[Java] Java并发编程之volatile关键字/&title=《[Java] Java并发编程之volatile关键字》 — Glemontree's blog&pic=https://glemontree.github.io/img/avatar.jpg" data-title="微博">
          <i class="icon icon-weibo"></i>
        </a>
      </li>
      <li>
        <a class="weixin share-sns wxFab" href="javascript:;" data-title="微信">
          <i class="icon icon-weixin"></i>
        </a>
      </li>
      <li>
        <a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=https://glemontree.github.io/2017/10/22/[Java] Java并发编程之volatile关键字/&title=《[Java] Java并发编程之volatile关键字》 — Glemontree's blog&source=记录我学习的每一步" data-title=" QQ">
          <i class="icon icon-qq"></i>
        </a>
      </li>
      <li>
        <a class="facebook share-sns" target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=https://glemontree.github.io/2017/10/22/[Java] Java并发编程之volatile关键字/" data-title=" Facebook">
          <i class="icon icon-facebook"></i>
        </a>
      </li>
      <li>
        <a class="twitter share-sns" target="_blank" href="https://twitter.com/intent/tweet?text=《[Java] Java并发编程之volatile关键字》 — Glemontree's blog&url=https://glemontree.github.io/2017/10/22/[Java] Java并发编程之volatile关键字/&via=https://glemontree.github.io" data-title=" Twitter">
          <i class="icon icon-twitter"></i>
        </a>
      </li>
      <li>
        <a class="google share-sns" target="_blank" href="https://plus.google.com/share?url=https://glemontree.github.io/2017/10/22/[Java] Java并发编程之volatile关键字/" data-title=" Google+">
          <i class="icon icon-google-plus"></i>
        </a>
      </li>
    </ul>
 </div>


<div class="page-modal wx-share" id="wxShare">
    <a class="close" href="javascript:;"><i class="icon icon-close"></i></a>
    <p>扫一扫，分享到微信</p>
    <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAN4AAADeCAAAAAB3DOFrAAACsElEQVR42u3aQZacMAwFwNz/0pMLBOZ/ye70oljxGtqmWNhC0p8/8fHzcDzd+f77+/nTL08jHzjw8PDwDj16MnE7wvu8T1dnM+Lh4eHd5s2W8vzqOyPZft5nefwdDw8P74t5ecCd35+/RDw8PLxv5rWwPMXQBvF4eHh4/5e3D2fznGoSTLcv6ECuBQ8PD28eu9aP9fnzK/U9PDw8vHVVfVYMy+9p76+fFg8PD+8CL19w23aoPAhur7bPiYeHh3eW917IbxsF8i1k39oVBf14eHh4l3nJQLNSWf6vTSD+S2UPDw8P7yhvFhzn4yTjt1tRkYbAw8PDO8qbNVrNlvjNFpLPOKzj4eHh4cW8NkSetUy1AXSbqvilvoeHh4d3lPf+EPlnf5IyyNfq9mqxqeDh4eF9hNeGxW2rQZ4EyZO5xcaAh4eHN+K1Q8+C4zz4Plskw8PDw/sM71QYnZfW2tarosUBDw8P7ygv3wDyifepirxNISqA4eHh4R3lzRIK7WLdpnHz/x5oIMDDw8Nb8PKP/NvFsM0sUU8uHh4e3oKXTzCsp5UltLzpKtp+8PDw8K7x8nLULFJtm1Db1/24VeDh4eFd451iDCP6RQp4mGXBw8PDO8Qr2pjiDaB9WUkAnQfoeHh4eDd4yUCb5oDZ5jEriT2+Ajw8PLzLvH3geyr5e6ychoeHh/cRXhsEz0bYF9Wif+Hh4eF9kJcErzPMZquotxA8PDy8o7yf8tinZWfnyYv7x1U8PDy8C7x22U0+/us0axwib8p1eHh4eGd57dCzuvwm7bvaGPDw8PCu8WZL/Ka0n7yyNg2Bh4eH9828fPnOGfkGU3wl4OHh4X0Bry2e5WMmRbg6XYuHh4d3jZckI/IUQ5t6aBf94tnw8PDwLvA2H/z7NqmcempePDw8vMW8fwH8++4DKBKyCAAAAABJRU5ErkJggg==" alt="微信分享二维码">
</div>




    <script src="//cdn.bootcss.com/node-waves/0.7.4/waves.min.js"></script>
<script>
var BLOG = { ROOT: '/', SHARE: true, REWARD: true };


lazyScripts.push('//s95.cnzz.com/z_stat.php?id=1273392949&web_id=1273392949')

</script>

<script src="//unpkg.com/hexo-theme-material-indigo@latest/js/main.min.js"></script>


<div class="search-panel" id="search-panel">
    <ul class="search-result" id="search-result"></ul>
</div>
<template id="search-tpl">
<li class="item">
    <a href="{path}" class="waves-block waves-effect">
        <div class="title ellipsis" title="{title}">{title}</div>
        <div class="flex-row flex-middle">
            <div class="tags ellipsis">
                {tags}
            </div>
            <time class="flex-col time">{date}</time>
        </div>
    </a>
</li>
</template>

<script src="//unpkg.com/hexo-theme-material-indigo@latest/js/search.min.js" async></script>






<script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>



<script>
(function() {
    var OriginTitile = document.title, titleTime;
    document.addEventListener('visibilitychange', function() {
        if (document.hidden) {
            document.title = '死鬼去哪里了！';
            clearTimeout(titleTime);
        } else {
            document.title = '(つェ⊂)咦!又好了!';
            titleTime = setTimeout(function() {
                document.title = OriginTitile;
            },2000);
        }
    });
})();
</script>



</body>
</html>
